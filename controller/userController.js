const { Category,SubCategory, SubCategoryAddField, SubCategoryMandatoryField, EcomLR, ExpLR, Admin, SupportTicket,UnprocessedOrder, ExpProductDetails, ExpOrders, ConsigneeDetails, ExpConsigneeDetails, EcomOrders, EcomProductDetails, EcomConsigneeDetails, TblDeliveryReattempts,TblRtoRequests, TblEscalation, NdrReason, UpdatedCustomerDetail, TblEscalationEcom, TblRtoRequestsecom, TblDeliveryReattemptsEcom, Ibr, AutomationFlow, EcomNdrReason, ExpNdrReason, Callecom, Callexp, AddressVerificationLog, CodSummary, CreateLR, TblBankRecovSpoid, TblBankRemitence, TblCodSummary

} = require('../models/index.js');


const { mySqlQury } = require('../middleware/db');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const access = require('../middleware/access');
const axios = require('axios');
const path = require('path');
// const mysql = require('mysql');
const uuid = require('uuid');
const { validateCustomerDetails, validateMultiOrderData, validateWarehouseData, validateForwarderForm1, validateAggregatorForm1,
  validateAggregatorForm3, validateAggregatorForm3Standard, validateClientOnboarding, validateClientSignIn, validateExpressCreateOrderData } = require('../middleware/validation');
const { title } = require('process');
// const axios = require('axios');
const FormData = require('form-data');
const csv = require('fast-csv');
const fs = require('fs');
const xlsx = require('xlsx');
const { Console, log } = require('console');
const { CONNREFUSED } = require('dns');
const moment = require('moment');

// const {crypto,ran} = require('crypto');
const sha256 = require('sha256');
const PDFDocument = require('pdfkit');
const bwipjs = require('bwip-js')
const puppeteer = require('puppeteer');
const nodemailer = require('nodemailer');
const crypto = require('crypto')
// Add this with your other imports at the top of the file
const { Parser } = require('json2csv');
const dashboardService = require('../services/dashboardServices');
const roleUtils = require('../utility/roleUtility');
const { getRolesByLevel, mappingRoles } = require('../config/mapRoles');
const { is_user_allowed, getAllowedUserContext, getClientParentInfo } = require('../utility/userContext');
const { message } = require('statuses');
const { getEffectiveUserId, safeInsertRole } = require('../utility/getEffectiveUserId');
const determineOriginZoneAggregator = require('../utility/determineOriginZoneAgg');
const {determineForwarderOriginZone, determineForwarderOriginEcomZone} = require('../utility/determineForwarderOriginZone');
const checkOdaStatus = require('../utility/checkOdaStatus');
const calculateVolumetricWeightLTL = require('../utility/calculateVolumetricWeightLTL');
const {calculateAdditionalChargesForwarder, calculateAdditionalChargesForwarderEcom} = require('../utility/calculateAdditionalChargesForwarder');
const calculateVolumetricWeight = require('../utility/calculateVolumetricWeight');
const computeVolumetricWeight = require('../utility/computeVolumetricWeight');
const unflattenSlabInputs = require('../services/unflattenSlabInputs');
const socket = require('../routes/socket/socket.js'); // Import the io instance
const updateWalletAndTransaction = require('../services/updateWalletAndTransaction.js');
const getValidDeliveryApiToken = require('../services/getValidDeliveryApiToken.js');
const {findRateForwarder, findRateForwarderEcom} = require('../services/findRateForwarder.js');
const {findRateAggrigator, findRateAggrigatorEcom} = require('../services/findRateAggrigator.js');
const fetchExpressBeesToken = require('../services/fetchExpressBeesToken.js');
const checkServiceability = require('../services/checkServiceability.js');
const {calculateAdditionalCharges,calculateAdditionalChargesEcom} = require('../services/calculateAdditionalCharges.js');
const { is } = require('type-is');
const supportService = require('../services/supportService.js');
// const { TicketModel } = require('../models/Ticket.js');
const initTicket = require('../models/Ticket');       // default export is a function
const { Sequelize, Op } = require('sequelize');

// SINGLE definition (do not redeclare Ticket anywhere else)
// const Ticket = sequelize.models.Ticket || initTicket(sequelize, DataTypes);

const loginPage = (req, res, next) => {
  const token = req.cookies.jwt;
 
  if (token) {
    try {
      // âœ… Verify token
      jwt.verify(token, process.env.TOKEN_KEY);
      // If valid, redirect to index
      return res.redirect("/index");
    } catch (err) {
      // If expired/invalid, clear cookie and show login page
      res.clearCookie("jwt");
    }
  }
 
  // No token or invalid token â†’ show login page
  res.render("pages/login", {
    title: "Log In",
    layout: "partials/layout-auth"
  });
};


function issueToken(res, payload) {
  const token = jwt.sign(payload, process.env.TOKEN_KEY, { expiresIn: "6h" });
  res.cookie("jwt", token, {
    expires: new Date(Date.now() + 6 * 60 * 60 * 1000), // 6h cookie
    httpOnly: true,
    sameSite: "lax",
  });
  return token;
} 




async function expCall(req, res) {
  try {
    const {
      order_id,
      name,
      phone_no,
      company_name,
      call_connected,
      not_connected_reason,
      customer_response,
    } = req.body;

    if (!order_id || !call_connected) {
      return res.status(400).json({
        ok: false,
        error: "order_id and call_connected are required",
      });
    }

    // ðŸ”¹ Try to find existing log for this order
    const [log, created] = await Callexp.findOrCreate({
      where: { order_id },
      defaults: {
        name,
        phone_no,
        company_name: company_name || null,
        call_connected,
        not_connected_reason: call_connected === "no" ? not_connected_reason : null,
        customer_response: call_connected === "yes" ? customer_response : null,
      },
    });

    if (!created) {
      await log.update({
        name,
        phone_no,
        company_name: company_name || null,
        call_connected,
        not_connected_reason: call_connected === "no" ? not_connected_reason : null,
        customer_response: call_connected === "yes" ? customer_response : null,
      });
    }

    return res.status(201).json({
      ok: true,
      message: "Express call log saved successfully",
      data: log,
    });
  } catch (err) {
    console.error("âŒ [expCall] Error:", err);
    return res.status(500).json({
      ok: false,
      error: err.message || "Server error",
    });
  }
}



async function ecomCall(req, res) {
  try {
    const {
      order_id,
      name,
      phone_no,
      company_name,
      call_connected,
      not_connected_reason,
      customer_response,
    } = req.body;

    if (!order_id || !call_connected) {
      return res.status(400).json({
        ok: false,
        error: "order_id and call_connected are required",
      });
    }

    // ðŸ”¹ Try to find existing log for this order
    const [log, created] = await Callecom.findOrCreate({
      where: { order_id },
      defaults: {
        name,
        phone_no,
        company_name: company_name || null,
        call_connected,
        not_connected_reason: call_connected === "no" ? not_connected_reason : null,
        customer_response: call_connected === "yes" ? customer_response : null,
      },
    });

    if (!created) {
      await log.update({
        name,
        phone_no,
        company_name: company_name || null,
        call_connected,
        not_connected_reason: call_connected === "no" ? not_connected_reason : null,
        customer_response: call_connected === "yes" ? customer_response : null,
      });
    }

    return res.status(201).json({
      ok: true,
      message: "Call log saved successfully",
      data: log,
    });
  } catch (err) {
    console.error("âŒ [ecomCall] Error:", err);
    return res.status(500).json({
      ok: false,
      error: err.message || "Server error",
    });
  }
}
// const loginAuth = async (req, res) => {
//   try {
//     const { password } = req.body || {};
//     const email = (req.body?.username || "").trim();

//     if (!email || !password) {
//       return res.status(400).json({ error: "Email and password are required." });
//     }

//     // 1) Fetch user
//     const [user] = await mySqlQury(
//       `SELECT id, first_name, last_name, email, password, role, role_id,
//               client_id, is_active, is_verified, is_kyc_submitted, is_kyc_verified,
//               level, parent_id, logo_path, company_name
//        FROM tbl_admin
//        WHERE email = ?
//        LIMIT 1`,
//       [email]
//     );

//     if (!user) {
//       return res.status(401).json({ error: "Your email is not registered" });
//     }

//     // 2) Password check
//     const okPass = await bcrypt.compare(password, user.password || "");
//     if (!okPass) {
//       req?.flash?.("errors", "your password is wrong");
//       return res.status(401).json({ error: "Your password is wrong" });
//     }

//     // helpers
//     const toNum = (v) => (v == null ? null : Number(v));
//     const role_id = toNum(user.role_id);
//     const level = toNum(user.level);
//     const parent_id = toNum(user.parent_id);

//     // 3) Role info
//     let roleName = "";
//     let rolesArray = [];
//     if (role_id) {
//       const [roleData] = await mySqlQury(
//         `SELECT id, name, description FROM roles WHERE id = ? LIMIT 1`,
//         [role_id]
//       );
//       roleName = roleData?.name || "";
//       rolesArray = roleData?.description ? roleUtils.parseRoles(roleData.description) : [];
//     }

//     // 4) Choose guard record (level 4 => client governs KYC/verification)
//     let guardSource = "user";
//     let guardRecord = user;
//     let clientRecord = null;

//     if (level === 4) {
//       if (!parent_id) {
//         return res.status(403).json({ error: "Client linkage missing for this user." });
//       }

//       const [clientRow] = await mySqlQury(
//         `SELECT id, first_name, last_name, email, role, role_id,
//                 client_id, is_active, is_verified, is_kyc_submitted, is_kyc_verified,
//                 level, parent_id, logo_path, company_name
//          FROM tbl_admin
//          WHERE id = ?
//          LIMIT 1`,
//         [parent_id]
//       );
//       if (!clientRow) {
//         return res.status(403).json({ error: "Client account not found for this user." });
//       }

//       clientRecord = clientRow;
//       guardSource = "client";
//       guardRecord = clientRow;

//       // require both user & client active
//       if (toNum(user.is_active) !== 1) {
//         return res.status(403).json({ error: "Your user account is inactive. Please contact support.", isInactive: true });
//       }
//       if (
//         toNum(clientRow.is_active) !== 1 ||
//         toNum(clientRow.is_kyc_verified) !== 1 ||
//         toNum(clientRow.is_kyc_submitted) !== 1
//       ) {
//         return res.status(403).json({ error: "Your client account is inactive. Please contact support.", isInactive: true });
//       }
//     } else {
//       if (toNum(user.is_active) !== 1) {
//         return res.status(403).json({ error: "Your account is inactive. Please contact support.", isInactive: true });
//       }
//     }

//     // 5) Email verification & pre-KYC gates
//     if (toNum(guardRecord.is_verified) !== 1) {
//       return res.status(403).json({ error: "Your email is not verified. Please check your inbox." });
//     }

//     // Base payload used for KYC-redirect tokens
//     const basePayload = {
//       id: user.id,
//       name: user.first_name,
//       email: user.email,
//       isActive: toNum(user.is_active),
//       level,
//       parent_id: parent_id ?? null,
//       roleName,
//       rolesArray,
//       role_id,
//       clientId: (level === 4 ? parent_id : (toNum(user.client_id) || null)),
//       clientOnboardedID: (level === 4 ? parent_id : null),
//       logo_path: user.logo_path ?? null,
//       last_name: user.last_name ?? null,
//       company_name: user.company_name ?? null,
//       segmentType: null,               // unknown until KYC verified
//       is_kyc_verified: false           // explicitly false for KYC gates
//     };

//     if (toNum(guardRecord.is_kyc_submitted) === 0) {
//       const token = issueToken(res, basePayload);
//       return res.status(200).json({
//         redirect: "/kyc",
//         message: "Please complete your KYC.",
//         is_kyc_verified: false,
//         token
//       });
//     }

//     if (toNum(guardRecord.is_kyc_submitted) === 1 && toNum(guardRecord.is_kyc_verified) === 0) {
//       const token = issueToken(res, basePayload);
//       return res.status(200).json({
//         redirect: "/kyc",
//         message: "KYC pending approval.",
//         is_kyc_verified: false,
//         token
//       });
//     }

//     // 6) Segment Type (for verified flows)
//     const kycOwnerId = (level === 4 && clientRecord) ? clientRecord.id : user.id;
//     let segmentType = null;
//     try {
//       const kycData = await mySqlQury(
//         `SELECT segment_type FROM kyc_submissions WHERE user_id = ? ORDER BY id DESC LIMIT 1`,
//         [kycOwnerId]
//       );
//       let raw = kycData?.[0]?.segment_type || null;
//       if (raw && typeof raw === "string") {
//         raw = raw.trim().toLowerCase();
//         if (raw === "ecommerce" || raw === "e-com") raw = "ecom";
//         if (raw === "express" || raw === "exp") raw = "express";
//         segmentType = raw;
//       }
//     } catch (err) {
//       console.log("KYC segment fetch error:", err);
//     }

//     // 7) Client IDs (for verified flows)
//     let clientId = null;
//     let clientOnboardedID = 1;

//     if (level === 4) {
//       clientId = parent_id;
//       clientOnboardedID = parent_id;
//     } else {
//       if (toNum(user.is_kyc_verified) === 1) {
//         clientId = toNum(user.client_id) || null;
//         if (clientId) {
//           const [clientOnboardedRow] = await mySqlQury(
//             `SELECT id FROM tbl_admin WHERE id = ? LIMIT 1`,
//             [clientId]
//           );
//           clientOnboardedID = clientOnboardedRow?.id || null;
//         }
//       }
//     }

//     // 8) Build verified payload & token
//     const tokenPayload = {
//       ...basePayload,
//       clientId,
//       clientOnboardedID,
//       segmentType,
//       is_kyc_verified: true
//     };

//     const token = issueToken(res, tokenPayload);
//     res.clearCookie("selection");

//     // 9) Redirect decision
//     let redirectPath = "/express";
//     let redirectReason = "Default dashboard";

//     if (role_id === 1) {
//       redirectPath = "/express";
//       redirectReason = "Superadmin access";
//     } else if (segmentType === "express") {
//       redirectPath = "/express";
//       redirectReason = guardSource === "client" ? "Client Express segment" : "Express segment user";
//     } else if (segmentType === "ecom") {
//       redirectPath = "/ecom";
//       redirectReason = guardSource === "client" ? "Client E-commerce segment" : "E-commerce segment user";
//     } else {
//       redirectPath = "/index";
//       redirectReason = "Unknown or missing segment type";
//     }

//     // 10) Final response
//     return res.status(200).json({
//       message: "Login successful",
//       redirect: redirectPath,
//       segmentType,
//       redirectReason,
//       token,
//       is_kyc_verified: true
//     });

//   } catch (error) {
//     console.error("Login error:", error);
//     return res.status(500).json({ error: "Internal server error" });
//   }
// };

// login controller 

// assumes: mySqlQury, roleUtils.parseRoles, issueToken(res, payload) already exist

// ---------- helpers ----------
const getTokenFromReq = (req) => {
  // 1) cookie 'jwt'
  if (req.cookies?.jwt) return req.cookies.jwt;

  // 2) Authorization: Bearer <token>
  const auth = req.headers?.authorization || req.headers?.Authorization;
  if (auth && typeof auth === "string" && auth.toLowerCase().startsWith("bearer ")) {
    return auth.slice(7).trim();
  }

  // 3) x-access-token (optional for app clients)
  if (req.headers?.["x-access-token"]) return String(req.headers["x-access-token"]).trim();

  return null;
};

const toNum = (v) => (v == null ? null : Number(v));

// fetch minimal user by id (token path)
async function loadUserById(userId) {
  const rows = await mySqlQury(
    `SELECT id, first_name, last_name, email, password, role, role_id,
            client_id, is_active, is_verified, is_kyc_submitted, is_kyc_verified,
            level, parent_id, logo_path, company_name
     FROM tbl_admin WHERE id = ? LIMIT 1`,
    [userId]
  );
  return rows?.[0] || null;
}

// role info (shared)
async function loadRoleInfo(role_id) {
  if (!role_id) return { roleName: "", rolesArray: [] };
  const [roleData] = await mySqlQury(
    `SELECT id, name, description FROM roles WHERE id = ? LIMIT 1`,
    [role_id]
  );
  return {
    roleName: roleData?.name || "",
    rolesArray: roleData?.description ? roleUtils.parseRoles(roleData.description) : [],
  };
}

// segment type from KYC owner id (shared)
async function getSegmentType(kycOwnerId) {
  try {
    const kycData = await mySqlQury(
      `SELECT segment_type FROM kyc_submissions WHERE user_id = ? ORDER BY id DESC LIMIT 1`,
      [kycOwnerId]
    );
    let raw = kycData?.[0]?.segment_type || null;
    if (raw && typeof raw === "string") {
      raw = raw.trim().toLowerCase();
      if (raw === "ecommerce" || raw === "e-com") raw = "ecom";
      if (raw === "express" || raw === "exp") raw = "express";
      return raw;
    }
  } catch (err) {
    console.log("KYC segment fetch error:", err);
  }
  return null;
}

// bundle the shared â€œpost-authâ€ flow to build payload/token/redirect
async function completeSession(res, user, guardSource = "user", clientRecord = null, roleName, rolesArray) {
  const level = toNum(user.level);
  const parent_id = toNum(user.parent_id);
  const role_id = toNum(user.role_id);

  // email verification gate
  if (toNum(user.is_verified) !== 1) {
    return { status: 403, body: { error: "Your email is not verified. Please check your inbox." } };
  }

  // Base payload used for KYC gates
  const basePayload = {
    id: user.id,
    name: user.first_name,
    email: user.email,
    isActive: toNum(user.is_active),
    level,
    parent_id: parent_id ?? null,
    roleName,
    rolesArray,
    role_id,
    clientId: (level === 4 ? parent_id : (toNum(user.client_id) || null)),
    clientOnboardedID: (level === 4 ? parent_id : null),
    logo_path: user.logo_path ?? null,
    last_name: user.last_name ?? null,
    company_name: user.company_name ?? null,
    segmentType: null,
    is_kyc_verified: user.is_kyc_verified,
    is_kyc_submitted: user.is_kyc_submitted,
  };

  // determine guard record (if level 4, client governs)
  const guardRecord = guardSource === "client" ? clientRecord : user;

  // KYC gates
  if (toNum(guardRecord.is_kyc_submitted) === 0) {
    const token = issueToken(res, basePayload);
    return {
      status: 200,
      body: { redirect: "/kyc", message: "Please complete your KYC.", is_kyc_verified: false, token },
    };
  }
  if (toNum(guardRecord.is_kyc_submitted) === 1 && toNum(guardRecord.is_kyc_verified) === 0) {
    const token = issueToken(res, basePayload);
    return {
      status: 200,
      body: { redirect: "/kyc", message: "KYC pending approval.", is_kyc_verified: false, token },
    };
  }

  // for verified flows
  const kycOwnerId = (level === 4 && clientRecord) ? clientRecord.id : user.id;
  const segmentType = await getSegmentType(kycOwnerId);

  let clientId = null;
  let clientOnboardedID = 1;

  if (level === 4) {
    clientId = parent_id;
    clientOnboardedID = parent_id;
  } else {
    if (toNum(user.is_kyc_verified) === 1) {
      clientId = toNum(user.client_id) || null;
      if (clientId) {
        const [clientOnboardedRow] = await mySqlQury(
          `SELECT id FROM tbl_admin WHERE id = ? LIMIT 1`,
          [clientId]
        );
        clientOnboardedID = clientOnboardedRow?.id || null;
      }
    }
  }

  const tokenPayload = {
    ...basePayload,
    clientId,
    clientOnboardedID,
    segmentType,
    is_kyc_verified: true,
  };

  const token = issueToken(res, tokenPayload);
  res.clearCookie("selection");

  // redirect decision
  let redirectPath = "/express";
  let redirectReason = "Default dashboard";

  if (role_id === 1) {
    redirectPath = "/express";
    redirectReason = "Superadmin access";
  } else if (segmentType === "express") {
    redirectPath = "/express";
    redirectReason = guardSource === "client" ? "Client Express segment" : "Express segment user";
  } else if (segmentType === "ecom") {
    redirectPath = "/ecom";
    redirectReason = guardSource === "client" ? "Client E-commerce segment" : "E-commerce segment user";
  } else {
    redirectPath = "/index";
    redirectReason = "Unknown or missing segment type";
  }

  return {
    status: 200,
    body: {
      message: "Login successful",
      redirect: redirectPath,
      segmentType,
      redirectReason,
      token,
      is_kyc_verified: true,
    },
  };
}

// ---------- main handler ----------
const loginAuth = async (req, res) => {
  try {
    // =========================================================
    // A) TOKEN PATH (cookie -> header Authorization -> x-access-token)
    // =========================================================
    // const incomingToken = getTokenFromReq(req);

    // if (incomingToken) {
    //   try {
    //     const decoded = jwt.verify(incomingToken, process.env.JWT_SECRET);
    //     if (!decoded || typeof decoded !== "object" || !decoded.id) {
    //       // fall through to credential path if invalid
    //       throw new Error("Invalid token payload");
    //     }

    //     // Load the latest user record from DB
    //     const user = await loadUserById(Number(decoded.id));
    //     if (!user) {
    //       return res.status(401).json({ error: "User not found for provided token." });
    //     }

    //     // super admin short-circuit: also enforce active if you wish
    //     if (user.id !== 1 && toNum(user.is_active) !== 1) {
    //       return res.status(403).json({ error: "Your account is inactive. Please contact support.", isInactive: true });
    //     }

    //     // Role info
    //     const role_id = toNum(user.role_id);
    //     const { roleName, rolesArray } = await loadRoleInfo(role_id);

    //     // Level 4 guard â†’ client record
    //     let clientRecord = null;
    //     let guardSource = "user";
    //     const level = toNum(user.level);
    //     const parent_id = toNum(user.parent_id);

    //     if (level === 4) {
    //       if (!parent_id) {
    //         return res.status(403).json({ error: "Client linkage missing for this user." });
    //       }
    //       const [clientRow] = await mySqlQury(
    //         `SELECT id, first_name, last_name, email, role, role_id, client_id,
    //                 is_active, is_verified, is_kyc_submitted, is_kyc_verified,
    //                 level, parent_id, logo_path, company_name
    //          FROM tbl_admin WHERE id = ? LIMIT 1`,
    //         [parent_id]
    //       );
    //       if (!clientRow) {
    //         return res.status(403).json({ error: "Client account not found for this user." });
    //       }

    //       // require both user & client active
    //       if (toNum(user.is_active) !== 1) {
    //         return res.status(403).json({ error: "Your user account is inactive. Please contact support.", isInactive: true });
    //       }
    //       if (
    //         toNum(clientRow.is_active) !== 1 ||
    //         toNum(clientRow.is_kyc_verified) !== 1 ||
    //         toNum(clientRow.is_kyc_submitted) !== 1
    //       ) {
    //         return res.status(403).json({ error: "Your client account is inactive. Please contact support.", isInactive: true });
    //       }

    //       clientRecord = clientRow;
    //       guardSource = "client";
    //     }

    //     // Build final session response (re-issues a fresh token)
    //     const result = await completeSession(res, user, guardSource, clientRecord, roleName, rolesArray);
    //     return res.status(result.status).json(result.body);
    //   } catch (e) {
    //     // invalid/expired token â†’ continue to credential path
    //     console.log("Token auth failed, switching to credential login:", e.message);
    //   }
    // }

    // =========================================================
    // B) CREDENTIAL PATH (email/password) â€“ original flow
    // =========================================================
    const { password } = req.body || {};
    const email = (req.body?.username || "").trim();

    if (!email || !password) {
      return res.status(400).json({ error: "Email and password are required." });
    }

    // 1) Fetch user
    const [user] = await mySqlQury(
      `SELECT id, first_name, last_name, email, password, role, role_id,
              client_id, is_active, is_verified, is_kyc_submitted, is_kyc_verified,
              level, parent_id, logo_path, company_name
       FROM tbl_admin
       WHERE email = ?
       LIMIT 1`,
      [email]
    );

    if (!user) {
      return res.status(401).json({ error: "Your email is not registered" });
    }

    // 2) Password check
    const okPass = await bcrypt.compare(password, user.password || "");
    if (!okPass) {
      req?.flash?.("errors", "your password is wrong");
      return res.status(401).json({ error: "Your password is wrong" });
    }

    // 3) Active checks & client governance
    const role_id = toNum(user.role_id);
    const level = toNum(user.level);
    const parent_id = toNum(user.parent_id);

    if (level === 4) {
      if (!parent_id) {
        return res.status(403).json({ error: "Client linkage missing for this user." });
      }
      const [clientRow] = await mySqlQury(
        `SELECT id, first_name, last_name, email, role, role_id,
                client_id, is_active, is_verified, is_kyc_submitted, is_kyc_verified,
                level, parent_id, logo_path, company_name
         FROM tbl_admin
         WHERE id = ?
         LIMIT 1`,
        [parent_id]
      );
      if (!clientRow) {
        return res.status(403).json({ error: "Client account not found for this user." });
      }
      // require both user & client active
      if (toNum(user.is_active) !== 1) {
        return res.status(403).json({ error: "Your user account is inactive. Please contact support.", isInactive: true });
      }
      if (
        toNum(clientRow.is_active) !== 1 ||
        toNum(clientRow.is_kyc_verified) !== 1 ||
        toNum(clientRow.is_kyc_submitted) !== 1
      ) {
        return res.status(403).json({ error: "Your client account is inactive. Please contact support.", isInactive: true });
      }

      const { roleName, rolesArray } = await loadRoleInfo(role_id);
      const result = await completeSession(res, user, "client", clientRow, roleName, rolesArray);
      return res.status(result.status).json(result.body);
    }

    // non-level-4
    if (toNum(user.is_active) !== 1) {
      return res.status(403).json({ error: "Your account is inactive. Please contact support.", isInactive: true });
    }

    const { roleName, rolesArray } = await loadRoleInfo(role_id);
    const result = await completeSession(res, user, "user", null, roleName, rolesArray);
    return res.status(result.status).json(result.body);

  } catch (error) {
    console.error("Login error:", error);
    return res.status(500).json({ error: "Internal server error" });
  }
};


const expressShipmentsLrNo = async (req, res) => {
  try {
    const lrNo = req.params.lrNo;
    console.log("lrNo", lrNo);

    // First check which courier this LR belongs to and get order ID
    const lrQuery = `
      SELECT l.lr_No, l.tagged_api, l.status, o.orderid
      FROM tbl_exp_lr l
      LEFT JOIN tbl_exp_orders o ON l.order_id = o.id
      WHERE l.lr_No = ?
    `;
    
    const lrResult = await mySqlQury(lrQuery, [lrNo]);
    
    if (lrResult.length === 0) {
      return res.status(404).json({ success: false, message: 'LR not found' });
    }

    const lrData = lrResult[0];
    const taggedApi = lrData.tagged_api;
    const status = lrResult[0].status;
    const orderID = lrResult[0].orderid;
    let trackingData = [];

    // Fetch tracking data based on tagged_api
    switch (taggedApi.toUpperCase()) {
      case 'XPRESSBEES':
        const expressbeesQuery = `
          SELECT 
            status_code as code,
            location,
            event_time as scan_datetime,
            message as scan_description,
            date as scan_date
          FROM tbl_exp_expressbees_status 
          WHERE lrnum = ? 
          ORDER BY event_time DESC
        `;
        trackingData = await mySqlQury(expressbeesQuery, [lrNo]);
        break;

      case 'DELHIVERY':
        const delhiveryQuery = `
          SELECT 
            status_code as code,
            scanned_location as location,
            scan_datetime,
            scan as scan_description,
            DATE(scan_datetime) as scan_date
          FROM tbl_exp_delhivery_status 
          WHERE lrnum = ? 
          ORDER BY scan_datetime DESC
        `;
        trackingData = await mySqlQury(delhiveryQuery, [lrNo]);
        break;

      case 'DTDC':
        const dtdcQuery = `
          SELECT 
            strCode as code,
            strOrigin as location,
            CONCAT(strActionDate, ' ', strActionTime) as scan_datetime,
            strAction as scan_description,
            strActionDate as scan_date
          FROM tbl_exp_dtdc_status 
          WHERE lrnum = ? 
          ORDER BY strActionDate DESC, strActionTime DESC
        `;
        trackingData = await mySqlQury(dtdcQuery, [lrNo]);
        break;

              default:
          return res.status(400).json({ success: false, message: 'Unsupported courier' });
      }

      // Only return essential tracking data
      res.json({
        success: true,
        data: {
          trackingData: trackingData,
          courier: taggedApi,
          status: status,
          orderID: orderID
        }
      });

    } catch (error) {
      console.error('Error fetching tracking data:', error);
      res.status(500).json({ success: false, message: 'Internal server error' });
    }
  };
const ecomShipmentsLrNo = async (req, res) => {
  try {
    const lrNo = req.params.lrNo;
    console.log("lrNo", lrNo);

    // First check which courier this LR belongs to and get order ID
    const lrQuery = `
      SELECT l.lr_No, l.tagged_api, l.status, o.orderid
      FROM tbl_ecom_lr l
      LEFT JOIN tbl_ecom_orders o ON l.order_id = o.id
      WHERE l.lr_No = ?
    `;
    
    const lrResult = await mySqlQury(lrQuery, [lrNo]);
    
    if (lrResult.length === 0) {
      return res.status(404).json({ success: false, message: 'LR not found' });
    }

    const lrData = lrResult[0];
    const taggedApi = lrData.tagged_api;
    const status = lrResult[0].status;
    const orderID = lrResult[0].orderid;
    let trackingData = [];

    // Fetch tracking data based on tagged_api
    switch (taggedApi.toUpperCase()) {
      case 'XPRESSBEES':
        const expressbeesQuery = `
          SELECT 
            status_code as code,
            location,
            event_time as scan_datetime,
            message as scan_description,
            date as scan_date
          FROM tbl_ecom_expressbees_status 
          WHERE lrnum = ? 
          ORDER BY event_time DESC
        `;
        trackingData = await mySqlQury(expressbeesQuery, [lrNo]);
        break;

      case 'DELHIVERY':
        const delhiveryQuery = `
          SELECT 
            status_code as code,
            scanned_location as location,
            scan_datetime,
            scan as scan_description,
            DATE(scan_datetime) as scan_date
          FROM tbl_ecom_delhivery_status 
          WHERE lrnum = ? 
          ORDER BY scan_datetime DESC
        `;
        trackingData = await mySqlQury(delhiveryQuery, [lrNo]);
        break;

      case 'DTDC':
        const dtdcQuery = `
          SELECT 
            strCode as code,
            strOrigin as location,
            CONCAT(strActionDate, ' ', strActionTime) as scan_datetime,
            strAction as scan_description,
            strActionDate as scan_date
          FROM tbl_ecom_dtdc_status 
          WHERE lrnum = ? 
          ORDER BY strActionDate DESC, strActionTime DESC
        `;
        trackingData = await mySqlQury(dtdcQuery, [lrNo]);
        break;

      default:
        return res.status(400).json({ success: false, message: 'Unsupported courier' });
    }

    // Only return essential tracking data
    res.json({
      success: true,
      data: {
        trackingData: trackingData,
        courier: taggedApi,
        status: status,
        orderID: orderID
      }
    });

  } catch (error) {
    console.error('Error fetching tracking data:', error);
    res.status(500).json({ success: false, message: 'Internal server error' });
  }
};

const trackShipment = async (req, res) => {

  try {
    const trackingNumber = req.query.trackingNumber;
    console.log("trackingNumber", trackingNumber);

    // Get Tagged_api value and other details from tbl_create_lr
    const lrQuery = `
        SELECT lr.Tagged_api, lr.lr_No, lr.order_date, lr.status,lr.po_id,
               lr.consignee_Name, lr.destination_Add, lr.destination_Pincode,
               lr.mode_Of_Payment, lr.total_Weight, lr.total_Box,lr.weight_unit
        FROM tbl_create_lr lr 
        WHERE lr.lr_No = ?`;
    const lrResult = await mySqlQury(lrQuery, [trackingNumber]);
    console.log("lrResult", lrResult[0].po_id)

    if (!lrResult || lrResult.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Tracking number not found'
      });
    }
    const poId = lrResult[0].po_id;

    // Get order details from tbl_unprocessed_order using po_id
    const orderQuery = `
        SELECT *
        FROM tbl_unprocessed_order
        WHERE po_no = ?`;
    const orderDetails = await mySqlQury(orderQuery, [poId]);

    // Get box dimensions from tbl_boxes_dimension
    const boxQuery = `
        SELECT *
        FROM tbl_boxes_dimension
        WHERE po_no = ?`;
    const boxDetails = await mySqlQury(boxQuery, [poId]);

    // Get product details from tbl_products
    const productQuery = `
        SELECT *
        FROM tbl_products
        WHERE po_no = ?`;
    const productDetails = await mySqlQury(productQuery, [poId]);

    // Get origin and destination details from tbl_unprocessed_order using po_id
    const poQuery = `
        SELECT origin_state, origin_city, origin_pincode,
               destination_state, destination_city, destination_pincode
        FROM tbl_unprocessed_order
        WHERE po_no = ?`;
    const poResult = await mySqlQury(poQuery, [poId]);

    const taggedApi = lrResult[0].Tagged_api;
    let trackingData = [];

    // Standardize tracking data based on courier
    if (taggedApi && (taggedApi === 'expressbees/Standard-Surface' || taggedApi === 'expressbees/Standard-Air')) {
      const query = `SELECT 
          lrnum as tracking_number,
          message as status,
          location as location,
          event_time as timestamp,
          message as details
          FROM tbl_expressbees_status 
          WHERE lrnum = ? 
          ORDER BY event_time DESC`;

      trackingData = await mySqlQury(query, [trackingNumber]);
    }
    else if (taggedApi === 'Delhivery/Standard-Surface') {
      const query = `SELECT 
          lrnum as tracking_number,
          scan as status,
          scanned_location as location,
          scan_datetime as timestamp,
          scan as details
          FROM tbl_delivery_standard_status 
          WHERE lrnum = ? 
          ORDER BY scan_datetime DESC`;

      trackingData = await mySqlQury(query, [trackingNumber]);
    }
    else if (['DTDC/B2C PRIORITY', 'DTDC/B2C SMART EXPRESS', 'DTDC/B2C PREMIUM',
      'DTDC/B2C GROUND ECONOMY', 'DTDC/PRIORITY', 'DTDC/GROUND EXPRESS',
      'DTDC/PREMIUM', 'DTDC/STD EXP-A'].includes(taggedApi)) {
      const query = `SELECT 
          lrnum as tracking_number,
          strAction as status,
          strOrigin as location,
          CONCAT(strActionDate, ' ', strActionTime) as timestamp,
          strRemarks as details
          FROM tbl_dtdc_standard_status
          WHERE lrnum = ? 
          ORDER BY strActionDate DESC, strActionTime DESC`;

      trackingData = await mySqlQury(query, [trackingNumber]);
    }

    if (trackingData.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'No tracking information found'
      });
    }
    console.log("trackingData", trackingData)

    // Format response with standardized tracking data
    const response = {
      success: true,
      shipmentDetails: {
        trackingNumber: lrResult[0].lr_No,
        orderDate: lrResult[0].order_date,
        status: lrResult[0].status,
        consigneeName: lrResult[0].consignee_Name,
        destinationAddress: lrResult[0].destination_Add,
        destinationPincode: lrResult[0].destination_Pincode,
        paymentMode: lrResult[0].mode_Of_Payment,
        weight: lrResult[0].total_Weight,
        boxes: lrResult[0].total_Box,
        weightUnit: lrResult[0].weight_unit,
        originState: poResult[0]?.origin_state || null,
        originCity: poResult[0]?.origin_city || null,
        originPincode: poResult[0]?.origin_pincode || null,
        destinationState: poResult[0]?.destination_state || null,
        destinationCity: poResult[0]?.destination_city || null,
        destinationPincode: poResult[0]?.destination_pincode || null,
        courier: taggedApi,
        po: poId
      },
      orderDetails: orderDetails.length > 0 ? orderDetails[0] : null,
      boxDetails: boxDetails,
      productDetails: productDetails,
      currentStatus: {
        status: trackingData[0].status || 'Unknown',
        location: trackingData[0].location || 'Unknown',
        lastUpdated: trackingData[0].timestamp || new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })
      },
      timeline: trackingData.map(entry => ({
        date: entry.timestamp || new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' }),
        status: entry.status || 'Unknown',
        location: entry.location || 'Unknown',
        details: entry.details || null
      }))
    };

    res.json(response);
  } catch (error) {
    console.error('Tracking error:', error);
    res.status(500).json({
      success: false,
      message: 'Data is not updated by courier partner it will be updated soon'
    });
  }
}

const getShippingLabel = async (req, res) => {
  try {
    const { courier, awbNumber, poId, labelSize = 'A4' } = req.query;
    console.log("details", req.query);
    const courierType = req.query.courier?.split('/')[1]?.split('-')[1] || 'Surface';

    // Create directory for label size
    const labelDir = path.join(__dirname, '..', 'public', 'labelprinting', labelSize.toLowerCase());
    if (!fs.existsSync(labelDir)) {
      fs.mkdirSync(labelDir, { recursive: true });
    }

    const labelPath = path.join(labelDir, `${awbNumber}.pdf`);
    const publicPath = `/labelprinting/${labelSize.toLowerCase()}/${awbNumber}.pdf`;

    // Return existing label if it exists
    if (fs.existsSync(labelPath)) {
      return res.sendFile(labelPath);
    }

    // Get order details
    const [orderDetails, products, boxData, zones] = await Promise.all([
      mySqlQury('SELECT * FROM tbl_unprocessed_order WHERE po_no = ?', [poId]),
      mySqlQury('SELECT * FROM tbl_products WHERE po_no = ?', [poId]),
      mySqlQury('SELECT * FROM tbl_boxes_dimension WHERE po_no = ?', [poId]),
      mySqlQury('SELECT origin_zone, destination_zone FROM tbl_aggrigator_bidding WHERE lr_No = ?', [awbNumber]),
    ]);


    // Query to get chargeable weight with better error handling
    const chargableWeightQuery = `
    SELECT chargable_weight 
    FROM tbl_create_lr 
    WHERE po_id = ? OR lr_No = ?
  `;
    const [chargableWeightResult] = await mySqlQury(chargableWeightQuery, [poId, awbNumber]);
    console.log("Chargable weight result:", chargableWeightResult);
    const chargable_weight = chargableWeightResult?.chargable_weight || 0;
    console.log("Chargeable weight for PO/LR:", poId, "=", chargable_weight);



    if (!orderDetails.length || !products.length) {
      return res.status(404).json({ error: "Order or products not found!" });
    }

    const order = orderDetails[0];
    const product = products[0];
    const boxDataDimension = boxData;
    const Zonedetails = zones[0];
    let clientLogo = null;
    let returnWarehouseAddress = null;
    // console.log("order.clientid",order)
    console.log("order.clientid", order.client_id)

    if (order.client_id) {
      try {
        // Get client logo
        const clientQuery = "SELECT logo_path, company_name FROM tbl_admin WHERE id = ?";
        const [clientData] = await mySqlQury(clientQuery, [order.client_id]);
        console.log("Client logo data:", clientData);
        clientLogo = clientData;


        // Get return warehouse address
        const warehouseQuery = "SELECT return_warehouse_address FROM tbl_add_warehouse WHERE client_id = ?";
        const [warehouseReturnData] = await mySqlQury(warehouseQuery, [order.client_id]);
        console.log("Return warehouse data:", warehouseReturnData);
      } catch (err) {
        console.error("Error fetching client/warehouse data:", err);
      }
    }

    // Set response headers
    // Set correct PDF headers
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="${awbNumber}-${labelSize}.pdf"`);
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    // Generate barcode first
    const barcodeBase64 = await generateBarcodeBase64(awbNumber);
    const htmlContent = generateLabelHTML({
      order,
      product,
      awbNumber,
      courier,
      courierType,
      poId,
      boxDataDimension,
      labelSize,
      barcodeBase64,
      chargable_weight,
      Zonedetails,
      returnWarehouseAddress,
      clientLogo,
    });


    // Convert HTML to PDF with better error handling
    // Convert to PDF with error handling
    const pdfBuffer = await convertHTMLToPDF(htmlContent, labelSize);

    // Write file with async operation
    await fs.promises.writeFile(labelPath, pdfBuffer);

    // Send buffer directly instead of file
    res.end(pdfBuffer);


    // Save label info
    await mySqlQury(
      'INSERT INTO tbl_label_printing SET ?',
      {
        awb_number: awbNumber,
        po_id: poId,
        client_type: courier,
        label_path: publicPath,
        label_size: labelSize,
        created_at: new Date()
      }
    );

  } catch (error) {
    console.error('Error generating label:', error);
    if (!res.headersSent) {
      res.status(500).json({
        message: 'Error generating shipping label',
        error: error.message
      });
    }
  }
}

const shippingLabelDelhiveryLtl =  async (req, res) => {
  try {
    const { awbNumber, poId,clientId, aggrigatorId } = req.query;
    console.log("Delhivery LTL Label request details:", req.query);
    const courier = "Delhivery/LTL-surface";
    const labelSize = "4X4";
    
    // Create directory for Delhivery LTL labels with size subfolder
    const labelDir = path.join(__dirname, '..', 'public', 'labelprinting', 'delhivery-ltl', labelSize.toLowerCase());
    if (!fs.existsSync(labelDir)) {
      fs.mkdirSync(labelDir, { recursive: true });
    }

    const labelPath = path.join(labelDir, `${awbNumber}.pdf`);
    const publicPath = `/labelprinting/delhivery-ltl/${labelSize.toLowerCase()}/${awbNumber}.pdf`;

    // Return existing label if it exists
    if (fs.existsSync(labelPath)) {
      return res.sendFile(labelPath);
    }

    // Get order details
    const [orderDetails, products, boxData, zones] = await Promise.all([
      mySqlQury('SELECT * FROM tbl_unprocessed_order WHERE po_no = ?', [poId]),
      mySqlQury('SELECT * FROM tbl_products WHERE po_no = ?', [poId]), 
      mySqlQury('SELECT * FROM tbl_boxes_dimension WHERE po_no = ?', [poId]),
      mySqlQury('SELECT origin_zone, destination_zone FROM tbl_aggrigator_bidding WHERE lr_No = ?', [awbNumber]),
    ]);
    console.log("products details", products)
    
    // Query to get chargeable weight
    const chargableWeightQuery = `
      SELECT chargable_weight 
      FROM tbl_create_lr 
      WHERE po_id = ? OR lr_No = ?
    `;
    const [chargableWeightResult] = await mySqlQury(chargableWeightQuery, [poId, awbNumber]);
    console.log("Chargable weight result:", chargableWeightResult);
    const chargable_weight = chargableWeightResult?.chargable_weight || 0;

    if (!orderDetails.length || !products.length) {
      return res.status(404).json({ error: "Order or products not found!" });
    }

    const order = orderDetails[0];
    const product = products[0];
    const boxDataDimension = boxData;
    const Zonedetails = zones[0];
    let clientLogo = null;
    let returnWarehouseAddress = null;
    console.log("client details", clientId, order.client_id)
    
    // Use provided clientId if available, otherwise use from order
    const effectiveClientId = clientId || order.client_id;
    
    if (effectiveClientId) {
      try {
        // Get client logo
        const clientQuery = "SELECT logo_path, company_name,company_address FROM tbl_admin WHERE id = ?";
        const [clientData] = await mySqlQury(clientQuery, [effectiveClientId]);
        clientLogo = clientData;

        // Get return warehouse address
        const warehouseQuery = "SELECT return_warehouse_address FROM tbl_add_warehouse WHERE client_id = ?";
        const [warehouseReturnData] = await mySqlQury(warehouseQuery, [effectiveClientId]);
        returnWarehouseAddress = warehouseReturnData;
      } catch (err) {
        console.error("Error fetching client/warehouse data:", err);
      }
    }
    console.log("client logo", clientLogo)

    // Set response headers
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="delhivery-ltl-${awbNumber}-${labelSize}.pdf"`);
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    
    // Create HTML content as a string (this is the key fix)
    let htmlString = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>Delhivery LTL Shipping Label</title>
      </head>
      <body>
    `;
    
    // For Delhivery LTL, check if child waybills exist
    const childWaybillsQuery = `SELECT * FROM child_lr_data WHERE lrNo = ?`;
    const childWaybillsResult = await mySqlQury(childWaybillsQuery, [awbNumber]);
    console.log("childWaybillsResult",childWaybillsResult)
    
    // Extract waybill information
// Extract waybill information
let childWaybills = [];
let docWaybill = null;
let masterWaybill = null;

if (childWaybillsResult.length > 0) {
  // Store the master waybill
  if (childWaybillsResult[0].masterWaybills) {
    masterWaybill = childWaybillsResult[0].masterWaybills;
  }
  
  // Store all child waybills
  childWaybills = childWaybillsResult.map(result => result.ltlChildLr).filter(lr => lr);
  
  // Store doc waybill
  if (childWaybillsResult[0].docWaybills) {
    docWaybill = childWaybillsResult[0].docWaybills;
  }
  
  console.log("Child waybills array:", childWaybills);
  console.log("Doc waybill:", docWaybill);
  console.log("Master waybill:", masterWaybill);
}
 const totalBoxCount = 1 + (Array.isArray(childWaybills) ? childWaybills.length : 0);

let sectionContent = '';
const sectionsPerPage = 4;
let sectionCount = 0;
// Define firstPageChildCount here in the parent scope
const firstPageChildCount = Math.min(
  Array.isArray(childWaybills) ? childWaybills.length : 0, 
  3  // Allow 3 children on first page with master
);
    const formattedDate = new Date().toLocaleDateString('en-US', {
      month: 'short',
      day: '2-digit',
      year: 'numeric'
    });
    
    // Format shipping information
    const fromAddress = `${order.from_address || ''}, ${order.from_city || ''}, ${order.from_state || ''}, ${order.from_pin || ''}`;
    const toAddress = `${order.consignee_name || 'Consignee Name'}
        ${order.consignee_address || 'Address'}
        ${order.destination_city || 'City'}, ${order.destination_state || 'State'}
        ${order.destination_pincode || 'Pincode'}`;
    const returnAddr = returnWarehouseAddress && returnWarehouseAddress.return_warehouse_address
      ? returnWarehouseAddress.return_warehouse_address
      : 'Return Address Not Available';
    
  // Add CSS styles
  htmlString += `
  <style>
    @page {
      size: A4;
      margin: 0;
    }
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 5px;
      font-size: 10px;
    }
    .page-container {
      page-break-after: always;
    }
    .label-container {
          display: grid;
          grid-template-columns: repeat(2, 1fr);
          grid-gap: 30px 10px;  /* 30px row gap, 10px column gap */
          padding: 5px;
        }
        .label-section {
          width: 100%;
          border: 1px solid #000;
          margin: 0;
        }
    .label-header {
      display: flex;
      border-bottom: 1px solid #000;
    }
    .logo {
      width: 30%;
      padding: 5px;
      font-weight: bold;
      border-right: 1px solid #000;
    }
    .info {
      width: 70%;
      padding: 5px;
    }
    .barcode-container {
      padding: 5px;
      text-align: center;
      border-bottom: 1px solid #000;
    }
    .barcode-container img {
      max-width: 100%;
    }
    .box-info {
      display: flex;
      border-bottom: 1px solid #000;
    }
    .box-info-left {
      width: 50%;
      padding: 5px;
      border-right: 1px solid #000;
    }
    .box-info-right {
      width: 50%;
      padding: 5px;
      text-align: right;
    }
    .location-info {
      display: flex;
      border-bottom: 1px solid #000;
    }
    .location-from {
      width: 50%;
      padding: 5px;
      border-right: 1px solid #000;
    }
    .location-to {
      width: 50%;
      padding: 5px;
    }
    .address-info {
      display: flex;
      border-bottom: 1px solid #000;
    }
    .address-text {
      width: 70%;
      padding: 5px;
      border-right: 1px solid #000;
    }
    .address-type {
      width: 30%;
      padding: 5px;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .return-address {
      padding: 5px;
      font-size: 9px;
    }
    .small-text {
      font-size: 8px;
    }
  </style>
  <div class="page-container">
    <div class="label-container">
    `;
    
    // Master waybill
    // Master waybill
if (masterWaybill) {
  const masterBarcodeBase64 = await generateBarcodeBase64(masterWaybill);
  htmlString += createLabelSection({
    title: 'Master',
    date: formattedDate,
    lrNumber: awbNumber,
    orderId: poId,
    waybillNumber: masterWaybill,
    masterWaybill: masterWaybill,
    barcode: masterBarcodeBase64,
    boxInfo: `Box : 1/${totalBoxCount}`,  // Updated box count
    fromLocation: clientLogo.company_address,
    toName: clientLogo.company_name,
    toAddress,
    fromAddress,
    returnAddress: returnAddr,
    type: products[0].product_name,
    courier: courier,
    userLogo: clientLogo
  });
  
  sectionCount++;
}
    
 // Add child waybills to first page - make sure we're looping through them properly
if (Array.isArray(childWaybills) && childWaybills.length > 0) {
 
  for (let i = 0; i < firstPageChildCount; i++) {
    const childWaybill = childWaybills[i];
    if (!childWaybill) continue; // Skip if undefined
    
    const childBarcode = await generateBarcodeBase64(childWaybill);
    htmlString += createLabelSection({
      title: 'Child',
      date: formattedDate,
      lrNumber: awbNumber,
      orderId: poId,
      waybillNumber: childWaybill,
      masterWaybill: masterWaybill,
      barcode: childBarcode,
      boxInfo: `Box : ${i+2}/${totalBoxCount}`,  // Updated box count
      fromLocation: clientLogo.company_address,
      toName: clientLogo.company_name,
      toAddress,
      fromAddress,
      returnAddress: returnAddr,
      type: products[0].product_name,
      courier: courier,
      userLogo: clientLogo
    });
  }
}
    // Close first page
    htmlString += `
        </div>
      </div>
    `;
    
    // Add remaining child waybills on second page if needed
    if (childWaybills.length > firstPageChildCount) {
      htmlString += `
        <div class="page-container">
          <div class="label-container">
      `;
      
      for (let i = firstPageChildCount; i < childWaybills.length; i++) {
        const childBarcode = await generateBarcodeBase64(childWaybills[i]);
        htmlString += createLabelSection({
          title: 'Child',
          date: formattedDate,
          lrNumber: awbNumber,
          orderId: poId,
          waybillNumber: childWaybills[i],
          masterWaybill: masterWaybill,
          barcode: childBarcode,
          boxInfo: `Box : ${i+2}/${childWaybills.length + 1}`,
          fromLocation: clientLogo.company_address,
          toName: clientLogo.company_name,
          toAddress,
          fromAddress,
          returnAddress: returnAddr,
          type: products[0].product_name,
          courier: courier,
          userLogo: clientLogo
        });
      }
      
      // Close second page
      htmlString += `
          </div>
        </div>
      `;
    }
    
    // Add document waybill on its own page if it exists
    if (docWaybill) {
      const docBarcode = await generateBarcodeBase64(docWaybill);
      htmlString += `
        <div class="page-container">
          <div class="label-container">
            ${createLabelSection({
              title: 'Child',
              date: formattedDate,
              lrNumber: awbNumber,
              orderId: `DOC ${awbNumber}`,
              waybillNumber: docWaybill,
              masterWaybill: masterWaybill,
              barcode: docBarcode,
              boxInfo: 'MPS: Documents',
              fromLocation: clientLogo.company_address,
              toName: clientLogo.company_name,
              toAddress,
              fromAddress,
              returnAddress: returnAddr,
              type: products[0].product_name,
              courier: courier,
              userLogo: clientLogo
            })}
          </div>
        </div>
      `;
    }
    
    // Close HTML
    htmlString += `
      </body>
      </html>
    `;
    
    // Convert to PDF with error handling
    const pdfBuffer = await convertHTMLToPDF(htmlString, labelSize);
    
    // Write file with async operation
    await fs.promises.writeFile(labelPath, pdfBuffer);
    
    // Save label info
    await mySqlQury(
      'INSERT INTO tbl_label_printing SET ?',
      {
        awb_number: awbNumber,
        po_id: poId,
        client_type: 'Delhivery/LTL-surface',
        label_path: publicPath,
        label_size: labelSize,
        created_at: new Date()
      }
    );
    
    // Send buffer directly
    res.end(pdfBuffer);

  } catch (error) {
    console.error('Error generating Delhivery LTL label:', error);
    if (!res.headersSent) {
      res.status(500).json({
        message: 'Error generating Delhivery LTL shipping label',
        error: error.message
      });
    }
  }
}

function createLabelSection({
  title,
  date,
  lrNumber,
  orderId,
  poId,
  waybillNumber,
  masterWaybill,
  barcode,
  boxInfo,
  fromLocation,
  toName,
  toAddress,
  fromAddress,
  returnAddress,
  type,
  courier,
  userLogo
}) {
  console.log("master way bill number in the craete", masterWaybill);
  console.log("child way bill number", waybillNumber);
  let clientSrc = '';
  let clientCompanyName = '';
  if (userLogo) {
    try {
      if (userLogo) {
        // Store company name for alt text  
        clientCompanyName = userLogo.company_name || 'Client';

        if (userLogo.logo_path) {
          const userLogoPath = path.join(__dirname, '..', 'public', userLogo.logo_path);
          console.log("Full path to client logo:", userLogoPath);

          // Check if file exists before reading
          if (fs.existsSync(userLogoPath)) {
            const userLogoBase64 = fs.readFileSync(userLogoPath, { encoding: 'base64' });
            clientSrc = `data:image/png;base64,${userLogoBase64}`;
          } else {
            console.warn(`Client logo file not found at path: ${userLogoPath}`);
            // Use empty string for src
            clientSrc = '';
          }
        }
      }
    } catch (err) {
      console.error('Error loading client logo:', err);
      // Use empty string on error
      clientSrc = '';
    }
    console.log("user logo", userLogo);
  }

  // Read the logo file and convert to base64
  const logoFilePath = path.join(__dirname, '..', 'public', 'assets', 'images', 'logos', 'delhivery.png');
  console.log("Reading logo from:", logoFilePath);
  const dispatchLogo = path.join(__dirname, '..', 'public', 'assets', 'images', 'logos', 'logo-dark.png');
  let dispatchLogoDataUrl = '';
  try {
    const dispatchLogoBase64 = fs.readFileSync(dispatchLogo, { encoding: 'base64' });
    dispatchLogoDataUrl = `data:image/png;base64,${dispatchLogoBase64}`;
  } catch (error) {
    console.error('Error reading logo file:', error);
  }

  let courierLogoDataUrl = '';
  try {
    const courierLogoBase64 = fs.readFileSync(logoFilePath, { encoding: 'base64' });
    courierLogoDataUrl = `data:image/png;base64,${courierLogoBase64}`;
  } catch (error) {
    console.error('Error reading logo file:', error);
  }

  // Define consistent styles
  const borderStyle = '1px solid #000';
  const paddingStyle = '2px';

  return `
      <div class="label-section" style="border: ${borderStyle};">
         <div class="label-header row" style="display: flex; flex-direction: column; padding: ${paddingStyle};">
          <div class="logo-row" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <div class="logo-col" style="width: 50%;">
              <img src="${courierLogoDataUrl}" alt="Delhivery Logo" style="width: 70px; height: auto;">
            </div>
            <div class="logo-col" style="width: 50%; text-align: right;">
              <img src="${dispatchLogoDataUrl}" alt="Dispatch Logo" style="width: 70px; height: auto;">
            </div>
          </div>
          <div class="info-row row" style="display: flex; flex-direction: row; align-items: center;">
            <div class="qr-col" style="width: 50%; text-align: start;">
              <a href="https://dispatchsolutions.in/universal-tracking?awbNumber=${lrNumber}" target="_blank">
                <img 
                  src="https://api.qrserver.com/v1/create-qr-code/?size=100x100&data=https://dispatchsolutions.in/universal-tracking?awbNumber=${waybillNumber}" 
                  alt="QR Code"
                  style="width: 80px; height: 80px;"
                >
              </a>
            </div>
            <div class="info-col" style="width: 85%; padding-left: 10px; flex-grow: 1;">
              <div class="info" style="font-weight: bold; display: flex; flex-direction: column; width: 90%;">
                <div style="border: ${borderStyle}; padding: ${paddingStyle}; margin-bottom: -1px; width: 100%;">DATE: ${String(date).toUpperCase()}</div>
                <div style="border: ${borderStyle}; padding: ${paddingStyle}; margin-bottom: -1px; width: 100%;">LRN: ${String(lrNumber).toUpperCase()}</div>
                <div style="border: ${borderStyle}; padding: ${paddingStyle}; margin-bottom: -1px; width: 100%;">OID: ${String(orderId).toUpperCase()}</div>
                <div style="border: ${borderStyle}; padding: ${paddingStyle}; margin-bottom: -1px; width: 100%;">OID: ${String(poId).toUpperCase()}</div>
                <div style="border: ${borderStyle}; padding: ${paddingStyle}; margin-bottom: -1px; width: 100%;">MASTER: ${masterWaybill ? String(masterWaybill).toUpperCase() : ''}</div>
                <div style="border: ${borderStyle}; padding: ${paddingStyle}; width: 100%;">110035 GUR/TGW</div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="barcode-container" style="padding: ${paddingStyle}; border-top: ${borderStyle};">
          
          <img src="data:image/png;base64,${barcode}" alt="Barcode">
          <div class="master-waybill" style="text-align: center; font-weight: bold; margin-top: 5px;">
            ${waybillNumber ? String(waybillNumber).toUpperCase() : "UNDEFINED"}
          </div>
        </div>
        
        <div class="box-info" style="display: flex; justify-content: space-between; padding: ${paddingStyle}; border-top: ${borderStyle};">
          <div class="box-info-left">${String(boxInfo).toUpperCase()}</div>
          <div class="box-info-right">
            <span style="font-weight: bold; margin-right: 10px;">${waybillNumber ? String(waybillNumber).toUpperCase() : "UNDEFINED"}</span>
            <span>${String(title).toUpperCase()}</span>
          </div>
        </div>
        
        <div class="location-info" style="display: flex; justify-content: space-between; padding: ${paddingStyle}; border-top: ${borderStyle};">
          <div class="location-from">${String(fromLocation).toUpperCase()}</div>
          <div class="location-to">${String(toName).toUpperCase()}</div>
          <img src="${clientSrc}" alt="${clientCompanyName}" style="width: 70px; height: auto;">
        </div>
        
        <div class="address-info" style="padding: ${paddingStyle}; border-top: ${borderStyle};">
          <div class="address-text">
            <div style="font-weight: bold;">DESTINATION ADDRESS :</div>
            <div class="small-text">${String(toAddress).toUpperCase()}</div>
          </div>
          <div class="address-type" style="text-align: right;">${String(type).toUpperCase()}</div>
        </div>
        
        <div class="return-address" style="padding: ${paddingStyle}; border-top: ${borderStyle};">
          <div style="font-weight: bold;">RETURN ADDRESS :</div>
          <div class="small-text">${String(returnAddress).toUpperCase()}</div>
        </div>
      </div>
    `;
  // ... existing code ...
}

// Shipping Label Preferences Functions
const getShippingLabelPreferences = async (req, res) => {
  try {
    const userId = req.user?.selectedClientId;
    
    if (!userId) {
      return res.status(400).json({ 
        success: false, 
        message: 'User ID not found' 
      });
    }

    // Check if preferences exist for this user
    const [existingPrefs] = await mySqlQury(
      'SELECT * FROM tbl_user_shipping_label_preferences WHERE user_id = ?',
      [userId]
    );

    if (existingPrefs) {
      return res.json({
        success: true,
        data: existingPrefs
      });
    } else {
      // Return default preferences if none exist
      const defaultPrefs = await getDefaultShippingLabelPreferences(req, res);
      return defaultPrefs;
    }
  } catch (error) {
    console.error('Error getting shipping label preferences:', error);
    res.status(500).json({
      success: false,
      message: 'Error retrieving preferences',
      error: error.message
    });
  }
};

const saveShippingLabelPreferences = async (req, res) => {
  try {
    const userId = req.user?.selectedClientId;
    
    if (!userId) {
      return res.status(400).json({ 
        success: false, 
        message: 'User ID not found' 
      });
    }

    const {
      show_order_id, show_invoice_number, show_order_date, show_invoice_date,
      show_order_barcode, show_invoice_barcode, show_rto_routing, show_declared_value,
      show_shipper_phone, show_gstin, show_shipper_address, show_brand_name, show_brand_logo,
      show_item_name, show_product_cost, show_product_quantity, show_sku_code,
      show_dimension, show_dead_weight, show_other_charges, limit_item_name_length,
      hide_buyer_sensitive_details, default_label_size
    } = req.body;

    // Check if preferences already exist
    const [existingPrefs] = await mySqlQury(
      'SELECT id FROM tbl_user_shipping_label_preferences WHERE user_id = ?',
      [userId]
    );

    if (existingPrefs) {
      // Update existing preferences
      await mySqlQury(
        `UPDATE tbl_user_shipping_label_preferences SET 
          show_order_id = ?, show_invoice_number = ?, show_order_date = ?, show_invoice_date = ?,
          show_order_barcode = ?, show_invoice_barcode = ?, show_rto_routing = ?, show_declared_value = ?,
          show_shipper_phone = ?, show_gstin = ?, show_shipper_address = ?, show_brand_name = ?, show_brand_logo = ?,
          show_item_name = ?, show_product_cost = ?, show_product_quantity = ?, show_sku_code = ?,
          show_dimension = ?, show_dead_weight = ?, show_other_charges = ?, limit_item_name_length = ?,
          hide_buyer_sensitive_details = ?, default_label_size = ?, updated_at = CURRENT_TIMESTAMP
        WHERE user_id = ?`,
        [
          show_order_id, show_invoice_number, show_order_date, show_invoice_date,
          show_order_barcode, show_invoice_barcode, show_rto_routing, show_declared_value,
          show_shipper_phone, show_gstin, show_shipper_address, show_brand_name, show_brand_logo,
          show_item_name, show_product_cost, show_product_quantity, show_sku_code,
          show_dimension, show_dead_weight, show_other_charges, limit_item_name_length,
          hide_buyer_sensitive_details, default_label_size, userId
        ]
      );
    } else {
      // Insert new preferences
      await mySqlQury(
        `INSERT INTO tbl_user_shipping_label_preferences (
          user_id, show_order_id, show_invoice_number, show_order_date, show_invoice_date,
          show_order_barcode, show_invoice_barcode, show_rto_routing, show_declared_value,
          show_shipper_phone, show_gstin, show_shipper_address, show_brand_name, show_brand_logo,
          show_item_name, show_product_cost, show_product_quantity, show_sku_code,
          show_dimension, show_dead_weight, show_other_charges, limit_item_name_length,
          hide_buyer_sensitive_details, default_label_size
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          userId, show_order_id, show_invoice_number, show_order_date, show_invoice_date,
          show_order_barcode, show_invoice_barcode, show_rto_routing, show_declared_value,
          show_shipper_phone, show_gstin, show_shipper_address, show_brand_name, show_brand_logo,
          show_item_name, show_product_cost, show_product_quantity, show_sku_code,
          show_dimension, show_dead_weight, show_other_charges, limit_item_name_length,
          hide_buyer_sensitive_details, default_label_size
        ]
      );
    }

    res.json({
      success: true,
      message: 'Shipping label preferences saved successfully'
    });
  } catch (error) {
    console.error('Error saving shipping label preferences:', error);
    res.status(500).json({
      success: false,
      message: 'Error saving preferences',
      error: error.message
    });
  }
};

const getDefaultShippingLabelPreferences = async (req, res) => {
  try {
    const defaultPrefs = {
      show_order_id: 1,
      show_invoice_number: 0,
      show_order_date: 1,
      show_invoice_date: 0,
      show_order_barcode: 1,
      show_invoice_barcode: 1,
      show_rto_routing: 1,
      show_declared_value: 1,
      show_shipper_phone: 1,
      show_gstin: 1,
      show_shipper_address: 1,
      show_brand_name: 1,
      show_brand_logo: 1,
      show_item_name: 1,
      show_product_cost: 1,
      show_product_quantity: 1,
      show_sku_code: 1,
      show_dimension: 1,
      show_dead_weight: 1,
      show_other_charges: 1,
      limit_item_name_length: 1,
      hide_buyer_sensitive_details: 1,
      default_label_size: 'A4'
    };

    res.json({
      success: true,
      data: defaultPrefs
    });
  } catch (error) {
    console.error('Error getting default preferences:', error);
    res.status(500).json({
      success: false,
      message: 'Error retrieving default preferences',
      error: error.message
    });
  }
};

const printBulkLabels = async (req, res) => {
  try {
    const { selectedRows, labelSize = '4X6' } = req.body;
    console.log("details", req.body);
    
    if (!Array.isArray(selectedRows) || !selectedRows.length) {
      return res.status(400).json({ error: "No valid rows provided" });
    }

    // Create a temporary directory for the merged PDF
    const tempDir = path.join(__dirname, '..', 'public', 'labelprinting', 'temp');
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }
    
    const batchFileName = `batch_labels_${Date.now()}.pdf`;
    const batchFilePath = path.join(tempDir, batchFileName);
    
    // Create an array to store all PDF buffers
    const pdfBuffers = [];
    
    // Generate each label
    for (const row of selectedRows) {
      try {
        const { lrNo: currentAwb, courier: currentCourier, poId: currentPoId } = row;
        
        // Create directory for label size - SAME AS get-shipping-label
        const labelDir = path.join(__dirname, '..', 'public', 'labelprinting', labelSize.toLowerCase());
        if (!fs.existsSync(labelDir)) {
          fs.mkdirSync(labelDir, { recursive: true });
        }
        
        const labelPath = path.join(labelDir, `${currentAwb}.pdf`);
        const publicPath = `/labelprinting/${labelSize.toLowerCase()}/${currentAwb}.pdf`;
        
        // Check if the label already exists - ADDED THIS CHECK
        if (fs.existsSync(labelPath)) {
          console.log(`Label for AWB ${currentAwb} already exists, using existing file`);
          // Read the existing PDF file and add to buffers
          const existingPdfBuffer = await fs.promises.readFile(labelPath);
          pdfBuffers.push(existingPdfBuffer);
          continue; // Skip to next label
        }
        
        // Get order details
        const [orderDetails, products, boxData, zones] = await Promise.all([
          mySqlQury('SELECT * FROM tbl_unprocessed_order WHERE po_no = ?', [currentPoId]),
          mySqlQury('SELECT * FROM tbl_products WHERE po_no = ?', [currentPoId]), 
          mySqlQury('SELECT * FROM tbl_boxes_dimension WHERE po_no = ?', [currentPoId]),
          mySqlQury('SELECT origin_zone, destination_zone FROM tbl_aggrigator_bidding WHERE lr_No = ?', [currentAwb]),
        ]);
        
        // Query to get chargeable weight
        const chargableWeightQuery = `
          SELECT chargable_weight 
          FROM tbl_create_lr 
          WHERE po_id = ? OR lr_No = ?
        `;
        const [chargableWeightResult] = await mySqlQury(chargableWeightQuery, [currentPoId, currentAwb]);
        const chargable_weight = chargableWeightResult?.chargable_weight || 0;
        
        if (!orderDetails.length || !products.length) {
          console.log(`Skipping AWB ${currentAwb}: Order or products not found`);
          continue;
        }
        
        const order = orderDetails[0];
        const product = products[0];
        const boxDataDimension = boxData;
        const Zonedetails = zones[0];
        let clientLogo = null;
        let returnWarehouseAddress = null;
       
        
        if (order.client_id) {
          try {
            // Get client logo
            const clientQuery = "SELECT logo_path,company_name FROM tbl_admin WHERE id = ?";
            const [clientData] = await mySqlQury(clientQuery, [order.client_id]);
            clientLogo = clientData;
            
            // Get return warehouse address
            const warehouseQuery = "SELECT return_warehouse_address FROM tbl_add_warehouse WHERE client_id = ?";
            const [warehouseReturnData] = await mySqlQury(warehouseQuery, [order.client_id]);
            returnWarehouseAddress = warehouseReturnData;
          } catch (err) {
            console.error("Error fetching client/warehouse data:", err);
          }
        }
        
        // Generate barcode
        const barcodeBase64 = await generateBarcodeBase64(currentAwb);
        const courierType = currentCourier?.split('/')[1]?.split('-')[1] || 'Surface';
        
        const htmlContent = generateLabelHTML({
          order,
          product,
          awbNumber: currentAwb,
          courier: currentCourier,
          courierType,
          poId: currentPoId,
          boxDataDimension,
          labelSize,
          barcodeBase64,
          chargable_weight,
          Zonedetails,
          returnWarehouseAddress,
          clientLogo,
        });
        
        // Convert HTML to PDF
        const pdfBuffer = await convertHTMLToPDF(htmlContent, labelSize);
        
        // Save individual PDF
        await fs.promises.writeFile(labelPath, pdfBuffer);
        
        // Add to buffers array for merging
        pdfBuffers.push(pdfBuffer);
        
        // Save label info to database
        await mySqlQury(
          'INSERT INTO tbl_label_printing SET ?',
          {
            awb_number: currentAwb,
            po_id: currentPoId,
            client_type: currentCourier,
            label_path: publicPath,
            label_size: labelSize,
            created_at: new Date()
          }
        );
      } catch (error) {
        console.error(`Error generating label for AWB ${row.lrNo}:`, error);
        // Continue with next label even if one fails
      }
    }
    
    // Merge all PDFs into one file
    if (pdfBuffers.length > 0) {
      try {
        const mergedPdf = await mergePDFBuffers(pdfBuffers);
        
        // Set headers for direct download
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="batch_labels_${Date.now()}.pdf"`);
        res.setHeader('Content-Length', mergedPdf.length);
        
        // Send the PDF buffer directly to the client
        return res.end(mergedPdf);
      } catch (error) {
        console.error('Error merging PDFs:', error);
        return res.status(500).json({
          success: false,
          message: 'Error merging PDFs',
          error: error.message
        });
      }
    } else {
      return res.status(404).json({ 
        success: false,
        message: "No labels could be generated" 
      });
    }
  } catch (error) {
    console.error('Error generating labels:', error);
    if (!res.headersSent) {
      res.status(500).json({
        success: false,
        message: 'Error generating shipping labels',
        error: error.message
      });
    }
  }
}
// Helper function to merge PDF buffers
async function mergePDFBuffers(pdfBuffers) {
  // You'll need to implement PDF merging here
  // This is a placeholder - you can use a library like pdf-lib or pdfkit

  // For example with pdf-lib:
  const { PDFDocument } = require('pdf-lib');

  const mergedPdf = await PDFDocument.create();

  for (const pdfBuffer of pdfBuffers) {
    const pdf = await PDFDocument.load(pdfBuffer);
    const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
    copiedPages.forEach((page) => {
      mergedPdf.addPage(page);
    });
  }

  return Buffer.from(await mergedPdf.save());
}

// Helper function to create each label section  
function generateLabelHTML(data) {
  const {
    order,
    product,
    awbNumber,
    courier,
    courierType,
    poId,
    boxDataDimension,
    labelSize,
    barcodeBase64,
    chargable_weight,
    Zonedetails,
    returnWarehouseAddress,
    clientLogo
  } = data;


  const logoPathDispatch = path.join(__dirname, '..', 'public', 'assets', 'images', 'logo-dark.png');
  console.log("logodispatchpath", logoPathDispatch)
  // console.log("logopath data of clint logo",clientLogo)
  const logoPathDispatchBase64 = fs.readFileSync(logoPathDispatch, { encoding: 'base64' });
  // Handle dispatch logo
  const logoDispatchSrc = `data:image/png;base64,${logoPathDispatchBase64 || ''}`;
  console.log("logoPathDispatch", logoPathDispatch);
  // Handle client logo with error checking
  // Handle client logo with error checking
  // Handle client logo with error checking
  let clientSrc = '';
  let clientCompanyName = 'Client';
  try {
    if (clientLogo) {
      // Store company name for alt text
      clientCompanyName = clientLogo.company_name || 'Client';

      if (clientLogo.logo_path) {
        const clientLogoPath = path.join(__dirname, '..', 'public', clientLogo.logo_path);
        console.log("Full path to client logo:", clientLogoPath);

        // Check if file exists before reading
        if (fs.existsSync(clientLogoPath)) {
          const clientLogoBase64 = fs.readFileSync(clientLogoPath, { encoding: 'base64' });
          clientSrc = `data:image/png;base64,${clientLogoBase64}`;
        } else {
          console.warn(`Client logo file not found at path: ${clientLogoPath}`);
          // Use empty string for src
          clientSrc = '';
        }
      }
    }
  } catch (err) {
    console.error('Error loading client logo:', err);
    // Use empty string on error
    clientSrc = '';
  }

  // Handle return warehouse address with null check
  const returnWarehouse = returnWarehouseAddress?.return_warehouse_address || 'No return address available';
  console.log("returnWarehouse", returnWarehouse);
  console.log("client logo src")


  const logoUrl = getCourierLogoPath(courier);
  console.log("logoUrlwithoutcut", logoUrl);



  console.log("data in the generateLabelHtml", data);
  console.log("courier logo url", logoUrl);

  const logoBase64 = fs.readFileSync(logoUrl, { encoding: 'base64' });
  const logosrccourier = `data:image/png;base64,${logoBase64}`;


  switch (labelSize) {
    case '4X6':
      return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Shipping Label 4x6</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
    <style>
      @media print {
        @page {
          size: 4in 6in;
          margin: 0;
        }
        body {
          margin: 0;
        }
      }
  
      body {
        font-family: Arial, sans-serif;
        font-size: 7pt;
        width: 4in;
        height: 6in;
        margin: 0;
        padding: 0;
        background: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
      }
  
      .label-box {
        width: 3.9in;
        height: 5.9in;
        border: 2px solid #000;
        padding: 6px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }
  
      /* Keeping existing styles */
      .logo-row img {
        max-height: 25px;
        object-fit: contain;
      }
  
      .section-title {
        font-weight: bold;
        font-size: 7pt;
        margin-bottom: 2px;
        text-transform: capitalize;
      }
  
      .info-text {
        font-size: 5.5pt;
        line-height: 1.2;
        text-transform: capitalize;
      }
  
      .barcode img,
      .barcode-large img {
        width: 100%;
        height: auto;
      }
  
      .icon-box {
        color: #000;
        padding: 5px 2px;
        font-size: 6pt;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        min-height: 60px;
        text-transform: capitalize;
      }
  
      .icon-box i {
        font-size: 18px;
        margin-bottom: 2px;
      }
  
      .method span {
        padding: 1px 4px;
        font-size: 6pt;
        border: 1px solid #000;
        border-radius: 2px;
        margin-right: 2px;
        text-transform: capitalize;
      }
  
      .filled {
        background-color: #000;
        color: #fff;
      }
  
      .section-divider {
        border-top: 1px dashed #999;
        margin: 4px 0;
      }
  
      .qrcode img {
        height: 50px;
        margin: 2px auto;
      }
  
      .footer {
        font-size: 6pt;
        text-align: center;
        text-transform: capitalize;
      }
  
      .text-small {
        font-size: 6pt;
        text-transform: capitalize;
      }
  
      th, td {
        text-transform: capitalize;
      }
    </style>
  </head>
  <body>
  
  <div class="label-box">
    <!-- Logos -->
    <div class="row mb-1">
      <div class="col-4 text-start"><img src="${logosrccourier}"style="width: 60%; alt="Courier Logo"></div>
      <div class="col-6 text-end"><img src="${clientSrc}" alt="C${clientCompanyName}" style="max-height: 30px;"></div>
      
    </div>
  
    <!-- From and To -->
    <div class="row">
      <div class="col-6">
        <div class="section-title">From:</div>
        <div class="info-text">
          ${(order.warehouse_name || 'WAREHOUSE NAME').toUpperCase()}<br>
          ${(order.warehouse_address || 'WAREHOUSE ADDRESS').toUpperCase()}<br>
          ${(order.origin_city || 'CITY').toUpperCase()}, ${(order.origin_state || 'STATE').toUpperCase()}<br>
          ${(order.origin_pincode || 'PINCODE').toUpperCase()}<br>
        </div>
      </div>
      <div class="col-6">
        <div class="section-title">To:</div>
        <div class="info-text">
          <strong>${(order.consignee_name || 'CONSIGNEE NAME').toUpperCase()}</strong><br>
          ${(order.consignee_address || 'ADDRESS').toUpperCase()}<br>
          ${(order.destination_city || 'CITY').toUpperCase()}, ${(order.destination_state || 'STATE').toUpperCase()}<br>
          ${(order.destination_pincode || 'PINCODE').toUpperCase()}<br>
        </div>
      </div>
    </div>
  
    <!-- Icons + QR -->
    <div class="row mt-1">
      <div class="col-4">
        <div class="icon-box">
          <i class="bi bi-exclamation-triangle-fill"></i>
          Fragile
        </div>
      </div>
      <div class="col-4">
        <div class="icon-box">
          <i class="bi bi-recycle"></i>
          Recycle
        </div>
      </div>
      <div class="col-4 qrcode text-center">
    <a href="https://dispatchsolutions.in/universal-tracking?awbNumber=${awbNumber}" target="_blank">
  
      <img 
        src="https://api.qrserver.com/v1/create-qr-code/?size=120x120&data=https://dispatchsolutions.in/universal-tracking?awbNumber=${awbNumber}" 
        alt="QR Code"
      >
    </a>
  </div>
  
    </div>
  
    <!-- Tracking + Method -->
    <div class="row mt-1 text-center">
      <div class="col-12">
        <strong>${courier?.includes('/LTL') ? 'LR Number' : 'AWB Number'}:</strong> ${awbNumber}
      </div>
      <div class="col-12 method mt-1">
        <span class="badge ${courierType === 'Express' ? 'bg-success' : 'bg-primary'} me-1">${courierType || 'Air'}</span>
        <span class="badge ${courier?.includes('/LTL') ? 'bg-info' : 'bg-secondary'}">${courier?.includes('/LTL') ? 'LTL' : 'Standard'}</span>
      </div>
    </div>
  
    <!-- Order + Barcode -->
    <div class="section-divider"></div>
  
  
    <!-- Item + Barcode -->
    <div class="section-divider"></div>
  <div class="row align-items-center mb-2">
    <div class="col-8">
      <div class="order-details">
        <div class="mb-1">
          <strong class="d-block">Order ID:</strong>
          <span class="text-dark"><span>Purchase Order:</span>${order.order_id || poId}</span><br>
          <span class="text-dark"><span>Order No:</span>${poId.poId || poId}</span>
        </div>
        <div>
          <strong class="d-block">${courier?.includes('/LTL') ? 'LR Number' : 'AWB Number'}:</strong>
          <span class="text-dark">${awbNumber}</span>
        </div>
      </div>
    </div>
    
    <div class="col-4">
      <div class="barcode-container text-center">
        <img 
          src="data:image/png;base64,${barcodeBase64}" 
          alt="LR Barcode"
          class="img-fluid mb-1"
        >
        <div class="barcode-number">
          <span class="fw-bold">${awbNumber}</span>
        </div>
      </div>
    </div>
  </div>
  
    <!-- Product Details Table -->
    <div class="section-divider"></div>
    <div class="row">
      <div class="col-12 text-small">
        <strong>Product Details:</strong>
        <table class="table table-sm table-bordered mt-1 mb-0" style="font-size: 6.5pt;">
          <thead class="table-light">
            <tr>
              <th>Product Name</th>
              <th>Qty</th>
              <th>Amount</th>
              <th>HSN</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>${product.product_name || 'Product'}</td>
              <td>${product.quantity || '0'}</td>
              <td>${product.order_value || '0.00'}</td>
              <td>${product.hsn_id || 'N/A'}</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  
    <!-- Box Details -->
    <div class="section-divider"></div>
    <div class="row">
      <div class="col-12 text-small">
        <strong>Box Details:</strong><br>
        Total Boxes: ${order.total_boxes || '0'}<br>
        Dimensions: ${boxDataDimension?.[0]?.DIMENSION || 'N/A'} ${boxDataDimension?.[0]?.unit || ''}<br>
        Weight: ${order.total_weight || '0'} ${order.weight_unit || 'kg'}
      </div>
    </div>
  
    <!-- Payment Details -->
    <div class="section-divider"></div>
    <div class="row">
      <div class="col-12 text-small">
        <strong>Payment Type:</strong> ${order.payment_type || 'N/A'}<br>
        <strong style="font-size:16px;">Invoice Amount:INR ${order.Invoice_amount || '0.00'} </strong> 
      </div>
    </div>
  
   
    <!-- Footer -->
    <div class="footer bg-white shadow-sm rounded p-2 mt-1">
      <div class="row align-items-center mb-0">
        <div class="col-6 text-center">
          <img src="${logoDispatchSrc}" alt="Dispatch Logo" style="max-height: 20px;">
          <div style="font-size: 5pt;">Powered by <span class="fw-bold"> Dispatch Solutions</span></div>
        </div>
  
        <div class="col-6 text-center">
          <div  style="font-size: 5pt;">support@dispatch.co.in | +91 9313 388 388</div>
          <div style="font-size: 5pt;">www.dispatch.co.in</div>
  
        </div>
      </div>
    </div>
  
  </div>
  
  </body>
  </html>`;

    case '4X4':
      return `<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Shipping Label 4x4</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      @media print {
        @page {
          size: 4in 4in;
          margin: 0;
        }
        body {
          margin: 0;
        }
      }
  
      * {
        box-sizing: border-box;
      }
  
      body {
        font-family: Arial, sans-serif;
        font-size: 7pt;
        width: 4in;
        height: 4in;
        margin: 0;
        padding: 0;
        background: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
      }
  
      .label-box {
        width: 3.86in;
        height: 3.86in;
        border: 2px solid #000;
        padding: 5px;
        display: flex;
        flex-direction: column;
      }
  
      .row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 4px;
      }
  
      .col {
        padding: 0 2px;
      }
  
      .col-4 {
        width: 32%;
      }
  
      .col-6 {
        width: 48%;
      }
  
      .col-12 {
        width: 100%;
      }
  
      .section-title {
        font-weight: bold;
        font-size: 7pt;
        margin-bottom: 2px;
      }
  
      .info-text {
        font-size: 6.5pt;
        line-height: 1.2;
      }
  
      .icon-box {
        color: #000;
        padding: 5px 2px;
        font-size: 6pt;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 50px;
      }
  
      .icon-box i {
        font-size: 18px;
        margin-bottom: 2px;
      }
  
      .method span {
        padding: 1px 4px;
        font-size: 6pt;
        border: 1px solid #000;
        border-radius: 2px;
        margin-right: 2px;
      }
  
      .filled {
        background-color: #000;
        color: #fff;
      }
  
      .section-divider {
        border-top: 1px dashed #999;
        margin: 2px 0;
      }
  
      .qrcode img {
        height: 50px;
        margin: 2px auto;
      }
  
      .footer {
        font-size: 6pt;
        text-align: center;
      }
  
      .text-small {
        font-size: 6pt;
      }
    </style>
  </head>
  <body>
  
  <div class="label-box">
  
    <!-- Logos -->
    <div class="row mb-1">
      <div class="col-4 text-start d-flex align-items-center">
        <img src="${logosrccourier}" alt="Courier Logo" style="max-width: 100%; height: 20px; object-fit: contain;">
      </div>
      
      <div class="col-4 text-end d-flex align-items-center justify-content-end">
        <img src="${clientSrc}" alt="${clientCompanyName}" style="max-width: 100%; height: 20px; object-fit: contain;">
      </div>
    </div>
    <!-- From and To -->
    <div class="row">
      <div class="col-6">
        <div class="section-title">FROM:</div>
        <div class="info-text">
          ${(order.warehouse_name || 'WAREHOUSE NAME').toUpperCase()}<br>
          ${(order.warehouse_address || 'WAREHOUSE ADDRESS').toUpperCase()}<br>
          ${(order.origin_city || 'CITY').toUpperCase()}, ${(order.origin_state || 'STATE').toUpperCase()}<br>
          ${(order.origin_pincode || 'PINCODE').toUpperCase()}<br>
        </div>
      </div>
      <div class="col-6">
        <div class="section-title">TO:</div>
        <div class="info-text">
          <strong>${(order.consignee_name || 'CONSIGNEE NAME').toUpperCase()}</strong><br>
          ${(order.consignee_address || 'ADDRESS').toUpperCase()}<br>
          ${(order.destination_city || 'CITY').toUpperCase()}, ${(order.destination_state || 'STATE').toUpperCase()}<br>
          ${(order.destination_pincode || 'PINCODE').toUpperCase()}<br>
        </div>
      </div>
    </div>
  
    <!-- Icons + QR -->
    <div class="row mt-1">
      <div class="col-4">
        <div class="icon-box">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
            <path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"/>
          </svg>
          <span>FRAGILE</span>
        </div>
      </div>
      <div class="col-4">
        <div class="icon-box">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
            <path d="M9.302 1.256a1.5 1.5 0 0 0-2.604 0l-1.704 2.98a.5.5 0 0 0 .869.497l1.703-2.981a.5.5 0 0 1 .868 0l2.54 4.444-1.372-.789a.5.5 0 1 0-.497.87l1.86 1.07a.5.5 0 0 0 .523-.047l3.5-2.5a.5.5 0 0 0-.848-.53l-2.89 2.065L9.302 1.256zM4.5 7.319l.557-.97a.5.5 0 1 1 .868.497l-.786 1.374a.5.5 0 0 1-.868 0l-.786-1.374a.5.5 0 1 1 .868-.497l.147.256zm3.593 2.168.557-.97a.5.5 0 1 1 .868.497l-.786 1.374a.5.5 0 0 1-.868 0l-.786-1.374a.5.5 0 1 1 .868-.497l.147.256z"/>
          </svg>
          <span>RECYCLE</span>
        </div>
      </div>
      <div class="col-4 qrcode text-center">
        <img src="https://api.qrserver.com/v1/create-qr-code/?size=120x120&data=Sender:${order.warehouse_name},${order.warehouse_address}|Receiver:${order.consignee_name},${order.consignee_address}|Tracking:${awbNumber}|Weight:${order.total_weight}|Date:${order.order_date}" alt="QR Code" style="width: 70%; height: auto;">
      </div>
    </div>
  
    <!-- Tracking + Method -->
    <div class="row mt-1 text-center">
      
      <div class="col-12 method mt-1">
        <span class="badge ${courierType === 'Express' ? 'bg-success' : 'bg-primary'} me-1">${courierType || 'AIR'}</span>
        <span class="badge ${courier?.includes('/LTL') ? 'bg-info' : 'bg-secondary'}">${courier?.includes('/LTL') ? 'LTL' : 'Standard'}</span>
      </div>
    </div>
  
    <!-- Order + Barcode -->
    <div class="section-divider"></div>
    <div class="row">
      <div class="col-6">
  <span class="text-dark"><span>Purchase Order:</span>${order.order_id || poId}</span><br>
         <strong> <span class="text-dark"><span>Order No:</span>${poId.poId || poId}</span></strong><br>
        <strong>${courier?.includes('/LTL') ? 'LR Number' : 'AWB Number'}:</strong><br>${awbNumber}
      </div>
      <div class="col-6 barcode">
        <img src="data:image/png;base64,${barcodeBase64}" alt="Order Barcode" style="width: 80%; height: auto;">
      </div>
    </div>
  
    
  
    <!-- Item + Barcode -->
    <div class="section-divider"></div>
    
  
    <!-- Delivery instruction -->
    <div class="section-divider"></div>
    <div class="row">
      <div class="col-12 text-small">
        <strong>Delivery instruction:</strong><br>${order.delivery_instructions || 'No special instructions'}
      </div>
    </div>
  
    <!-- Footer -->
   <div class="footer bg-white shadow-sm rounded p-2 mt-1">
      <div class="row align-items-center mb-0">
        <div class="col-6 text-center">
          <img src="${logoDispatchSrc}" alt="Dispatch Logo" style="max-height: 20px;">
          <div class="text-primary" style="font-size: 7pt;">Powered by <span class="fw-bold">Dispatch Solutions</span></div>
        </div>
  
        <div class="col-6 text-center">
          <div class="text-secondary" style="font-size: 7pt;">support@dispatch.co.in | +91 9313 388 388</div>
          <div class="text-primary" style="font-size: 7pt;">www.dispatch.co.in</div>
        </div>
      </div>
    </div>
  
  </div>
  
  </body>
  </html>`;

    case '4X2':
      return `<!DOCTYPE html>
  <html lang="en">
      <head>
          <meta charset="UTF-8">
          <title>Shipping Label 4x2</title>
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
          <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
          <style>
      @media print {
        @page {
          size: 4in 2in;
          margin: 0;
        }
        body {
          margin: 0;
        }
      }
  
      body {
        font-family: Arial, sans-serif;
        font-size: 8pt;
        width: 4in;
        height: 2in;
        margin: 0;
        padding: 0;
        background: #fff;
        display: flex;
        justify-content: center;
        align-items: flex-start;
      }
  
      .label-box {
        width: 3.86in;
        height: 1.86in;
        border: 1px solid #000;
        padding: 5px;
        box-sizing: border-box;
        display: grid;
        grid-template-rows: auto 1fr auto;
        gap: 2px;
      }
  
      .logo-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        height: 15px;
      }
  
      .logo-row img {
        max-height: 12px;
        object-fit: contain;
      }
  
      .content-area {
        display: grid;
        grid-template-rows: auto auto;
        gap: 2px;
        margin-bottom: 2px;
      }
  
      .addresses {
        display: flex;
        justify-content: space-between;
        gap: 10px;
      }
  
      .tracking-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
  
      .section-title {
        font-weight: bold;
        font-size: 7pt;
        margin-bottom: 1px;
      }
  
      .info-text {
        font-size: 6pt;
        line-height: 1.1;
      }
  
      .barcode {
        width: 25%;
      }
  
      .barcode img {
        width: 100%;
        height: auto;
      }
  
      .method span {
        font-size: 6pt;
        padding: 1px 4px;
        border: 1px solid #000;
        border-radius: 2px;
        margin-right: 2px;
      }
  
      .footer {
        font-size: 5pt;
        text-align: center;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding-top: 2px;
        border-top: 1px solid #eee;
        margin-top: auto;
        height: 20px;
        overflow: hidden;
      }
  
      .footer img {
        max-height: 10px;
      }
  
      .footer-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        line-height: 1;
      }
  
      .footer-right {
        text-align: right;
        line-height: 1;
      }
  
      .col-6 {
        width: 48%;
      }
  
      .col-4 {
        width: 32%;
      }
  
      .col-8 {
        width: 65%;
      }
    </style>
      </head>
      <body>
          <div class="label-box">
              <div class="logo-row">
                  <img src="${logosrccourier}" alt="Courier Logo">
                  
                  <img src="${clientSrc}" alt="${clientCompanyName}">
              </div>
  
              <div class="content-area">
                  <div class="addresses">
                      <div class="col-6">
                          <div class="section-title">From:</div>
                          <div class="info-text">
                              ${(order.warehouse_name || 'Warehouse Name').toUpperCase()}<br>
                              ${(order.warehouse_address || 'Warehouse Address').toUpperCase()}<br>
                              ${(order.origin_city || 'City').toUpperCase()}, ${(order.origin_state || 'State').toUpperCase()}<br>
                              ${(order.origin_pincode || 'Pincode').toUpperCase()}
                          </div>
                      </div>
                      <div class="col-6">
                          <div class="section-title">To:</div>
                          <div class="info-text">
                              <strong>${(order.consignee_name || 'Consignee Name').toUpperCase()}</strong><br>
                              ${(order.consignee_address || 'Address').toUpperCase()}<br>
                              ${(order.destination_city || 'City').toUpperCase()}, ${(order.destination_state || 'State').toUpperCase()}<br>
                              ${(order.destination_pincode || 'Pincode').toUpperCase()}
                          </div>
                      </div>
                  </div>
  
                  <div class="tracking-info">
                      <div class="col-8">
                          <div style="margin-bottom: 2px;">
                              <strong>${courier?.includes('/LTL') ? 'LR Number' : 'AWB Number'}:</strong> ${awbNumber}<br>
                            
                              <strong> <span class="text-dark"><span>Order No:</span>${poId.poId || poId}</span></strong>
                          </div>
                          <div class="method">
                              <span class="badge border border-dark text-dark bg-white me-1">${courierType || 'AIR'}</span>
                              <span class="badge border border-dark text-dark bg-white">${courier?.includes('/LTL') ? 'LTL' : 'Standard'}</span>
                          </div>
                      </div>
                      <div class="col-4 barcode text-center">
                          <img src="data:image/png;base64,${barcodeBase64}" alt="Order Barcode">
                          <div style="font-size: 7pt;">${awbNumber}</div>
                      </div>
                  </div>
              </div>
  
              <div class="footer">
                  <div class="footer-content">
                      <img src="${logoDispatchSrc}" alt="Dispatch Logo">
                      <small>Powered by <strong>Dispatch Solutions</strong></small>
                  </div>
                  <div class="footer-right">
                      <small>support@dispatch.co.in | +91 9313 388 388</small><br>
                      <small>www.dispatch.co.in</small>
                  </div>
              </div>
          </div>
      </body>
  </html>`;
    case 'A4':
      return `<!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <title>Shipping Invoice - A4</title>
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        @media print {
          @page {
            size: A4;
            margin: 5mm;
          }
        }
    
        body {
          font-family: Arial, sans-serif;
          font-size: 10pt;
          background-color: #fff;
          color: #000;
          padding: 0;
          margin: 0;
        }
    
        .invoice-box {
          width: 100%;
          border: 1px solid #000;
          padding: 10px;
          box-sizing: border-box;
        }
    
        table {
          width: 100%;
          border-collapse: collapse;
        }
    
        table, th, td {
          border: 1px solid #000;
        }
    
        th, td {
          padding: 4px;
          font-size: 9pt;
          text-align: left;
        }
    
        .section-title {
          font-weight: bold;
          margin-bottom: 3px;
        }
    
        .divider {
          border-top: 1px dashed #999;
          margin: 8px 0;
        }
    
        .barcode img {
          width: 100%;
          height: auto;
        }
    
        .row {
          display: flex;
          flex-wrap: wrap;
          margin-bottom: 8px;
        }
    
        .col-4 {
          width: 33%;
        }
    
        .col-5 {
          width: 41%;
        }
    
        .col-6 {
          width: 48%;
          padding-right: 2%;
        }
    
        .col-7 {
          width: 58%;
        }
    
        .col-12 {
          width: 100%;
        }
    
        .signature-space {
          height: 60px;
          border: 1px dashed #000;
          margin-top: 5px;
        }
    
        .text-center {
          text-align: center;
        }
    
        .footer {
          margin-top: 10px;
          font-size: 8pt;
          border-top: 1px solid #ddd;
          padding-top: 5px;
        }
      </style>
    </head>
    <body>
    
    <div class="invoice-box">
      <!-- Header with logos -->
      <div class="row" style="display: flex; align-items: center; justify-content: space-between; margin: -10px 0 -8px;">
        <div class="col-4" style="display: flex; align-items: center;">
          <img src="${logosrccourier}" alt="Courier Logo" style="width: 60%; margin: 0;">
        </div>
        <div class="col-6" style="display: flex; align-items: center; justify-content: flex-end;">
          <img src="${clientSrc}" alt="${clientCompanyName}" style="width: 35%; margin: 0;">
        </div>
      </div>
    
      <!-- Addresses -->
      <div class="row" style="margin-top: 15px;">
        <div class="col-6">
          <div class="section-title">From:</div>
          <div>
            ${(order.warehouse_name || 'WAREHOUSE NAME').toUpperCase()}<br>
            ${(order.warehouse_address || 'WAREHOUSE ADDRESS').toUpperCase()}<br>
            ${(order.origin_city || 'CITY').toUpperCase()}, ${(order.origin_state || 'STATE').toUpperCase()} ${(order.origin_pincode || 'PINCODE').toUpperCase()}<br>
            ${(order.warehouse_contact_person || 'Phone').toUpperCase()}
          </div>
        </div>
        <div class="col-6">
          <div class="section-title">To:</div>
          <div>
            <strong>${(order.consignee_name || 'CONSIGNEE NAME').toUpperCase()}</strong><br>
            ${(order.consignee_address || 'ADDRESS').toUpperCase()}<br>
            ${(order.destination_city || 'CITY').toUpperCase()}, ${(order.destination_state || 'STATE').toUpperCase()} ${(order.destination_pincode || 'PINCODE').toUpperCase()}<br>
            ${(order.consignee_phone || 'Phone').toUpperCase()}
          </div>
        </div>
      </div>
    
      <!-- Tracking & Order Info -->
      <div class="row" style="margin-top: 15px;">
        <div class="col-4">
          <div class="section-title">${courier?.includes('/LTL') ? 'LR #:' : 'AWB #:'}</div>
          <div><strong>${awbNumber}</strong></div>
          <div class="section-title" style="margin-top: 8px;">Order #:</div>
          <span class="text-dark"><span>Purchase Order:</span>${order.order_id || poId}</span><br>
          <span class="text-dark"><span>Order No:</span>${poId.poId || poId}</span>
          <div class="section-title" style="margin-top: 8px;">Date:</div>
          <div>${new Date(order.order_date).toLocaleDateString() || 'N/A'}</div>
        </div>
            <div class="col-4 qrcode text-center">
    <a href="https://dispatchsolutions.in/universal-tracking?awbNumber=${awbNumber}" target="_blank">
      <img 
        src="https://api.qrserver.com/v1/create-qr-code/?size=120x120&data=https://dispatchsolutions.in/universal-tracking?awbNumber=${awbNumber}" 
        alt="QR Code"
      >
    </a>
  </div>
        <div class="col-4">
          <div class="section-title">Shipping Method:</div>
          <div>${courierType || 'AIR'} - ${courier?.includes('/LTL') ? 'LTL' : 'Standard'}</div>
          <div class="section-title" style="margin-top: 8px;">Invoice:</div>
          <div>${order.invoice_no || 'N/A'}</div>
          <div class="section-title" style="margin-top: 8px;">Payment:</div>
          <div>${order.payment_type || 'N/A'}</div>
        </div>
      </div>
    
      <!-- Weight Info -->
      <div class="row" style="margin-top: 15px;">
        <div class="col-4">
          <div class="section-title">Zones:</div>
          <div>${Zonedetails?.origin_zone || 'N/A'}-${Zonedetails?.destination_zone || 'N/A'}</div>
        </div>
        <div class="col-4">
          <div class="section-title">Weight:</div>
          <div>${order.total_weight || '0'} ${order.weight_unit || 'kg'}</div>
        </div>
        <div class="col-4">
          <div class="section-title">Chargeable:</div>
          <div>${chargable_weight === 0 ? order.total_weight : chargable_weight || '0'} ${order.weight_unit || 'kg'}</div>
        </div>
      </div>
    
      <div class="divider"></div>
    
      <!-- Box & Product Details -->
      <div class="row">
        <div class="col-7">
          <!-- Box Details -->
          <div class="section-title">Box Details:</div>
          <table>
            <thead>
              <tr>
                <th>Box</th>
                <th>Dimension</th>
                <th>Unit</th>
              </tr>
            </thead>
            <tbody>
              ${boxDataDimension?.map(box => `
                <tr>
                  <td>${box.box_number || '1'}</td>
                  <td>${box.DIMENSION || 'N/A'}</td>
                  <td>${box.unit || 'cm'}</td>
                </tr>
              `).join('') || `
                <tr>
                  <td>1</td>
                  <td>N/A</td>
                  <td>cm</td>
                </tr>
              `}
            </tbody>
          </table>
          
          <div style="margin-top: 8px;">
            <span>Total Boxes: ${boxDataDimension?.length || '1'}</span> | 
            <span>Volumetric Weight: ${chargable_weight || 'N/A'}${order.weight_unit || 'kg'}</span>
          </div>
    
          <!-- Product Details -->
          <div class="section-title" style="margin-top: 20px;">Product Details:</div>
          <table>
            <thead>
              <tr>
                <th>Product</th>
                <th>Qty</th>
                <th>Amount</th>
                <th>HSN</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>${product.product_name || 'N/A'}</td>
                <td>${product.quantity || '0'}</td>
                <td>${product.order_value || '0.00'}</td>
                <td>${product.hsn_id || 'N/A'}</td>
              </tr>
            </tbody>
          </table>
          
          <div style="margin-top: 10px;">
            <div class="row">
              <div class="col-6">
                <strong>Category:</strong> ${(product.category || 'N/A').toUpperCase()}<br>
                <strong>SKU:</strong> ${(product.sku || 'N/A').toUpperCase()}
              </div>
              <div class="col-6">
                <strong>Origin:</strong> ${(order.origin_city || 'N/A').toUpperCase()}<br>
                <strong>Destination:</strong> ${(order.destination_city || 'N/A').toUpperCase()}
              </div>
            </div>
          </div>
    
          <!-- Barcode -->
          <div style="margin-top: 20px;">
            <div class="section-title">${courier?.includes('/LTL') ? 'LR Barcode' : 'AWB Barcode'}:</div>
            <div class="barcode text-center">
              <img src="data:image/png;base64,${barcodeBase64}" alt="Item Barcode" style="width:60%">
              <div class="text-center">
                <span><strong>${awbNumber}</strong></span>
              </div>
            </div>
          </div>
        </div>
    
        <!-- Declaration Section -->
        <div class="col-5">
          <div style="border: 1px solid #000; padding: 10px;">
            <div class="section-title">Declaration:</div>
            <div style="font-size: 9pt; line-height: 1.4;">
              I/We declare that this consignment does not contain personal mail, cash, jewellery,
              contraband, illegal drugs, any prohibited items and commodities which can cause safety
              hazards while transporting
            </div>
            
            <div class="section-title" style="margin-top: 15px;">Sender's Signature & Seal:</div>
            <div style="font-size: 9pt; line-height: 1.4;">
              I have read and understood terms & conditions of carriage mentioned on website.
            </div>
            
            <!-- Signature Space -->
            <div class="signature-space"></div>
            <div class="text-center" style="font-size: 9pt;">
              (Sign & Seal Here)
            </div>
          </div>
          
          <!-- Shipping Details -->
          <div style="margin-top: 20px;">
            <div class="section-title">Shipping Details:</div>
            <div class="row">
              <div class="col-6">
                <strong>Origin:</strong> ${(order.origin_city || 'N/A').toUpperCase()}, ${(order.origin_state || 'N/A').toUpperCase()}<br>
                <strong>Destination:</strong> ${(order.destination_city || 'N/A').toUpperCase()}, ${(order.destination_state || 'N/A').toUpperCase()}<br>
              </div>
              <div class="col-6">
                <strong>Order Date:</strong> ${new Date(order.order_date).toLocaleDateString() || 'N/A'}<br>
                <strong>Service Type:</strong> ${(courierType || 'Standard').toUpperCase()}
              </div>
            </div>
          </div>
          
          <!-- Delivery Instructions -->
          <div style="margin-top: 20px;">
            <div class="section-title">Delivery Instructions:</div>
            <div style="font-size: 9pt; line-height: 1.3; min-height: 80px; border: 1px solid #eee; padding: 5px;">
              ${order.delivery_instructions || 'No special instructions provided. Standard delivery procedures apply.'}
            </div>
          </div>
        </div>
      </div>
    
      <div class="divider"></div>
    
      <!-- Key Information -->
      <div>
        <div class="row">
          <div class="col-12">
            <strong>Key Information:</strong>
            <span style="font-size: 9pt; text-transform: uppercase;">
              This Document is not a tax invoice. Weight captured by ${courier?.split('/')[0] || 'N/A'} 
              will be used for invoice generation.
            </span>
          </div>
        </div>
      </div>
    
      <!-- Footer -->
      <div class="footer">
        <div class="row">
          <div class="col-6 text-center">
            <img src="${logoDispatchSrc}" alt="Dispatch Logo" style="max-height: 22px;">
            <div>Powered by <strong>Dispatch Solutions</strong></div>
          </div>
          <div class="col-6 text-center">
            <div>support@dispatch.co.in | +91 9313 388 388</div>
            <div>www.dispatch.co.in</div>
          </div>
        </div>
      </div>
    
    </div>
    
    </body>
    </html>`;
    default:
      return `<!DOCTYPE html><html><body>Unsupported label size</body></html>`;
  }
}
async function convertHTMLToPDF(html, size) {
  // Try to find Chrome executable path
  let executablePath;
  try {
    // Common Chrome paths on Windows
    const possiblePaths = [
      'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe',
      'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
      process.env.CHROME_PATH,
      process.env.PUPPETEER_EXECUTABLE_PATH
    ];
    
    for (const path of possiblePaths) {
      if (path && require('fs').existsSync(path)) {
        executablePath = path;
        break;
      }
    }
    
    console.log('Using Chrome executable path:', executablePath || 'default');
  } catch (error) {
    console.warn('Could not determine Chrome path:', error.message);
  }

  const browser = await puppeteer.launch({
    headless: 'new',
    executablePath,
    args: [
      '--no-sandbox', 
      '--disable-setuid-sandbox', 
      '--font-render-hinting=none',
      '--disable-dev-shm-usage',
      '--disable-gpu',
      '--no-first-run',
      '--no-zygote',
      '--single-process'
    ],
    timeout: 30000
  });

  try {
    const page = await browser.newPage();

    // Set viewport based on size
    const dimensions = {
      '4X6': { width: 384, height: 576 },
      '4X4': { width: 384, height: 384 },
      '4X2': { width: 384, height: 192 },
      'A4': { width: 920, height: 1050 },
      'A6': { width: 298, height: 420 }
    };

    const viewport = dimensions[size] || dimensions['A4'];
    await page.setViewport(viewport);

    // Inject PDF-specific styles
    const modifiedHtml = html.replace('</head>',
      `<style>
          * { -webkit-print-color-adjust: exact !important; }
          @page { size: ${viewport.width}px ${viewport.height}px; margin: 0; }
          body { margin: 0; padding: 0; }
        </style>
        </head>`
    );

    // Set content with proper wait conditions
    console.log('Setting page content with HTML length:', modifiedHtml.length);
    await page.setContent(modifiedHtml, {
      waitUntil: ['networkidle0', 'load', 'domcontentloaded']
    });

    // Ensure all content is loaded
    await page.evaluate(() => new Promise(resolve => {
      if (document.readyState === 'complete') {
        resolve();
      } else {
        window.addEventListener('load', resolve);
      }
    }));

    // Generate PDF with proper settings
    const pdfBuffer = await page.pdf({
      width: `${viewport.width}px`,
      height: `${viewport.height}px`,
      printBackground: true,
      margin: { top: 0, right: 0, bottom: 0, left: 0 },
      preferCSSPageSize: true,
      scale: 1,
      landscape: size === '4X2',
      omitBackground: false,
      timeout: 30000
    });

    // Ensure we return a proper Buffer
    if (Buffer.isBuffer(pdfBuffer)) {
      console.log('âœ… PDF buffer is already a Buffer');
      return pdfBuffer;
    } else if (pdfBuffer instanceof Uint8Array) {
      console.log('âœ… Converting Uint8Array to Buffer');
      return Buffer.from(pdfBuffer);
    } else {
      console.log('âœ… Converting to Buffer, type:', typeof pdfBuffer);
      return Buffer.from(pdfBuffer);
    }
  } catch (error) {
    console.error('Puppeteer PDF generation failed:', error);
    
    // Fallback: Try to use html-pdf-node if available
    try {
      console.log('Attempting fallback PDF generation...');
      const { html_to_pdf } = require('html-pdf-node');
      
      const options = { format: 'A4' };
      const file = { content: html };
      const pdfBuffer = await html_to_pdf(file, options);
      
      console.log('Fallback PDF generation successful');
      return pdfBuffer;
    } catch (fallbackError) {
      console.error('Fallback PDF generation also failed:', fallbackError);
      throw new Error(`PDF generation failed: ${error.message}. Please ensure Chrome is installed or use a different PDF library.`);
    }
  } finally {
    if (browser) {
      await browser.close();
    }
  }
}
// Remove the example usage that was causing the error

// New Shipping Label Generation Function
const generateNewShippingLabel = async (req, res) => {
  try {
    const { orderId, labelSize = 'A4', orderType = 'express', lrNo: frontendLrNo, bulkOrderIds } = req.query;
    const userId = req.user?.selectedClientId;
    console.log("lr new label", req.query);
    
    // Check if this is a bulk operation
    if (bulkOrderIds) {
      console.log("ðŸ”„ Bulk operation detected, processing bulk labels...");
      return await processBulkLabels(req, res);
    }
    
    // Use frontend LR number if provided, otherwise will extract from database
    let lrNumber = frontendLrNo;
    
    // Create directory structure for labels
    const labelsDir = path.join(__dirname, '..', 'public', 'shipping-labels');
    const orderTypeDir = path.join(labelsDir, orderType);
    const labelSizeDir = path.join(orderTypeDir, labelSize);
    
    // Ensure directories exist
    if (!fs.existsSync(labelsDir)) fs.mkdirSync(labelsDir, { recursive: true });
    if (!fs.existsSync(orderTypeDir)) fs.mkdirSync(orderTypeDir, { recursive: true });
    if (!fs.existsSync(labelSizeDir)) fs.mkdirSync(labelSizeDir, { recursive: true });
    
    console.log(`ðŸ“ Label directories created/verified:`);
    console.log(`   Root: ${labelsDir}`);
    console.log(`   Order Type: ${orderTypeDir}`);
    console.log(`   Label Size: ${labelSizeDir}`);
    
    // Get LR number from order details (will be set after query)
    // lrNumber is already declared above
    
    // Generate filename based on LR number only (no timestamp)
    const fileName = `label-${lrNumber || orderId}-${labelSize}.pdf`;
    const filePath = path.join(labelSizeDir, fileName);
    
    // Use same filename for both (no timestamp needed)
    const simpleFileName = fileName;
    const simpleFilePath = filePath;
    
    // Check if label already exists (using simple filename)
    if (fs.existsSync(simpleFilePath)) {
      console.log(`Label already exists: ${simpleFilePath}`);
      
      // Return existing file
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${simpleFileName}"`);
      res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
      res.setHeader('Pragma', 'no-cache');
      res.setHeader('Expires', '0');
      
      const existingFile = fs.createReadStream(simpleFilePath);
      existingFile.pipe(res);
      return;
    }
    
    console.log(`Generating new label: ${filePath}`);
    
    if (!userId) {
      return res.status(400).json({
        success: false,
        message: 'User ID not found'
      });
    }

    if (!orderId) {
      return res.status(400).json({
        success: false,
        message: 'Order ID is required'
      });
    }

    console.log('Generating new shipping label for:', { orderId, labelSize, userId, orderType });

    // 1. Get user preferences from the new table
    const preferencesQuery = `
      SELECT * FROM tbl_user_shipping_label_preferences 
      WHERE user_id = ?
    `;
    const [userPreferences] = await mySqlQury(preferencesQuery, [userId]);
    
    if (!userPreferences) {
      return res.status(404).json({
        success: false,
        message: 'Shipping label preferences not found for this user'
      });
    }

    // 2. Get order details based on orderType from frontend
    let orderDetails = null;
    let productDetails = null;
    
    if (orderType === 'express') {
      console.log('Express orderType');
      // Get Express order details
      const expressOrderQuery = `
        SELECT 
          o.*, 
          lr.lr_no, lr.tagged_api, lr.chargable_weight, lr.volumetric_weight,
          lr.pickup_zone, lr.destination_zone, lr.status as lr_status,
          c.company_name, kyc.logo_path, kyc.gst_number as gstin
        FROM tbl_exp_orders o
        LEFT JOIN tbl_exp_lr lr ON o.id = lr.order_id
        LEFT JOIN tbl_admin c ON o.client_id = c.id
        LEFT JOIN kyc_submissions kyc ON o.client_id = kyc.user_id
        WHERE o.id = ?
      `;
      
      // First test a simple query without JOINs
      try {
        const simpleTest = await mySqlQury('SELECT * FROM tbl_exp_orders WHERE id = ?', [orderId]);
        console.log('Simple test query result:', simpleTest);
      } catch (error) {
        console.error('Simple test query failed:', error);
      }
      
      let rawResult;
      try {
        rawResult = await mySqlQury(expressOrderQuery, [orderId]);
        console.log('Raw query result:', rawResult);
      } catch (error) {
        console.error('SQL Query Error:', error);
        console.error('Query:', expressOrderQuery);
        console.error('Parameters:', [orderId]);
        rawResult = [[]]; // Return empty result to prevent crashes
      }
      
      let [expressOrderResult] = rawResult;
      
      console.log('Express query result:', { 
        orderId, 
        queryParams: [orderId], 
        rawResult,
        expressOrderResult,
        resultCount: rawResult.length,
        firstResult: expressOrderResult
      });
      
      if (expressOrderResult && rawResult.length > 0) {
        orderDetails = expressOrderResult;
        
        // Extract LR number for file naming (override frontend value if database has it)
        lrNumber = orderDetails.lr_no || lrNumber;
        console.log(`ðŸ“‹ LR Number extracted: ${lrNumber}`);
        
        // Update filenames with LR number (no timestamp)
        const fileName = `label-${lrNumber}-${labelSize}.pdf`;
        const filePath = path.join(labelSizeDir, fileName);
        
        console.log(`ðŸ“ Updated file paths with LR number:`);
        console.log(`   File: ${fileName}`);
        
        // Get Express product details
        const expressProductQuery = `SELECT * FROM tbl_exp_product_details WHERE order_id = ? ORDER BY id DESC`;
        const expressProductResult = await mySqlQury(expressProductQuery, [orderId]);
        
        if (expressProductResult && expressProductResult.length > 0) {
          productDetails = expressProductResult[0];
          // Store all products for detailed display
          orderDetails.allProducts = expressProductResult;
          console.log("Stored Express products in orderDetails.allProducts:", orderDetails.allProducts);
        }
        
        // Get Express package details (all boxes)
        const expressPackageQuery = `
          SELECT * FROM tbl_exp_boxes_details WHERE order_id = ? ORDER BY id DESC
        `;
        const expressPackageResult = await mySqlQury(expressPackageQuery, [orderId]);
        
        if (expressPackageResult && expressPackageResult.length > 0) {
          // Also store all boxes for detailed display
          orderDetails.allBoxes = expressPackageResult;
          console.log("Stored Express boxes in orderDetails.allBoxes:", orderDetails.allBoxes);
        }
        
        // Get Express consignee details
        const expressConsigneeQuery = `
          SELECT * FROM tbl_exp_consignee_details WHERE order_id = ?
        `;
        const [expressConsigneeResult] = await mySqlQury(expressConsigneeQuery, [orderId]);
        console.log("expressConsigneeResult",expressConsigneeResult)
        
        if (expressConsigneeResult) {
          // Merge consignee details into orderDetails, but preserve allProducts and allBoxes
          orderDetails = { 
            ...orderDetails, 
            ...expressConsigneeResult,
            allProducts: orderDetails.allProducts, // Preserve products
            allBoxes: orderDetails.allBoxes       // Preserve boxes
          };
          console.log("Final Express orderDetails after merge:", {
            hasProducts: !!orderDetails.allProducts,
            hasBoxes: !!orderDetails.allBoxes,
            productCount: orderDetails.allProducts?.length || 0,
            boxCount: orderDetails.allBoxes?.length || 0
          });
        }
        
        // Get warehouse details for Express order
        if (orderDetails.warehouse_id) {
          console.log(`ðŸ” Looking up warehouse details for warehouse_id: ${orderDetails.warehouse_id}`);
          try {
            const warehouseQuery = `SELECT warehouse_name, warehouse_address,warehouse_city,warehouse_state,warehouse_pincode FROM tbl_add_warehouse WHERE serial = ?`;
            const [warehouseResult] = await mySqlQury(warehouseQuery, [orderDetails.warehouse_id]);
            console.log("Warehouse details for Express:", warehouseResult);
            
            if (warehouseResult) {
              orderDetails.warehouse_name = warehouseResult.warehouse_name;
              orderDetails.warehouse_address = warehouseResult.warehouse_address;
              orderDetails.warehouse_city = warehouseResult.warehouse_city;
              orderDetails.warehouse_state = warehouseResult.warehouse_state;
              orderDetails.warehouse_pincode = warehouseResult.warehouse_pincode;
              console.log("Warehouse info added to orderDetails:", {
                warehouse_name: orderDetails.warehouse_name,
                warehouse_address: orderDetails.warehouse_address
              });
            }
          } catch (error) {
            console.error('Error fetching warehouse details for Express:', error);
          }
        } else {
          console.log(`âš ï¸ No warehouse_id found for Express order ${orderDetails.id}, using company details as fallback`);
        }
      }
      
      if (!orderDetails) {
        console.log('No Express order found with orderId (primary key):', orderId);
      }
      
    } else if (orderType === 'ecom') {
      // Get Ecom order details using the correct Ecom tables
      console.log("ecom order type");
      const ecomOrderQuery = `
        SELECT 
          o.*, 
          lr.lr_no, lr.tagged_api, lr.chargable_weight, lr.volumetric_weight,
          lr.pickup_zone, lr.destination_zone, lr.status as lr_status,
          c.company_name, kyc.logo_path, kyc.gst_number as gstin
        FROM tbl_ecom_orders o
        LEFT JOIN tbl_ecom_lr lr ON o.id = lr.order_id
        LEFT JOIN tbl_admin c ON o.client_id = c.id
        LEFT JOIN kyc_submissions kyc ON o.client_id = kyc.user_id
        WHERE o.id = ?
      `;
      
      let rawEcomResult;
      try {
        rawEcomResult = await mySqlQury(ecomOrderQuery, [orderId]);
        console.log('Raw Ecom query result:', rawEcomResult);
      } catch (error) {
        console.error('Ecom SQL Query Error:', error);
        console.error('Query:', ecomOrderQuery);
        console.error('Parameters:', [orderId]);
        rawEcomResult = [[]]; // Return empty result to prevent crashes
      }
      
      let [ecomOrderResult] = rawEcomResult;
      
      console.log('Ecom query result:', { 
        orderId, 
        queryParams: [orderId], 
        rawEcomResult,
        ecomOrderResult,
        resultCount: rawEcomResult.length,
        firstResult: ecomOrderResult
      });
      
      if (ecomOrderResult && rawEcomResult.length > 0) {
        orderDetails = ecomOrderResult;
        
        // Extract LR number for file naming (Ecom)
        lrNumber = orderDetails.lr_no || lrNumber;
        console.log(`ðŸ“‹ LR Number extracted (Ecom): ${lrNumber}`);
        
        // Update filenames with LR number (Ecom) (no timestamp)
        const fileName = `label-${lrNumber}-${labelSize}.pdf`;
        const filePath = path.join(labelSizeDir, fileName);
        
        console.log(`ðŸ“ Updated file paths with LR number (Ecom):`);
        console.log(`   File: ${fileName}`);
        
        // Get Ecom product details
        const ecomProductQuery = `SELECT * FROM tbl_ecom_product_details WHERE order_id = ? ORDER BY id DESC`;
        const ecomProductResult = await mySqlQury(ecomProductQuery, [orderId]);
        console.log("ecomProductResult",ecomProductResult)
        
        if (ecomProductResult && ecomProductResult.length > 0) {
          productDetails = ecomProductResult[0];
          // Store all products for detailed display
          orderDetails.allProducts = ecomProductResult;
          console.log("Stored products in orderDetails.allProducts:", orderDetails.allProducts);
        }
        
        // Get Ecom package details if available (all boxes)
        const ecomPackageQuery = `SELECT * FROM tbl_ecom_boxes_details WHERE order_id = ? ORDER BY id DESC`;
        const ecomPackageResult = await mySqlQury(ecomPackageQuery, [orderId]);
        
        if (ecomPackageResult && ecomPackageResult.length > 0) {
          // Also store all boxes for detailed display
          orderDetails.allBoxes = ecomPackageResult;
          console.log("Stored boxes in orderDetails.allBoxes:", orderDetails.allBoxes);
        }
        
        // Get Ecom consignee details
        const ecomConsigneeQuery = `SELECT * FROM tbl_ecom_consignee_details WHERE order_id = ?`;
        const [ecomConsigneeResult] = await mySqlQury(ecomConsigneeQuery, [orderDetails.id]);
        console.log("ecomConsigneeResult",ecomConsigneeResult)
        
        if (ecomConsigneeResult) {
          console.log("in ecomConsigneeResult",ecomConsigneeResult)
          // Merge consignee details into orderDetails, but preserve allProducts and allBoxes
          orderDetails = { 
            ...orderDetails, 
            ...ecomConsigneeResult,
            allProducts: orderDetails.allProducts, // Preserve products
            allBoxes: orderDetails.allBoxes       // Preserve boxes
          };
          console.log("Final orderDetails after merge:", {
            hasProducts: !!orderDetails.allProducts,
            hasBoxes: !!orderDetails.allBoxes,
            productCount: orderDetails.allProducts?.length || 0,
            boxCount: orderDetails.allBoxes?.length || 0
          });
        }
        
        // Get warehouse details for Ecom order
        if (orderDetails.warehouse_id) {
          console.log(`ðŸ” Looking up warehouse details for warehouse_id: ${orderDetails.warehouse_id}`);
          try {
              const warehouseQuery = `SELECT warehouse_name, warehouse_address,warehouse_city,warehouse_state,warehouse_pincode FROM tbl_add_warehouse WHERE serial = ?`;
            const [warehouseResult] = await mySqlQury(warehouseQuery, [orderDetails.warehouse_id]);
            console.log("Warehouse details for Ecom:", warehouseResult);
            console.log("orderDetails",warehouseResult.length)
            
            if (warehouseResult) {
              orderDetails.warehouse_name = warehouseResult.warehouse_name;
              orderDetails.warehouse_address = warehouseResult.warehouse_address;
              orderDetails.warehouse_city = warehouseResult.warehouse_city;
              orderDetails.warehouse_state = warehouseResult.warehouse_state;
              orderDetails.warehouse_pincode = warehouseResult.warehouse_pincode;
              console.log("Warehouse info added to orderDetails:", {
                warehouse_name: orderDetails.warehouse_name,
                warehouse_address: orderDetails.warehouse_address
              });
            }
          } catch (error) {
            console.error('Error fetching warehouse details for Ecom:', error);
          }
        } else {
          console.log(`âš ï¸ No warehouse_id found for Ecom order ${orderDetails.id}, using company details as fallback`);
        }
      }
      
      if (!orderDetails) {
        console.log('No Ecom order found with orderId (primary key):', orderId);
      }
    }
    console.log("orderDetails",orderDetails)
    if (!orderDetails) {
      return res.status(404).json({
        success: false,
        message: `Order not found in ${orderType} tables`
      });
    }

    // 4. Generate HTML content based on preferences and order type
    const htmlContent = generateShippingLabelHTML({
      order: orderDetails,
      product: productDetails,
      preferences: userPreferences,
      labelSize,
      orderType
    });

    // 5. Convert to PDF
    const pdfBuffer = await convertHTMLToPDF(htmlContent, labelSize);

    // 6. Save PDF to disk for future use
    try {
      fs.writeFileSync(filePath, pdfBuffer);
      console.log(`Label saved to: ${filePath}`);
    } catch (writeError) {
      console.error('Error saving label to disk:', writeError);
      // Continue anyway - we can still send the PDF
    }

    // 7. Set response headers
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');

    // 8. Send PDF buffer
    res.end(pdfBuffer);

  } catch (error) {
    console.error('Error generating new shipping label:', error);
    if (!res.headersSent) {
      res.status(500).json({
        success: false,
        message: 'Error generating shipping label',
        error: error.message
      });
    }
  }
};

// Utility function to clean up old labels (can be called via cron job)
const cleanupOldLabels = async (daysToKeep = 30) => {
  try {
    const labelsDir = path.join(__dirname, '..', 'public', 'shipping-labels');
    if (!fs.existsSync(labelsDir)) return;
    
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);
    
    let totalDeleted = 0;
    let totalSize = 0;
    
    // Recursively find all PDF files
    const findPDFs = (dir) => {
      const files = fs.readdirSync(dir);
      files.forEach(file => {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);
        
        if (stat.isDirectory()) {
          findPDFs(filePath);
        } else if (file.endsWith('.pdf') && file.includes('-')) {
          // Check if file has timestamp (contains '-')
          const fileDate = stat.mtime;
          if (fileDate < cutoffDate) {
            try {
              fs.unlinkSync(filePath);
              totalDeleted++;
              totalSize += stat.size;
              console.log(`Deleted old label: ${filePath}`);
            } catch (error) {
              console.error(`Error deleting ${filePath}:`, error);
            }
          }
        }
      });
    };
    
    findPDFs(labelsDir);
    
    console.log(`Cleanup completed: ${totalDeleted} files deleted, ${(totalSize / 1024 / 1024).toFixed(2)} MB freed`);
    
  } catch (error) {
    console.error('Error during label cleanup:', error);
  }
};

// Get Orders List for Shipping Label Page
const getOrdersList = async (req, res) => {
  try {
    const userId = req.user?.selectedClientId;
    
    if (!userId) {
      return res.status(400).json({
        success: false,
        message: 'User ID not found'
      });
    }

    // Get orders from both Express and Ecom tables
    const expressOrdersQuery = `
      SELECT 
        o.orderid as order_id,
        o.ref_number,
        o.invoice_no,
        lr.lr_no,
        CONCAT(cd.first_name, ' ', cd.last_name) as consignee_name,
        cd.city as consignee_city,
        cd.pincode as consignee_pincode,
        lr.chargable_weight,
        lr.tagged_api,
        o.created_at,
        o.company_name,
        cd.address_line1 as consignee_address,
        cd.phone as consignee_phone,
        o.grand_total,
        o.collectable_amount,
        o.payment_mode,
        kyc.gst_number as gstin,
        'express' as order_type
      FROM tbl_exp_orders o
      LEFT JOIN tbl_exp_lr lr ON o.id = lr.order_id
      LEFT JOIN tbl_exp_consignee_details cd ON o.id = cd.order_id
      LEFT JOIN kyc_submissions kyc ON o.client_id = kyc.user_id
      WHERE o.client_id = ?
      ORDER BY o.created_at DESC
      LIMIT 50
    `;
    
    const ecomOrdersQuery = `
      SELECT 
        o.orderid as order_id,
        o.po_no,
        o.invoice_no,
        lr.lr_no,
        CONCAT(cd.first_name, ' ', cd.last_name) as consignee_name,
        cd.city as consignee_city,
        cd.pincode as consignee_pincode,
        lr.chargable_weight,
        lr.tagged_api,
        o.created_at,
        o.company_name,
        cd.address_line1 as consignee_address,
        cd.phone as consignee_phone,
        o.grand_total,
        o.collectable_amount,
        o.payment_mode,
        kyc.gst_number as gstin,
        'ecom' as order_type
      FROM tbl_ecom_orders o
      LEFT JOIN tbl_ecom_lr lr ON o.id = lr.order_id
      LEFT JOIN tbl_ecom_consignee_details cd ON o.id = cd.order_id
      LEFT JOIN kyc_submissions kyc ON o.client_id = kyc.user_id
      WHERE o.client_id = ?
      ORDER BY o.created_at DESC
      LIMIT 50
    `;
    
    const [expressOrders] = await mySqlQury(expressOrdersQuery, [userId]);
    const [ecomOrders] = await mySqlQury(ecomOrdersQuery, [userId]);
    
    // Combine and sort orders by creation date
    const allOrders = [...(expressOrders || []), ...(ecomOrders || [])];
    const orders = allOrders.sort((a, b) => new Date(b.created_at) - new Date(a.created_at)).slice(0, 100);
    
    if (!orders) {
      return res.status(200).json({
        success: true,
        data: []
      });
    }

    // Format the orders data
    const formattedOrders = orders.map(order => ({
      orderId: order.order_id,
      lrNo: order.lr_no || 'N/A',
      consigneeName: order.consignee_name || 'N/A',
      consigneeCity: order.consignee_city || 'N/A',
      consigneePincode: order.consignee_pincode || 'N/A',
      weight: order.chargable_weight || 'N/A',
      courier: order.tagged_api || 'N/A',
      orderDate: order.created_at,
      companyName: order.company_name || 'N/A',
      consigneeAddress: order.consignee_address || 'N/A',
      consigneePhone: order.consignee_phone || 'N/A',
      grandTotal: order.grand_total || 'N/A',
      collectableAmount: order.collectable_amount || 'N/A',
      paymentMode: order.payment_mode || 'N/A',
      orderType: order.order_type || 'ecom'
    }));

    res.status(200).json({
      success: true,
      data: formattedOrders
    });

  } catch (error) {
    console.error('Error fetching orders list:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching orders list',
      error: error.message
    });
  }
};

// Helper function to generate HTML content based on preferences
const generateShippingLabelHTML = ({ order, product, preferences, labelSize, orderType = 'ecom' }) => {
  const currentDate = new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: '2-digit'
  });
  console.log("ðŸ” generateShippingLabelHTML called with:");
  console.log("  - order:", order);
  console.log("  - product:", product);
  console.log("  - preferences:", preferences);
  console.log("  - labelSize:", labelSize);
  console.log("  - orderType:", orderType);
  console.log("  - order keys:", Object.keys(order));
  console.log("  - order.orderid:", order.orderid);
  console.log("  - order.id:", order.id);
  console.log("  - order.ref_number:", order.ref_number);
  console.log("  - order.po_no:", order.po_no);

  // Field mapping based on order type with static fallbacks
  const fieldMap = {
    express: {
      orderId: order.orderid || order.ref_number || 'EXPRESS-001',
      invoiceNumber: order.invoice_no || 'INV-001',
      consigneeName: `${order.first_name || ''} ${order.last_name || ''}`.trim() || 'Customer Name',
      consigneeAddress: order.address_line1 || 'Customer Address',
      consigneeCity: order.city || 'City',
      consigneeState: order.state || 'State',
      consigneePincode: order.pincode || '000000',
      consigneePhone: order.phone || '0000000000',
      lrNo: order.lr_no || 'LR-001',
      courier: order.tagged_api || 'Express',
      collectableValue: order.collectable_amount || '0',
      declaredValue: order.grand_total || '0',
      dimension: product ? `${product.length || '10'}x${product.breadth || '10'}x${product.height || '10'} ${product.dimension_unit || 'cm'}` : '10x10x10 cm',
      weight:`${order.total_weight || '1'} ${order.weight_unit || 'kg'}`,
      companyName: order.company_name || 'Company Name',
      companyAddress: order.warehouse_address || 'Company Address',
      companyPhone: order.warehouse_phone || '0000000000',
      gstin: order.gstin || 'GSTIN000000000',
      total_boxes: order.total_boxes || '1',
    },
    ecom: {
      orderId: order.orderid || order.po_no || 'PO-001',
      invoiceNumber: order.invoice_no || order.invoice_number || 'INV-001',
      consigneeName: `${order.first_name || ''} ${order.last_name || ''}`.trim() || 'Customer Name',
      consigneeAddress: order.address_line1 || order.consignee_address || 'Customer Address',
      consigneeCity: order.city || order.destination_city || 'City',
      consigneeState: order.state || order.destination_state || 'State',
      consigneePincode: order.pincode || order.destination_pincode || '000000',
      consigneePhone: order.phone || order.consignee_phone || '0000000000',
      lrNo: order.lr_no || 'LR-001',
      courier: order.tagged_api || order.courier || 'Standard',
      collectableValue: order.collectable_amount || order.collectable_value || '0',
      declaredValue: order.grand_total || order.declared_value || '0',
      dimension: product ? product.dimension : '10x10x10 cm',
      weight: product ? `${product.weight} ${product.weight_unit || 'KG'}` : '1 KG',
      companyName: order.company_name || 'Company Name',
      companyAddress: order.warehouse_address || order.from_address || 'Company Address',
      companyPhone: order.warehouse_phone || order.from_phone || '0000000000',
      gstin: order.gstin || 'GSTIN000000000'
    }
  };

  const fields = fieldMap[orderType] || fieldMap.ecom;

    // Generate different HTML based on label size
  try {
    console.log('Generating HTML for label size:', labelSize);
    console.log('Order data keys:', Object.keys(order));
    console.log('Order has products:', !!order.allProducts);
    console.log('Order has boxes:', !!order.allBoxes);
    if (order.allProducts) {
      console.log('Product count:', order.allProducts.length);
      console.log('First product:', order.allProducts[0]);
    }
    if (order.allBoxes) {
      console.log('Box count:', order.allBoxes.length);
      console.log('First box:', order.allBoxes[0]);
    }
    
    let html;
    switch (labelSize) {
      case '4X4':
        html = generate4X4Label(order, preferences, orderType);
        break;
      case '4X6':
        html = generate4X6Label(order, preferences, orderType);
        break;
      case '4X2':
        html = generate4X2Label(order, preferences, orderType);
        break;
      case 'A4':
        html = generateA4Label(order, preferences, orderType);
        break;
      default:
        html = generate4X6Label(order, preferences, orderType); // Default to 4X6
    }
    
    console.log('HTML generated successfully, length:', html.length);
    return html;
  } catch (error) {
    console.error('Error generating HTML:', error);
    console.error('Error details:', {
      message: error.message,
      stack: error.stack,
      labelSize,
      orderType,
      orderKeys: Object.keys(order)
    });
    
    // Generate a simple fallback label
    console.log('Generating fallback simple label...');
    const fallbackHtml = `<!DOCTYPE html>
<html>
<head><title>Shipping Label</title></head>
<body style="font-family: Arial; padding: 20px;">
  <h2>Shipping Label</h2>
  <p><strong>Order ID:</strong> ${order.orderid || 'N/A'}</p>
  <p><strong>AWB:</strong> ${order.lr_no || 'N/A'}</p>
  <p><strong>Courier:</strong> ${order.tagged_api || 'N/A'}</p>
  <p><strong>From:</strong> ${order.company_name || 'N/A'}</p>
  <p><strong>To:</strong> ${order.first_name || 'N/A'}</p>
  <p><strong>Address:</strong> ${order.address_line1 || 'N/A'}</p>
  <p><strong>City:</strong> ${order.city || 'N/A'}</p>
  <p><strong>Weight:</strong> ${order.total_weight || 'N/A'} ${order.weight_unit || ''}</p>
</body>
</html>`;
    
    console.log('Fallback HTML generated, length:', fallbackHtml.length);
    return fallbackHtml;
  }
};


// 4X4 Label Generator
const generate4X4Label = (order, preferences, orderType) => {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Shipping Label 4x4</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>
  <style>
    @media print {
      @page {
        size: 4in 4in;
        margin: 0;
      }
      body {
        margin: 0;
      }
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      font-size: 7pt;
      width: 4in;
      height: 4in;
      margin: 0;
      padding: 0;
      background: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .label-box {
      width: 3.86in;
      height: 3.86in;
      border: 2px solid #000;
      padding: 5px;
      display: flex;
      flex-direction: column;
    }

    .row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    .col-4 {
      width: 32%;
    }

    .col-6 {
      width: 48%;
    }

    .col-12 {
      width: 100%;
    }

    .section-title {
      font-weight: bold;
      font-size: 7pt;
      margin-bottom: 2px;
    }

    .info-text {
      font-size: 6.5pt;
      line-height: 1.2;
    }

    .icon-box {
      color: #000;
      padding: 5px 2px;
      font-size: 6pt;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 50px;
    }

    .icon-box i {
      font-size: 18px;
      margin-bottom: 2px;
    }

    .method span {
      padding: 1px 4px;
      font-size: 6pt;
      border: 1px solid #000;
      border-radius: 2px;
      margin-right: 2px;
    }

    .section-divider {
      border-top: 1px dashed #999;
      margin: 2px 0;
    }

    .qrcode img {
      height: 50px;
      margin: 2px auto;
    }

    .footer {
      font-size: 6pt;
      text-align: center;
    }

    .text-small {
      font-size: 6pt;
    }
    
    .barcode svg {
      max-width: 100% !important;
      max-height: 100% !important;
      overflow: hidden !important;
    }
  </style>
</head>
<body>

<div class="label-box">

  <!-- Logos -->
  <div class="row mb-1">
    <div class="col-4 text-start d-flex align-items-center">
      <img src="${getCourierLogoPath(order.tagged_api)}" alt="${order.tagged_api}" style="max-height: 25px; max-width: 100%;">
    </div>
    
    <div class="col-4 text-end d-flex align-items-center justify-content-end">
      ${order.logo_path ? 
        `<img src="${getCompanyLogoPath(order.logo_path)}" alt="${order.company_name}" style="max-height: 25px; max-width: 100%;">` : 
        `<div style="font-size: 10pt; font-weight: bold;">${order.company_name}</div>`
      }
    </div>
  </div>

  <!-- From and To -->
  <div class="row">
    <div class="col-6">
      <div class="section-title">FROM:</div>
      <div class="info-text">
        ${order.warehouse_name?.toUpperCase() || order.company_name?.toUpperCase() || 'WAREHOUSE NAME'}<br>
        ${order.warehouse_address || 'WAREHOUSE ADDRESS'}<br>
        ${order.warehouse_city || 'CITY'}, ${order.warehouse_state || 'STATE'} ${order.warehouse_pincode || '000000'}<br>
      </div>
    </div>
    <div class="col-6">
      <div class="section-title">TO:</div>
      <div class="info-text">
        <strong>${order.first_name?.toUpperCase() || 'CONSIGNEE NAME'}</strong><br>
        ${order.address_line1?.toUpperCase() || 'CONSIGNEE ADDRESS'}<br>
        ${order.city?.toUpperCase() || 'CITY'}, ${order.state?.toUpperCase() || 'STATE'}<br>
        ${order.pincode?.toUpperCase() || 'PINCODE'}<br>
      </div>
    </div>
  </div>

  <!-- Icons + QR -->
  <div class="row mt-1">
    <div class="col-4">
      <div class="icon-box">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
          <path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"/>
        </svg>
        <span>FRAGILE</span>
      </div>
    </div>
    <div class="col-4">
      <div class="icon-box">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
          <path d="M9.302 1.256a1.5 1.5 0 0 0-2.604 0l-1.704 2.98a.5.5 0 0 0 .869.497l1.703-2.981a.5.5 0 0 1 .868 0l2.54 4.444-1.372-.789a.5.5 0 1 0-.497.87l1.86 1.07a.5.5 0 0 0 .523-.047l3.5-2.5a.5.5 0 0 0-.848-.53l-2.89 2.065L9.302 1.256zM4.5 7.319l.557-.97a.5.5 0 1 1 .868.497l-.786 1.374a.5.5 0 0 1-.868 0l-.786-1.374a.5.5 0 1 1 .868-.497l.147.256zm3.593 2.168.557-.97a.5.5 0 1 1 .868.497l-.786 1.374a.5.5 0 0 1-.868 0l-.786-1.374a.5.5 0 1 1 .868-.497l.147.256z"/>
        </svg>
        <span>RECYCLE</span>
      </div>
    </div>
    <div class="col-4 qrcode text-center">
      <img src="https://api.qrserver.com/v1/create-qr-code/?size=120x120&data=${order.lr_no}" alt="QR Code" style="width: 70%; height: auto;">
    </div>
  </div>

  <!-- Tracking + Method -->
  <div class="row mt-1 text-center">
    <div class="col-12 method mt-1">
      <span class="badge bg-success me-1">${orderType.toUpperCase()}</span>
      <span class="badge bg-secondary">Standard</span>
    </div>
  </div>

  <!-- Order + Barcode -->
  <div class="section-divider"></div>
  <div class="row">
    <div class="col-6">
      <span class="text-dark">Purchase Order: ${order.orderid}</span><br>
      <strong>Order No: ${order.orderid}</strong><br>
      <strong>AWB Number:</strong><br>${order.lr_no}
    </div>
    <div class="col-6 barcode">
      <div style="width: 80%; height: 40px; background: #f0f0f0; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 8pt; overflow: hidden;">
        <svg id="barcode-${order.lr_no}" style="width: 100%; height: 100%; max-width: 100%; max-height: 100%; overflow: hidden;"></svg>
        <script>
          JsBarcode("#barcode-${order.lr_no}", "${order.lr_no}", {
            format: "CODE128",
            height: 35,
            width: 1.2,
            displayValue: true,
            fontSize: 8,
            margin: 2
          });
        </script>
      </div>
    </div>
  </div>

  <!-- Delivery instruction -->
  <div class="section-divider"></div>
  <div class="row">
    <div class="col-12 text-small">
      <strong>Delivery instruction:</strong><br>Standard Delivery
    </div>
  </div>

  <!-- Footer -->
  <div class="footer bg-white shadow-sm rounded p-2 mt-1">
    <div class="row align-items-center mb-0">
      <div class="col-6 text-center">
        <div style="font-size: 10pt; font-weight: bold; color: #007bff;">dispatch</div>
        <div class="text-primary" style="font-size: 7pt;">Powered by <span class="fw-bold">Dispatch Solutions</span></div>
      </div>

      <div class="col-6 text-center">
        <div class="text-secondary" style="font-size: 7pt;">support@dispatch.co.in</div>
        <div class="text-primary" style="font-size: 7pt;">www.dispatch.co.in</div>
      </div>
    </div>
  </div>

</div>

</body>
</html>`;
};

// Helper function to get courier logo text
const getCourierLogoPath = (courier) => {
  console.log("courier",courier)
  if (!courier) return 'COURIER';
  
  // For PDF generation, we need base64 encoded images
  const fs = require('fs');
  const path = require('path');
  
  try {
    let imagePath = '';
    if (courier?.toLowerCase().includes('expressbees') || courier?.toLowerCase().includes('xpressbees')) {
      imagePath = path.join(__dirname, '../public/assets/images/logos/expressbees.png');
    } else if (courier?.toLowerCase().includes('delhivery')) {
      imagePath = path.join(__dirname, '../public/assets/images/logos/delhivery.png');
    } else if (courier?.toLowerCase().includes('dtdc')) {
      imagePath = path.join(__dirname, '../public/assets/images/logos/dtdc.png');
    } else {
      imagePath = path.join(__dirname, '../public/assets/images/logos/logo-dark.png');
    }
    
    console.log('Attempting to read image from:', imagePath);
    
    if (fs.existsSync(imagePath)) {
      const imageBuffer = fs.readFileSync(imagePath);
      const base64Image = imageBuffer.toString('base64');
      const mimeType = 'image/png';
      console.log(`Successfully converted image to base64, size: ${base64Image.length} characters`);
      return `data:${mimeType};base64,${base64Image}`;
    } else {
      console.log(`Image not found: ${imagePath}, falling back to text`);
      return courier; // Return text instead of broken image
    }
  } catch (error) {
    console.error('Error reading image file:', error);
    console.error('Error details:', {
      message: error.message,
      stack: error.stack,
      courier: courier,
      cwd: process.cwd(),
      __dirname: __dirname
    });
    console.log('Falling back to text-based logo');
    return courier; // Return text instead of broken image
  }
};

// Helper function to get company logo as base64 data URL
const getCompanyLogoPath = (logoPath) => {
  console.log("company logo path:", logoPath);
  if (!logoPath) return null;
  
  // For PDF generation, we need base64 encoded images
  const fs = require('fs');
  const path = require('path');
  
  try {
    // Logo files are stored in public/assets/clientdocs/
    const imagePath = path.join(__dirname, '../public/assets/clientdocs/', logoPath);
    
    console.log('Attempting to read company logo from:', imagePath);
    
    if (fs.existsSync(imagePath)) {
      const imageBuffer = fs.readFileSync(imagePath);
      const base64Image = imageBuffer.toString('base64');
      
      // Determine MIME type based on file extension
      let mimeType = 'image/jpeg'; // default
      if (logoPath.toLowerCase().endsWith('.png')) {
        mimeType = 'image/png';
      } else if (logoPath.toLowerCase().endsWith('.gif')) {
        mimeType = 'image/gif';
      }
      
      console.log(`Successfully converted company logo to base64, size: ${base64Image.length} characters, type: ${mimeType}`);
      return `data:${mimeType};base64,${base64Image}`;
    } else {
      console.log(`Company logo not found: ${imagePath}`);
      return null;
    }
  } catch (error) {
    console.error('Error reading company logo file:', error);
    console.error('Error details:', {
      message: error.message,
      stack: error.stack,
      logoPath: logoPath,
      cwd: process.cwd(),
      __dirname: __dirname
    });
    return null;
  }
};

// Helper function to get Dispatch logo as base64 data URL
const getDispatchLogoPath = () => {
  const fs = require('fs');
  const path = require('path');
  
  try {
    const imagePath = path.join(__dirname, '../public/assets/images/logos/logo-dark.png');
    console.log('Attempting to read Dispatch logo from:', imagePath);
    
    if (fs.existsSync(imagePath)) {
      const imageBuffer = fs.readFileSync(imagePath);
      const base64Image = imageBuffer.toString('base64');
      const mimeType = 'image/png';
      console.log(`Successfully converted Dispatch logo to base64, size: ${base64Image.length} characters`);
      return `data:${mimeType};base64,${base64Image}`;
    } else {
      console.log(`Dispatch logo not found: ${imagePath}, falling back to text`);
      return 'dispatch'; // Return text instead of broken image
    }
  } catch (error) {
    console.error('Error reading Dispatch logo file:', error);
    return 'dispatch'; // Return text instead of broken image
  }
};

// 4X6 Label Generator
const generate4X6Label = (order, preferences, orderType) => {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Shipping Label 4x6</title>
  <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      background: white;
      width: 4in;
      height: 6in;
      padding: 0 8px;
      font-size: 8px;
      line-height: 1.1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .shipping-label {
      width: calc(100% - 16px);
      height: calc(100% - 16px);
      border: 2px solid #000;
      background: white;
      position: relative;
      margin: 8px;
    }

    /* Header Section */
    .header-row {
      display: flex;
      border-bottom: 2px solid #000;
      height: 40px;
    }

    .company-section {
      flex: 1;
      border-right: 2px solid #000;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f8f8f8;
      font-weight: bold;
      font-size: 12px;
      text-transform: uppercase;
    }

    .courier-section {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f8f8f8;
    }

    .courier-logo {
      max-height: 35px;
      max-width: 140px;
    }

    /* First Barcode Section */
    .first-barcode {
      text-align: center;
      padding: 8px;
      border-bottom: 1px solid #000;
    }

    /* AWB Row */
    .awb-row {
      display: flex;
      height: 25px;
      border-bottom: 1px solid #000;
    }

    .awb-left {
      flex: 1;
      display: flex;
      align-items: center;
      padding-left: 8px;
      font-size: 10px;
      font-weight: bold;
    }

    .awb-right {
      width: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-left: 1px solid #000;
      font-size: 9px;
      font-weight: bold;
    }

    /* Address Section */
    .address-section {
      display: flex;
      min-height: 120px;
      border-bottom: 1px solid #000;
    }

    .ship-to {
      flex: 2;
      padding: 8px;
      border-right: 1px solid #000;
    }

    .service-info {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .service-type {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      border-bottom: 1px solid #000;
      font-size: 9px;
      font-weight: bold;
    }

    .service-amount {
      flex: 1;
      text-align: center;
      padding: 8px;
      font-size: 9px;
      font-weight: bold;
    }

    /* Seller Section */
    .seller-section {
      display: flex;
      height: 80px;
      border-bottom: 1px solid #000;
    }

    .seller-info {
      flex: 2;
      padding: 8px;
      border-right: 1px solid #000;
      font-size: 7px;
    }

    .date-section {
      flex: 1;
      padding: 8px;
      font-size: 7px;
    }

    /* Product Table */
    .product-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 8px;
    }

    .product-table th,
    .product-table td {
      border: 1px solid #000;
      padding: 4px;
      text-align: left;
    }

    .product-table th {
      background: #f0f0f0;
      font-weight: bold;
    }

    /* Bottom Barcode */
    .bottom-barcode {
      text-align: center;
      padding: 8px;
      border-bottom: 1px solid #000;
    }

    /* Return Address */
    .return-address {
      padding: 8px;
      font-size: 7px;
      line-height: 1.2;
    }

    .label-title {
      font-weight: bold;
      font-size: 9px;
      margin-bottom: 4px;
    }

    .address-text {
      font-size: 8px;
      line-height: 1.3;
    }

    .consignee-name {
      font-weight: bold;
      font-size: 9px;
      text-transform: uppercase;
    }
  </style>
</head>
<body>
  <div class="shipping-label">
    <!-- Header Row -->
    <div class="header-row">
      <div class="company-section">
        ${order.company_name || 'DISPATCH SOLUTIONS'}
      </div>
      <div class="courier-section">
        <img src="${getCourierLogoPath(order.tagged_api)}" alt="${order.tagged_api}" class="courier-logo">
      </div>
    </div>

    <!-- First Barcode -->
    <div class="first-barcode">
      <svg id="barcode-top-${order.lr_no}" style="height: 40px; width: 280px;"></svg>
      <script>
        JsBarcode("#barcode-top-${order.lr_no}", "${order.lr_no}", {
          format: "CODE128",
          height: 35,
          width: 2,
          displayValue: true,
          fontSize: 10,
          margin: 0
        });
      </script>
      <div style="font-size: 10px; font-weight: bold; margin-top: 2px;">${order.lr_no}</div>
    </div>

    <!-- AWB Row -->
    <div class="awb-row">
      <div class="awb-left">${order.orderid}</div>
      <div class="awb-right">${order.payment_mode || 'COD'}</div>
    </div>

    <!-- Address Section -->
    <div class="address-section">
      <div class="ship-to">
        <div class="label-title">Ship To:</div>
        <div class="consignee-name">${(order.first_name || 'CONSIGNEE NAME').toUpperCase()}</div>
        <div class="address-text">
          ${order.address_line1 || 'Address Line 1'}<br>
          ${order.city || 'City'}, ${order.state || 'State'}<br>
          ${order.pincode || 'PINCODE'}<br>
          <strong>PIN: ${order.pincode || '000000'}</strong>
        </div>
      </div>
      <div class="service-info">
        <div class="service-type">
          ${order.payment_mode || 'COD'}<br>
          Surface
        </div>
        <div class="service-amount">
          INR<br>
          ${order.grand_total || order.collectable_amount || '0'}
        </div>
      </div>
    </div>

    <!-- Seller Section -->
    <div class="seller-section">
      <div class="seller-info">
        <strong>Seller: ${order.company_name || 'DISPATCH SOLUTIONS'}</strong><br>
        <strong>Address:</strong> ${order.warehouse_address || order.company_address || 'Warehouse Address'}<br>
        ${order.warehouse_city || 'City'}, ${order.warehouse_state || 'State'}, ${order.warehouse_pincode || '000000'}
      </div>
      <div class="date-section">
        <strong>Date:</strong> ${new Date().toLocaleDateString()}<br>
        <strong>Time:</strong> ${new Date().toLocaleTimeString()}
      </div>
    </div>

    <!-- Product Table -->
    <table class="product-table">
      <thead>
        <tr>
          <th>Product(Qty)</th>
          <th>Price</th>
          <th>Total</th>
        </tr>
      </thead>
      <tbody>
        ${order.allProducts && order.allProducts.length > 0 ? 
          order.allProducts.slice(0, 3).map(product => `
            <tr>
              <td>${(product.name || 'Product').substring(0, 20)}(${product.qty || '1'})</td>
              <td>INR ${product.price || order.collectable_amount}</td>
              <td>INR ${product.price || order.collectable_amount}</td>
            </tr>
          `).join('') :
          `<tr>
            <td>TEA ITEMS(1)</td>
            <td>INR ${order.collectable_amount || '0'}</td>
            <td>INR ${order.collectable_amount || '0'}</td>
          </tr>`
        }
        <tr style="border-top: 2px solid #000;">
          <td><strong>Total</strong></td>
          <td></td>
          <td><strong>INR ${order.grand_total || order.collectable_amount || '0'}</strong></td>
        </tr>
      </tbody>
    </table>

    <!-- Bottom Barcode -->
    <div class="bottom-barcode">
      <svg id="barcode-bottom-${order.lr_no}" style="height: 35px; width: 300px;"></svg>
      <script>
        JsBarcode("#barcode-bottom-${order.lr_no}", "${order.lr_no}", {
          format: "CODE128",
          height: 30,
          width: 2.2,
          displayValue: true,
          fontSize: 9,
          margin: 0
        });
      </script>
    </div>

    <!-- Return Address -->
    <div class="return-address">
      <strong>Return Address:</strong> ${order.warehouse_name || order.company_name || 'WAREHOUSE NAME'}<br>
      ${order.warehouse_address || order.company_address || 'Return Address'}<br>
      ${order.warehouse_city || 'City'}, ${order.warehouse_state || 'State'}, ${order.warehouse_pincode || '000000'}
      
      <!-- Dispatch Branding -->
      <div style="text-align: center; margin-top: 8px; border-top: 1px solid #ddd; padding-top: 6px;">
        <img src="${getDispatchLogoPath()}" alt="Dispatch" style="height: 20px; margin-bottom: 4px;">
        <div style="font-size: 6px; color: #666;">
          support@dispatch.co.in | +91 9313 388 388 | www.dispatch.co.in
        </div>
      </div>
    </div>
  </div>
</body>
</html>`;
};

// 4X2 Label Generator
const generate4X2Label = (order, preferences, orderType) => {
  return `<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Shipping Label 4x2</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
        <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
        <style>
    body {
      font-family: Arial, sans-serif;
      font-size: 8pt;
      margin: 0;
      padding: 0;
      background: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .label-box {
      width: 3.86in;
      height: 1.86in;
      border: 1px solid #000;
      padding: 5px;
      box-sizing: border-box;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 2px;
      /* Center the 4X2 label on its own page */
      margin: auto;
    }

    .logo-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      height: 15px;
    }

    .content-area {
      display: grid;
      grid-template-rows: auto auto;
      gap: 2px;
      margin-bottom: 2px;
    }

    .addresses {
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }

    .tracking-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .section-title {
      font-weight: bold;
      font-size: 7pt;
      margin-bottom: 1px;
    }

    .info-text {
      font-size: 6pt;
      line-height: 1.1;
    }

    .barcode {
      width: 25%;
    }

    .method span {
      font-size: 6pt;
      padding: 1px 4px;
      border: 1px solid #000;
      border-radius: 2px;
      margin-right: 2px;
    }

    .footer {
      font-size: 5pt;
      text-align: center;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-top: 2px;
      border-top: 1px solid #eee;
      margin-top: auto;
      height: 20px;
      overflow: hidden;
    }

    .footer-content {
      display: flex;
      flex-direction: center;
      align-items: center;
      line-height: 1;
    }

    .footer-right {
      text-align: right;
      line-height: 1;
    }

    .col-6 {
      width: 48%;
    }

    .col-4 {
      width: 32%;
    }

    .col-8 {
      width: 65%;
    }
    
    .barcode svg {
      max-width: 100% !important;
      max-height: 100% !important;
      overflow: hidden !important;
    }
  </style>
    </head>
    <body>
        <div class="label-box">
            <div class="logo-row">
                <img src="${getCourierLogoPath(order.tagged_api)}" alt="${order.tagged_api}" style="max-height: 20px; max-width: 100%;">
                ${order.logo_path ? 
                  `<img src="${getCompanyLogoPath(order.logo_path)}" alt="${order.company_name}" style="max-height: 20px; max-width: 100%;">` : 
                  `<div style="font-size: 8pt; font-weight: bold;">${order.company_name}</div>`
                }
            </div>

            <div class="content-area">
                <div class="addresses">
                    <div class="col-6">
                        <div class="section-title">From:</div>
      <div class="info-text">
        ${order.warehouse_name?.toUpperCase() || order.company_name?.toUpperCase() || 'WAREHOUSE NAME'}<br>
        ${order.warehouse_address || 'WAREHOUSE ADDRESS'}<br>
        ${order.warehouse_city || 'CITY'}, ${order.warehouse_state || 'STATE'} ${order.warehouse_pincode || '000000'}<br>
      </div>
                    </div>
                    <div class="col-6">
                        <div class="section-title">To:</div>
                        <div class="info-text">
                            <strong>${order.first_name?.toUpperCase() || 'CONSIGNEE NAME'}</strong><br>
                            ${order.address_line1?.toUpperCase() || 'CONSIGNEE ADDRESS'}<br>
                            ${order.city?.toUpperCase() || 'CITY'}, ${order.state?.toUpperCase() || 'STATE'}<br>
                            ${order.pincode?.toUpperCase() || 'PINCODE'}
                        </div>
                    </div>
                </div>

                <div class="tracking-info">
                    <div class="col-8">
                        <div style="margin-bottom: 2px;">
                            <strong>AWB Number:</strong> ${order.lr_no}<br>
                            <strong>Order No: ${order.orderid}</strong>
                        </div>
                        <div class="method">
                            <span class="badge border border-dark text-dark bg-white me-1">${orderType.toUpperCase()}</span>
                            <span class="badge border border-dark text-dark bg-white">Standard</span>
                        </div>
                    </div>
                    <div class="col-4 barcode text-center">
                        <div style="width: 100%; height: 30px; background: #f0f0f0; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 6pt; overflow: hidden;">
                            <svg id="barcode-${order.lr_no}" style="width: 100%; height: 100%; max-width: 100%; max-height: 100%; overflow: hidden;"></svg>
                            <script>
                              JsBarcode("#barcode-${order.lr_no}", "${order.lr_no}", {
                                format: "CODE128",
                                height: 25,
                                width: 1,
                                displayValue: true,
                                fontSize: 6,
                                margin: 1
                              });
                            </script>
                        </div>
                        <div style="font-size: 7pt;">${order.lr_no}</div>
                    </div>
                </div>
            </div>

            <div class="footer">
                <div class="footer-content">
                    <div style="font-size: 8pt; font-weight: bold; color: #007bff;">dispatch</div>
                    <small>Powered by <strong>Dispatch Solutions</strong></small>
                </div>
                <div class="footer-right">
                    <small>support@dispatch.co.in</small><br>
                    <small>www.dispatch.co.in</small>
                </div>
            </div>
        </div>
    </body>
</html>`;
};

// A4 Label Generator
const generateA4Label = (order, preferences, orderType) => {
  console.log("preferences in the a4", preferences);
  
  // Helper function to check if a preference is enabled
  const isEnabled = (prefKey) => preferences && preferences[prefKey] === 1;
  
  // Helper function to limit item name length
  const limitItemName = (name, limit = 30) => {
    if (!isEnabled('limit_item_name_length') || !name) return name || 'Product';
    return name.length > limit ? name.substring(0, limit) + '...' : name;
  };

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Shipping Invoice - A4</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>
  <style>
    @media print {
      @page {
        size: A4;
        margin: 5mm;
      }
    }

    body {
      font-family: Arial, sans-serif;
      font-size: 10pt;
      background-color: #fff;
      color: #000;
      padding: 0;
      margin: 0;
    }

    .invoice-box {
      width: calc(100% - 40px);
      border: 1px solid #000;
      padding: 20px;
      box-sizing: border-box;
      margin: 20px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    table, th, td {
      border: 1px solid #000;
    }

    th, td {
      padding: 4px;
      font-size: 9pt;
      text-align: left;
    }

    .section-title {
      font-weight: bold;
      margin-bottom: 2px;
    }

    .divider {
      border-top: 1px dashed #999;
      margin: 15px 0;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    .col-4 {
      width: 33%;
    }

    .col-5 {
      width: 41%;
    }

    .col-6 {
      width: 48%;
      padding-right: 2%;
    }

    .col-7 {
      width: 58%;
    }

    .col-12 {
      width: 100%;
    }

    .signature-space {
      height: 60px;
      border: 1px dashed #000;
      margin-top: 5px;
    }

    .text-center {
      text-align: center;
    }

    .footer {
      margin-top: 40px;
      font-size: 8pt;
      padding-top: 5px;
    }
    
    .text-center svg {
      max-width: 100% !important;
      max-height: 100% !important;
      overflow: hidden !important;
    }
  </style>
</head>
<body>

<div class="invoice-box">
  <!-- Header with logos -->
  <div class="row" style="display: flex; align-items: center; justify-content: space-between; margin: -10px 0 -8px;">
    <div class="col-4" style="display: flex; align-items: center;">
      <img src="${getCourierLogoPath(order.tagged_api)}" alt="${order.tagged_api}" style="max-height: 40px; max-width: 100%;">
    </div>
    <div class="col-6" style="display: flex; align-items: center; justify-content: flex-end;">
      ${isEnabled('show_brand_logo') && order.logo_path ? 
        `<img src="${getCompanyLogoPath(order.logo_path)}" alt="${order.company_name}" style="max-height: 40px; max-width: 100%;">` : 
        isEnabled('show_brand_name') && order.company_name ? `<div style="font-size: 14pt; font-weight: bold;">${order.company_name}</div>` : ''
      }
    </div>
  </div>

  <!-- Addresses -->
  <div class="row" style="margin-top: 20px;">
    <div class="col-6">
       <div class="section-title">From:</div>
      <div class="info-text">
        ${isEnabled('show_brand_name') && (order.warehouse_name || order.company_name) ? 
          (order.warehouse_name?.toUpperCase() || order.company_name?.toUpperCase()) : 
          'WAREHOUSE NAME'}<br>
        ${isEnabled('show_shipper_address') && order.warehouse_address ? 
          order.warehouse_address : 
          'WAREHOUSE ADDRESS'}<br>
        ${order.warehouse_city || 'CITY'}, ${order.warehouse_state || 'STATE'} ${order.warehouse_pincode || '000000'}<br>
        ${isEnabled('show_shipper_phone') && order.warehouse_phone ? `Phone: ${order.warehouse_phone}` : ''}
        ${isEnabled('show_gstin') && order.gstin ? `<br>GSTIN: ${order.gstin}` : ''}
      </div>
    </div>
    <div class="col-6">
      <div class="section-title">To:</div>
      <div>
        <strong>${order.first_name?.toUpperCase() || 'CONSIGNEE NAME'}</strong><br>
        ${order.address_line1?.toUpperCase() || 'CONSIGNEE ADDRESS'}<br>
        ${order.city?.toUpperCase() || 'CITY'}, ${order.state?.toUpperCase() || 'STATE'} ${order.pincode?.toUpperCase() || 'PINCODE'}<br>
        Phone: ${order.phone || 'PHONE'}
      </div>
    </div>
  </div>

  <!-- Tracking & Order Info -->
  <div class="row" style="margin-top: 20px;">
    <div class="col-4">
      <div class="section-title">AWB #:</div>
      <div><strong>${order.lr_no}</strong></div>
      ${isEnabled('show_order_id') && order.orderid ? `
        <div class="section-title" style="margin-top: 8px;">Order #:</div>
        <span>Purchase Order: ${order.orderid}</span><br>
        <span>Order No: ${order.orderid}</span>
      ` : ''}
      ${isEnabled('show_order_date') && order.order_date ? `
        <div class="section-title" style="margin-top: 8px;">Order Date:</div>
        <div>${new Date(order.order_date).toLocaleDateString()}</div>
      ` : ''}
      ${isEnabled('show_invoice_date') ? `
        <div class="section-title" style="margin-top: 8px;">Invoice Date:</div>
        <div>${new Date().toLocaleDateString()}</div>
      ` : ''}
    </div>
    <div class="col-4 qrcode text-center">
      <img 
        src="https://api.qrserver.com/v1/create-qr-code/?size=120x120&data=${order.lr_no}" 
        alt="QR Code"
      >
    </div>
    <div class="col-4">
      <div class="section-title">Shipping Method:</div>
      <div>${orderType.toUpperCase()} - Standard</div>
      ${isEnabled('show_invoice_number') && order.invoice_no ? `
        <div class="section-title" style="margin-top: 8px;">Invoice:</div>
        <div>${order.invoice_no}</div>
      ` : ''}
      <div class="section-title" style="margin-top: 8px;">Payment:</div>
      <div>${order.payment_mode || 'COD'}</div>
      ${isEnabled('show_declared_value') && (order.declared_value || order.collectable_amount) ? `
        <div class="section-title" style="margin-top: 8px;">Declared Value:</div>
        <div>â‚¹${order.declared_value || order.collectable_amount}</div>
      ` : ''}
    </div>
  </div>

  <!-- Weight Info -->
  <div class="row" style="margin-top: 15px;">
    <div class="col-4">
      <div class="section-title">Zones:</div>
      <div>Origin-Destination</div>
    </div>
    ${isEnabled('show_dead_weight') && order.total_weight ? `
      <div class="col-4">
        <div class="section-title">Weight:</div>
        <div>${order.total_weight}</div>
      </div>
    ` : ''}
    <div class="col-4">
      <div class="section-title">Chargeable:</div>
      <div>${order.chargable_weight}</div>
    </div>
  </div>

  <div class="divider"></div>

  <!-- Box & Product Details -->
  <div class="row" style="margin-top: 20px;">
    <div class="col-7">
      <!-- Box Details -->
      ${isEnabled('show_dimension') && order.allBoxes && order.allBoxes.length > 0 ? `
        <div class="section-title">Box Details:</div>
        <table>
          <thead>
            <tr>
              <th>Box</th>
              <th>Dimension</th>
              <th>Unit</th>
            </tr>
          </thead>
          <tbody>
            ${order.allBoxes.map((box, index) => `
              <tr>
                <td>${index + 1}</td>
                <td>${box.length || '1'}x${box.breadth || '1'}x${box.height || '1'}</td>
                <td>${box.dimension_unit || 'cm'}</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
        
        <div style="margin-top: 8px;">
          <span>Total Boxes: ${order.allBoxes.length}</span> | 
          <span>Weight: ${order.total_weight} ${order.weight_unit}</span>
        </div>
      ` : ''}

      <!-- Product Details -->
      ${(isEnabled('show_item_name') || isEnabled('show_product_quantity') || isEnabled('show_product_cost') || isEnabled('show_sku_code')) && order.allProducts && order.allProducts.length > 0 ? `
        <div class="section-title" style="margin-top: 20px;">Product Details:</div>
        <table>
          <thead>
            <tr>
              ${isEnabled('show_item_name') ? '<th>Product</th>' : ''}
              ${isEnabled('show_product_quantity') ? '<th>Qty</th>' : ''}
              ${isEnabled('show_product_cost') ? '<th>Amount</th>' : ''}
              ${isEnabled('show_sku_code') ? '<th>SKU</th>' : ''}
            </tr>
          </thead>
          <tbody>
            ${order.allProducts.map(product => `
              <tr>
                ${isEnabled('show_item_name') ? `<td>${limitItemName(product.name)}</td>` : ''}
                ${isEnabled('show_product_quantity') ? `<td>${product.qty || '1'}</td>` : ''}
                ${isEnabled('show_product_cost') ? `<td>${product.price || order.collectable_amount}</td>` : ''}
                ${isEnabled('show_sku_code') ? `<td>${product.sku || 'N/A'}</td>` : ''}
              </tr>
            `).join('')}
          </tbody>
        </table>
      ` : ''}
      
      <!-- Barcode -->
      ${isEnabled('show_order_barcode') ? `
        <div style="margin-top: 20px;">
          <div class="section-title">AWB Barcode:</div>
          <div class="text-center">
            <div style="width: 60%; height: 60px; background: #f0f0f0; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 12pt; margin: 0 auto; overflow: hidden;">
              <svg id="barcode-${order.lr_no}" style="width: 100%; height: 100%; max-width: 100%; max-height: 100%; overflow: hidden;"></svg>
              <script>
                JsBarcode("#barcode-${order.lr_no}", "${order.lr_no}", {
                  format: "CODE128",
                  height: 50,
                  width: 1.5,
                  displayValue: true,
                  fontSize: 10,
                  margin: 3
                });
              </script>
            </div>
            <div class="text-center">
              <span><strong>${order.lr_no}</strong></span>
            </div>
          </div>
        </div>
      ` : ''}
    </div>

    <!-- Declaration Section -->
    <div class="col-5">
      <div style="border: 1px solid #000; padding: 10px;">
        <div class="section-title">Declaration:</div>
        <div style="font-size: 9pt; line-height: 1.4;">
          I/We declare that this consignment does not contain personal mail, cash, jewellery,
          contraband, illegal drugs, any prohibited items and commodities which can cause safety
          hazards while transporting
        </div>
        
        <div class="section-title" style="margin-top: 15px;">Sender's Signature & Seal:</div>
        <div style="font-size: 9pt; line-height: 1.4;">
          I have read and understood terms & conditions of carriage mentioned on website.
        </div>
        
        <!-- Signature Space -->
        <div class="signature-space"></div>
        <div class="text-center" style="font-size: 9pt;">
          (Sign & Seal Here)
        </div>
      </div>
      
      <!-- Delivery Instructions -->
      <div style="margin-top: 20px;">
        <div class="section-title">Delivery Instructions:</div>
        <div style="font-size: 9pt; line-height: 1.3; min-height: 80px; border: 1px solid #eee; padding: 5px;">
          Standard delivery procedures apply.
        </div>
      </div>

      <!-- Other Charges -->
      ${isEnabled('show_other_charges') && (order.base_rate || order.total_additional || order.total_gst || order.total_lr_charges) ? `
        <div style="margin-top: 20px;">
          <div class="section-title">Other Charges:</div>
          <div style="font-size: 9pt; line-height: 1.3; border: 1px solid #eee; padding: 5px;">
            ${order.base_rate ? `<div>Base Rate: â‚¹${order.base_rate}</div>` : ''}
            ${order.total_additional ? `<div>Additional Charges: â‚¹${order.total_additional}</div>` : ''}
            ${order.total_gst ? `<div>GST: â‚¹${order.total_gst}</div>` : ''}
            ${order.total_lr_charges ? `<div><strong>Total: â‚¹${order.total_lr_charges}</strong></div>` : ''}
          </div>
        </div>
      ` : ''}
    </div>
  </div>

  <div class="divider"></div>

  <!-- Key Information -->
  <div style="margin-top: 20px;">
    <div class="row">
      <div class="col-12">
        <strong>Key Information:</strong>
        <span style="font-size: 9pt; text-transform: uppercase;">
          This Document is not a tax invoice. Weight captured will be used for invoice generation.
        </span>
      </div>
    </div>
  </div>

  <!-- Footer -->
  <div class="footer">
    <div class="row">
      <div class="col-6 text-center">
        <img src="${getDispatchLogoPath()}" alt="Dispatch" style="max-height: 30px; max-width: 120px;">
        <div>Powered by <strong>Dispatch Solutions</strong></div>
      </div>
      <div class="col-6 text-center">
        <div>support@dispatch.co.in | +91 9313 388 388</div>
        <div>www.dispatch.co.in</div>
      </div>
    </div>
  </div>

</div>

</body>
</html>`;
};

// The functions will be called from where they are needed with proper parameters
async function generateDelhiveryLtlBarcodeBase64(awbNumber) {
  try {
    const canvas = createCanvas(400, 100);
    JsBarcode(canvas, awbNumber, {
      format: "CODE128",
      displayValue: true,
      fontSize: 16,
      height: 70,
      margin: 10
    });

    return canvas.toDataURL('image/png').split(',')[1];
  } catch (error) {
    console.error('Error generating Delhivery LTL barcode:', error);
    // Return a fallback or default barcode if generation fails
    return null;
  }
}

async function generateBarcodeBase64(text) {
  try {
    const barcodeBuffer = await bwipjs.toBuffer({
      bcid: 'code128',
      text: text,
      scale: 2,
      height: 10,
      includetext: false,
      textxalign: 'center',
      backgroundcolor: 'FFFFFF'
    });

    return barcodeBuffer.toString('base64');
  } catch (err) {
    console.error('Error generating barcode:', err);
    throw err;
  }
}
// Function to get courier logo path
// function getCourierLogoPath(courier) {
//   console.log('Courier:', courier);

//   const logoDir = path.join(__dirname, '..', 'public', 'assets', 'images');
//   if (courier?.includes('expressbees')) {
//     return path.join(logoDir, '1741609022486.png');
//   } else if (courier?.includes('Delhivery')) {
//     return path.join(logoDir, '1741608240706.png');
//   } else if (courier?.includes('DTDC/LTL-surface')) {
//     return path.join(logoDir, 'dtdcnew.png');
//   }
//   else {
//     return path.join(logoDir, 'logo-white.jpg');
//   }
// }


const index = async (req, res) => {
  const { tenant, type } = req.query;
  const role_data = req.user;
  const clientId = req.user.selectedClientId; 
  let courierType;

  try {
    if (clientId === 1) {
      // default for superadmin
      courierType = "express";
    } else {
      // === Get segment_type from DB ===
      const [userData] = await mySqlQury(
        `
        SELECT k.segment_type
        FROM tbl_admin a
        JOIN kyc_submissions k ON a.id = k.user_id
        WHERE a.id = ?
        `,
        [clientId]
      );

      courierType =
        userData?.segment_type?.toLowerCase() === "ecom"
          ? "ecom"
          : "express";
    }

    // âœ… redirect to the appropriate route
    return res.redirect(`/${courierType}`);
  } catch (err) {
    console.error("Error in index:", err);
    return res.status(500).send("Internal Server Error");
  }
};


const orderSummary = async (req, res) => {
  try {
    const clientId = req.user.clientId || 0;
    const userId = req.user.id;
    const role = req.user.role;

    const [
      rtoTrend,
      // orderStatusChart,
      getOrderSummary,
      unprocessedCounts,
      monthlyOrderTrend,
      monthlyCreatedLRTrend,
      dispatchedCounts,
      inTransitCounts,
      deliveredCounts,
      cancelledCounts,
      rtoCounts,
      ndrCounts,
      agingUnprocessed,
      agingReadyToDispatch,
      agingInTransit,
      agingRTO,
      agingNDR
    ] = await Promise.all([

      dashboardService.getRTOTrend(clientId),
      // dashboardService.getOrderStatusChart(clientId),
      dashboardService.getOrderSummary(clientId),
      dashboardService.getUnprocessedCounts(clientId),
      dashboardService.getMonthlyOrderTrend(clientId),
      dashboardService.getMonthlyCreatedLRTrend(clientId),
      dashboardService.getStatusWiseCounts([1], clientId),        // dispatched
      dashboardService.getStatusWiseCounts([2, 3], clientId),     // in transit
      dashboardService.getStatusWiseCounts([4], clientId),        // delivered
      dashboardService.getStatusWiseCounts([0], clientId),        // cancelled
      dashboardService.getStatusWiseCounts([5, 7], clientId),     // RTO
      dashboardService.getStatusWiseCounts([6], clientId),        // NDR
      dashboardService.getAgingData('tbl_unprocessed_order', 'is_unprocessesd = 1', clientId),
      dashboardService.getAgingData('tbl_create_lr', 'status = 1', clientId),
      dashboardService.getAgingData('tbl_create_lr', 'status IN (2,3)', clientId),
      dashboardService.getAgingData('tbl_create_lr', 'status = 5', clientId),
      dashboardService.getAgingData('tbl_create_lr', 'status = 6', clientId)
    ]);
    const data = {
      rtoTrend,
      getOrderSummary,
      // orderStatusChart,
      unprocessedCounts,
      monthlyOrderTrend,
      monthlyCreatedLRTrend,
      dispatchedCounts,
      inTransitCounts,
      deliveredCounts,
      cancelledCounts,
      rtoCounts,
      ndrCounts,
      aging: {
        unprocessed: agingUnprocessed,
        dispatch: agingReadyToDispatch,
        inTransit: agingInTransit,
        rto: agingRTO,
        ndr: agingNDR
      }
    };
    res.json({ data });
  } catch (err) {
    console.error('Order Summary Fetch Error:', err);
    res.status(500).json({ error: 'Failed to fetch order summary' });
  }
}

const getOrdersRto = async (req, res) => {
  const { fromDate, toDate } = req.body;

  try {
    const query = `SELECT
      order_date as status_date,
  
      -- Total RTO count (status = 5 or 7)
      COALESCE(COUNT(DISTINCT CASE WHEN status IN (5, 7) THEN lr_No END), 0) AS count_value,
  
      -- In Transit count (status = 7)
      COALESCE(COUNT(DISTINCT CASE WHEN status = 7 THEN lr_No END), 0) AS in_Transit_value,
  
      -- Delivered count (status = 5)
      COALESCE(COUNT(DISTINCT CASE WHEN status = 5 THEN lr_No END), 0) AS delivered_value,
  
      -- Pending count (Total RTO - Delivered) â†’ (status IN (5,7)) - (status = 5)
      COALESCE(
          COUNT(DISTINCT CASE WHEN status IN (5, 7) THEN lr_No END) -
          COUNT(DISTINCT CASE WHEN status = 5 THEN lr_No END),
          0
      ) AS pending_value,
  
      -- Pending percentage
      COALESCE(
          ROUND(
              (COUNT(DISTINCT CASE WHEN status IN (5, 7) THEN lr_No END) -
              COUNT(DISTINCT CASE WHEN status = 5 THEN lr_No END)) * 100 /
              NULLIF(COUNT(DISTINCT CASE WHEN status IN (5, 7) THEN lr_No END), 0),
          0),
          0
      ) AS rto_pending_percentage,
  
      -- In Transit percentage
      COALESCE(
          ROUND(
              COUNT(DISTINCT CASE WHEN status = 7 THEN lr_No END) * 100 /    
              NULLIF(COUNT(DISTINCT CASE WHEN status IN (5, 7) THEN lr_No END), 0),
          0),
          0
      ) AS in_Transit_percentage,
  
      -- Delivered percentage
      COALESCE(
          ROUND(
              COUNT(DISTINCT CASE WHEN status = 5 THEN lr_No END) * 100 /
              NULLIF(COUNT(DISTINCT CASE WHEN status IN (5, 7) THEN lr_No END), 0),
          0),
          0
      ) AS delivered_percentage
  
  FROM tbl_create_lr
  WHERE
      order_date BETWEEN ? AND ?
  GROUP BY order_date;
  
  `
    const result = await mySqlQury(query, [fromDate, toDate]);
    // Format the data based on the correct column names
    const formattedData = result.map(row => ({
      date: row.status_date,
      totalRTO: row.count_value,
      inTransit: row.in_Transit_value,
      delivered: row.delivered_value,
      pending: row.pending_value,
      rtoPendingPercentage: row.rto_pending_percentage,
      inTransitPercentage: row.in_Transit_percentage,
      deliveredPercentage: row.delivered_percentage
    }));
    return res.json(formattedData);

  } catch (error) {
    console.error('Error fetching data:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
}
const getOrders = async (req, res) => {
  const { fromDate, toDate, clientID } = req.body;
  console.log("clientID in getOrders", clientID);

  try {

    // const clientCondition = clientID > 0 ? `AND client_id = ?` : '';
    const query = `SELECT
      DATE(uo.order_date) AS order_date,
      COUNT(DISTINCT uo.po_no) AS total_order_count,  
      COUNT(DISTINCT CASE WHEN uo.is_unprocessesd = 1 THEN uo.po_no END) AS unprocessed_order_count,
      COUNT(DISTINCT CASE WHEN lr.status = 0 THEN lr.po_id END) AS status_0_cancel_count,  
      COUNT(DISTINCT CASE WHEN lr.status = 1 THEN lr.po_id END) AS status_1_readyDispatch_count,  
      COUNT(DISTINCT CASE WHEN lr.status IN (2, 3) THEN lr.po_id END) AS status_3_inTransit_count,
      COUNT(DISTINCT CASE WHEN lr.status = 4 THEN lr.po_id END) AS status_4_delivered_count,
      COUNT(DISTINCT CASE WHEN lr.status IN (5,7) THEN lr.po_id END) AS status_5_rto_count,
     
      COUNT(DISTINCT CASE WHEN lr.status = 6 THEN lr.po_id END) AS status_6_ndr_count,
      (
          COUNT(DISTINCT CASE WHEN uo.is_unprocessesd = 1 THEN uo.po_no END) +
          COUNT(DISTINCT CASE WHEN lr.status IN (1, 2, 3) THEN lr.po_id END)
      ) AS total_unprocessed_and_pending_count,
      ROUND((COUNT(DISTINCT CASE WHEN lr.status = 4 THEN lr.po_id END) * 100.0) / NULLIF(COUNT(DISTINCT uo.po_no), 0), 2) AS delivery_percentage,
      ROUND((COUNT(DISTINCT CASE WHEN lr.status = 5 THEN lr.po_id END) * 100.0) / NULLIF(COUNT(DISTINCT uo.po_no), 0), 2) AS rto_percentage,
      ROUND(((COUNT(DISTINCT CASE WHEN uo.is_unprocessesd = 1 THEN uo.po_no END) +
              COUNT(DISTINCT CASE WHEN lr.status IN (1, 2, 3) THEN lr.po_id END))
             * 100.0) / NULLIF(COUNT(DISTINCT uo.po_no), 0), 2) AS pending_percentage
  FROM
      tbl_unprocessed_order uo
  LEFT JOIN
      tbl_create_lr lr ON uo.po_no = lr.po_id
  WHERE
      uo.order_date BETWEEN ? AND ?
       ${clientID > 0 ? "AND uo.client_id = ?" : ""}
  GROUP BY
      DATE(uo.order_date)
  ORDER BY
      DATE(uo.order_date) ASC;`

    const values = clientID > 0 ? [clientID] : [];

    const result = await mySqlQury(query, [fromDate, toDate, values]);
    const formattedData = result.map(row => ({
      date: row.order_date,
      totalOrders: row.total_order_count,
      unprocessed: row.unprocessed_order_count,
      readyToDispatch: row.status_1_readyDispatch_count,
      cancel: row.status_0_cancel_count,
      inTransit: row.status_3_inTransit_count,
      delivered: row.status_4_delivered_count,
      rto: row.status_5_rto_count,
      ndr: row.status_6_ndr_count,
      pending: row.total_unprocessed_and_pending_count,
      deliveredPercentage: row.delivery_percentage || 0,
      rtoPercentage: row.rto_percentage || 0,
      pendingPercentage: row.pending_percentage || 0
    }));

    return res.json(formattedData);

  } catch (error) {
    console.error('Error fetching data:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
}
const codReports = async (req, res, next) => {
  try {
    const role_data = req.user;
    const tenant = req.cookies.tenant; // âœ… now you get it from the frontend
    console.log("sdhdjsds", tenant)
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    let walletBalance = 0;
    let loginDetails = null;
    let clientId = 0;
    let vasService = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id, first_name,vas, company_name, logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }

      // Get wallet balance for the related client
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [role]
    );

    // Fetch profile data
    const [profile] = await mySqlQury(
      'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
      [req.user.id]
    );

    // Start Dashboard / Order Summary Tab
    // Start Dashboard / Order Summary Tab
    const ordersQuery = `SELECT
          COUNT(DISTINCT lr.po_id) AS po_no_count,  -- Count of unique PO IDs
          SUM(uo.amount) AS payment_cod_count          -- Total COD amount
        FROM tbl_create_lr lr
        LEFT JOIN tbl_unprocessed_order uo ON lr.po_id = uo.po_no
        LEFT JOIN tbl_admin nc ON uo.client_id = nc.id
        WHERE lr.status IN (0, 4, 5)
         ${clientId > 0 ? "AND lr.client_id = ?" : ""}
        AND lr.mode_of_payment = 'cod';`;
    const cod_client_order_wise = clientId > 0 ? [clientId] : [];
    const unprocessedOrder = await mySqlQury(ordersQuery, cod_client_order_wise);
    let unprocessedOrderCount = unprocessedOrder[0]?.po_no_count || 0;
    let codCountInUnprocessedOrder = unprocessedOrder[0]?.payment_cod_count || 0;

    const bankCOD = `SELECT SUM(Amt_Bank_Recv_Forwarder) as Amt_Bank_Recv_Forwarder FROM tbl_bank_remitence`;
    const remittedAmountForwarder = await mySqlQury(bankCOD);
    const Amt_Bank_Recv_Forwarder = remittedAmountForwarder[0]?.Amt_Bank_Recv_Forwarder || 0;

    const aggregatorCOD = `SELECT SUM(total_remittance_amount) as total_remittance_amount FROM tbl_agg_client_remittance`;
    const remittedAmountAggregator = await mySqlQury(aggregatorCOD);
    const Amt_Bank_Recv_Client = remittedAmountAggregator[0]?.total_remittance_amount || 0;

    const unremitted_amount_query = `SELECT
          SUM(discrepency_amount) + SUM(CASE WHEN amount_from_forwarder = 0 THEN remitted_amount ELSE 0 END) AS grand_total
        FROM tbl_cod_remitence;`;

    const unremitted_amount_forwarder = await mySqlQury(unremitted_amount_query);
    const unremitted_amount_forwarder_cod = unremitted_amount_forwarder[0]?.grand_total || 0;

    const codTable = `SELECT
        lr.order_date,
        COUNT(DISTINCT  lr.lr_No ) AS total_orders,
         Round(COALESCE(SUM(cs.cod_amount), 0)) as total_amount,
       
        COUNT(DISTINCT CASE WHEN cs.status IN (4) THEN cs.lr_no END) AS delivered_orders,
            ROUND(COALESCE(SUM(CASE WHEN cs.status IN (4) THEN cs.cod_amount END), 0)) AS cod_amount,
        COUNT(DISTINCT CASE WHEN cs.status IN (5, 7) THEN cs.lr_no END) AS rto_orders,
         COUNT(DISTINCT  acr.lr_no ) AS remitted_order_count,
         ROUND(COALESCE(SUM(acr.total_remittance_amount), 0)) AS remitted_amount,
          COUNT(DISTINCT brp.lr_awb ) AS to_be_remitted_order_count,
          ROUND(COALESCE(SUM(brp.remitted_amount), 0)) AS to_be_remitted_amount
         
       
    FROM tbl_create_lr lr
    left join tbl_cod_summary cs on  lr.lr_No = cs.lr_no
    left join tbl_agg_client_remittance acr on lr.lr_No = acr.lr_no
    left join tbl_bankrecovspoid brp on lr.lr_No = brp.lr_awb
    where
    lr.status IN ( 4, 5, 7)
    AND lr.mode_of_payment = 'COD'
      ${clientId > 0 ? "AND lr.client_id = ?" : ""}
    GROUP BY lr.order_date;
    `
    const cod_client_wise = clientId > 0 ? [clientId] : [];
    const cod_data = await mySqlQury(codTable, cod_client_wise)

    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id)); // Convert to numbers
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    // Render the EJS file with the active topics and order data
    res.render('pages/cod-reports', {
      title: 'cod-reports',
      bodyClass: 'profile-page',
      activePage: 'profile',
      activeTopicIds,
      role,
      loginDetails,
      Amt_Bank_Recv_Forwarder,
      unprocessedOrderCount,
      codCountInUnprocessedOrder,
      Amt_Bank_Recv_Client,
      unremitted_amount_forwarder_cod,
      role_data,
      profile, // Send profile data
      clientId, // Send clientId
      walletBalance,
      cod_data,
      vasService
    });
  } catch (error) {
    console.error("Error fetching active topics:", error);
    next(error);
  }
}
const downloadExcel = async (req, res) => {
  try {
    // const filePath = path.join(__dirname, "../files/sample.xlsx"); // Ek step upar jaane ke liye "../" use kiya
    const filePath = path.join(__dirname, "files", "sample.xlsx");

    // Check karo file exist karti hai ya nahi
    if (!fs.existsSync(filePath)) {
      return res.status(404).send("File not found!");
    }

    res.download(filePath, "report.xlsx", (err) => {
      if (err) {
        console.error("File download error:", err);
        res.status(500).send("Error downloading file");
      }
    });
  } catch (err) {
    throw err;
  }
}
const billingDateFilter = async (req, res) => {
  const { fromDate, toDate, status } = req.query;
  console.log("status in the ", status)
  if (!fromDate || !toDate) {
    return res.status(400).json({ error: 'fromDate and toDate are required' });
  }

  try {
    const query = `SELECT 
    cl.lr_No,
    MAX(cl.lr_id) AS lr_id,
    MAX(cl.order_date) AS order_date,
    MAX(cl.consignee_Name) AS consignee_Name,
    MAX(cl.po_id) AS po_id,
    MAX(cl.destination_Pincode) AS destination_Pincode,
    MAX(cl.destination_Add) AS destination_Add,
    MAX(cl.total_Box) AS total_Box,
    MAX(cl.status) AS status,
    MAX(uo.origin_city) AS origin_city,
    MAX(uo.origin_pincode) AS origin_pincode,
    MAX(ab.additional_charge) AS additional_charge,
    MAX(ab.total_rate) AS total_rate,
    MAX(laa.charge_name) AS charge_name
  FROM tbl_create_lr cl
  INNER JOIN tbl_aggrigator_bidding ab ON cl.lr_No = ab.lr_No
  INNER JOIN tbl_lr_agg_add laa ON cl.lr_No = laa.lr
  INNER JOIN tbl_unprocessed_order uo ON cl.po_id = uo.po_no
  WHERE cl.status != 0 
    AND DATE(cl.order_date) BETWEEN ? AND ?
    AND cl.status = ?
  GROUP BY cl.lr_No;
  `

    const values = [fromDate, toDate, status];

    const result = await mySqlQury(query, values);

    res.json(result);
  } catch (error) {
    console.error('Error fetching data:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
}
const orderStats = async (req, res) => {
  try {
    const query = `SELECT
      DATE_FORMAT(lr.order_date, '%Y-%m') AS month,
      COUNT(lr.po_id) AS total_orders,
      COALESCE(SUM(uo.amount), 0) AS total_amount,
      COUNT(CASE WHEN lr.status = 4 THEN 1 END) AS delivered_orders,
      COUNT(CASE WHEN lr.status = 5 THEN 1 END) AS rto_orders,
     
      COUNT(CASE WHEN acr.utr_number IS NOT NULL THEN 1 END) AS remitted_order_count,
      COALESCE(SUM(acr.remitted_cod), 0) AS remitted_amount,
  
      COUNT(CASE WHEN bpo.utr_number IS NULL THEN 1 END) AS to_be_remitted_order_count,
      COALESCE(SUM(bpo.remitted_amount), 0) AS to_be_remitted_amount  -- **Fixed the syntax error**
  
  FROM tbl_create_lr lr
  LEFT JOIN tbl_unprocessed_order uo ON lr.po_id = uo.po_no
  LEFT JOIN tbl_bankrecovspoid bpo ON lr.lr_no = bpo.lr_awb
  LEFT JOIN tbl_bank_remitence br ON bpo.utr_number = br.utr_number
  LEFT JOIN tbl_agg_client_remittance acr ON lr.lr_no = acr.lr_no
  WHERE lr.status IN (0, 4, 5)
  AND lr.mode_Of_Payment = 'cod'
  GROUP BY month
  ORDER BY month
  LIMIT 25;
  `
    const rows = await mySqlQury(query);

    // Check if rows are being returned correctly
    console.log(rows);

    res.json(rows || []);  // Always return an array, even if it's empty
  } catch (err) {
    console.error("Error fetching order stats:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}
const lagout = async (req, res) => {
  res.clearCookie("jwt")
  res.clearCookie("selection")

  res.render('pages/login', { title: 'Log In', layout: 'partials/layout-auth' })
}
const validatePincode = async (req, res) => {
  const { pincode } = req.body;

  try {
    // Check if the pincode exists in tbl_master_pincode
    const masterPincodeResult = await mySqlQury('SELECT state, city FROM tbl_master_pincode WHERE pincode = ?', [pincode]);

    // If no record is found, return valid: false
    if (masterPincodeResult.length === 0) {
      return res.json({ valid: false });
    }
    console.log("master pincode result", masterPincodeResult)

    // Extract state and city from the result
    const { state, city } = masterPincodeResult[0];

    // Respond with validation result and the details
    res.json({ valid: true, state, city });
  } catch (err) {
    console.error('Error querying database:', err);
    return res.status(500).json({ valid: false });
  }
}
const validatePincodeMaster = async (req, res) => {
  const { pickupPincode, destinationPincode } = req.body;
  console.log("destination:", destinationPincode)
  console.log("pickup:", pickupPincode)

  try {
    // Check if the pickup pincode exists in the master table
    const pickupPincodeResult = await mySqlQury('SELECT COUNT(*) AS count FROM tbl_master_pincode WHERE pincode = ?', [pickupPincode]);
    const isPickupValid = pickupPincodeResult[0].count > 0;

    // Check if the destination pincode exists in the master table
    const destinationPincodeResult = await mySqlQury('SELECT COUNT(*) AS count FROM tbl_master_pincode WHERE pincode = ?', [destinationPincode]);
    const isDestinationValid = destinationPincodeResult[0].count > 0;

    // Respond with the validation result
    res.json({ valid: isPickupValid && isDestinationValid });
  } catch (err) {
    console.error('Error querying database:', err);
    return res.status(500).json({ valid: false });
  }
}

// const createLr = async (req, res) => {
//   console.log("Received data:", req.body);
//   console.log("Received files:", req.files);
//   // console.log("first do one thing mention the client because in the client calculation u will face problem", kyuiyiyiyi)
//   console.log("in the create lr", req.body.clientId)
//   // console.log("dsjdhsjd",sgdsjdg)
//   // Extract form data
//   const {
//     forwardingPartner,

//     lrNo, // Added lrNo here
//     consigneeName,
//     insuranceType,
//     pickupPincode,
//     destinationPincode,
//     pickupAdd,
//     destinationAdd,
//     orderID,
//     PONO, // This should match with po_no in your tables
//     totalWeight,
//     totalBox,
//     modeOfPayment,
//     invoiceValue,
//     invoiceNo,
//     ewaybill,
//     shipperGst,
//     consigneeGst,
//     clientId
//   } = req.body;
//   // here data is creting lr 
//   const po_no = PONO;
//   console.log("invoice _value", invoiceValue, po_no, PONO)
//   // console.log("jhdjsdjsd",hduwdwudyuw)
//   let lrType = "manualLr"


//   // Prepare SQL query to insert data into tbl_create_lr
//   const insertSql = `
//       INSERT INTO tbl_create_lr (
//         order_id, po_id, lr_No, order_date, forwarding_Partner, lr_Type, consignee_Name,
//         insurance_Type, pickup_Pincode, destination_Pincode, pickup_Add, destination_Add,
//         total_Weight, total_Box, mode_Of_Payment, invoice_Value, invoice_No, eway_bill,
//         shipper_Gst, consignee_Gst,client_id
//       )
//       VALUES (?, ?, ?, NOW(), ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
//     `;

//   // Values to insert
//   const insertValues = [
//     orderID,
//     PONO,
//     lrNo, // Include lrNo here
//     forwardingPartner,
//     lrType,
//     consigneeName,
//     insuranceType,
//     pickupPincode,
//     destinationPincode,
//     pickupAdd,
//     destinationAdd,
//     totalWeight,
//     totalBox,
//     modeOfPayment,
//     invoiceValue,
//     invoiceNo,
//     ewaybill,
//     shipperGst,
//     consigneeGst,
//     clientId
//   ];
//   const insertFileSql = `
//       INSERT INTO tbl_files (lr_id, filename, filetype, filepath)
//       VALUES (?, ?, ?, ?)
//     `;

//   // Prepare SQL queries to update is_unprocessesd to 0
//   const updateUnprocessedOrderSql = `
//       UPDATE tbl_unprocessed_order
//       SET 	is_unprocessesd = 0
//       WHERE po_no = ?
//     `;

//   const updateBoxesDimensionSql = `
//       UPDATE tbl_boxes_dimension
//       SET 	is_unprocessesd = 0
//       WHERE po_no = ?
//     `;

//   try {
//     // Start transaction

//     await mySqlQury('START TRANSACTION');

//     // here start drama of saving lr 
//     let sql1 = 'SELECT * FROM tbl_unprocessed_order WHERE is_unprocessesd = 1';
//     let sql2 = 'SELECT * FROM tbl_boxes_dimension WHERE is_unprocessesd = 1';
//     const queryParams = [];

//     if (po_no) {
//       sql1 += ' AND po_no = ?';
//       sql2 += ' AND po_no = ?';
//       queryParams.push(PONO);
//     }

//     const [result1, result2] = await Promise.all([
//       mySqlQury(sql1, queryParams),
//       mySqlQury(sql2, queryParams)
//     ]);
//     //
//     console.log("result ", result1[0])


//     //  data from here to here
//     if (!Array.isArray(result1) || !Array.isArray(result2)) {
//       return res.status(404).json({ error: 'No data found' });
//     }






//     console.log("Order details:", result1);
//     console.log("rew id", req.user)
//     // let clientId;

//     console.log("tables client and ", tablesClient, client_id)

//     // Access the user ID directly from req.user
//     const userId = req.user.id; // Accessing the user ID directly

//     // Set client_id based on role or user id
//     if (userId == 1) {
//       console.log("in this 1")
//       // If user id is 1, use the client ID from the request body
//       clientId = tablesClient;
//     } else {
//       // If user id is not 1, use the user id
//       clientId = userId;
//       console.log("in this not one")// Use the user ID directly
//     }
//     // console.log("")

//     // if (req.user.id === 1) {
//     //   clientId = req.body.clientId;
//     // } else {
//     //   clientId = req.user.id;
//     // }

//     // console.log("jjdfjf",sdejde)



//     // // Update is_unprocessesd in both tables
//     await mySqlQury(updateUnprocessedOrderSql, [PONO]);
//     await mySqlQury(updateBoxesDimensionSql, [PONO]);

//     // Commit transaction
//     await mySqlQury('COMMIT');

//     res.status(200).json({ message: 'LR/Docket created and unprocessed status updated successfully' });
//   } catch (error) {
//     console.log("Error in create_lr:", error);

//     // Rollback transaction in case of error
//     await mySqlQury('ROLLBACK');

//     res.status(500).json({ message: 'Error creating LR/Docket or updating unprocessed status' });
//   }
// }
// const createLrApi = async (req, res) => {
//   await mySqlQury('START TRANSACTION');
//   try {
//     // Log received data and files
//     // console.log("Received data in create lr data manual allocation:", req.body);
//     // console.log("check doing error",uhuwhu)

//     console.log("Received files:", req.files);
//     const AggrigatorId = req.body.Id


//     // Destructuring the data from req.body
//     const {

//       lrNo,
//       consigneeName,
//       insuranceType,
//       pickupPincode,
//       destinationPincode,
//       pickupAdd,
//       destinationAdd,
//       orderID,
//       PONO,
//       totalWeight,
//       totalBox,
//       modeOfPayment,
//       invoiceValue,
//       invoiceNo,
//       ewaybill,
//       shipperGst,
//       consigneeGst,
//       TaggedApi,
//       nameAggrigator,
//       serviceType,
//       Category,
//       agg_defination,
//       total_rate,
//       tat,
//       originZone,
//       destinationZone,
//       boxDimensions,
//       chargableTotalWeight,
//       additionalCharges,
//       clientId,
//       forwarderRateAndTat,
//       aggrigatorBaserate,
//       aggrigatorAdditionalCharges,
//       cGst,
//       sGst,
//       iGst,
//       oda_Charge,
//       ClientAdditionalCharges,
//       category,
//       weight_unit,
//       CodAmount,
//       ltlChildLr,
//       docWaybills,
//       masterWaybills
//     } = req.body;
//     console.log("ltlChildLr", ltlChildLr)
//     console.log("docWaybills", docWaybills)
//     console.log("masterWaybills", masterWaybills)
//     console.log("category CATEGORY", Category)
//     console.log("category small", category)

//     // console.log("dsjhdjadgfjdsf",djdustduwstduy)
//     const aggrigatorTotaladditional = ClientAdditionalCharges;
//     console.log("aggrigatorTotaladditional", aggrigatorTotaladditional)
//     console.log("aggrigatorAdditionalCharges", aggrigatorAdditionalCharges);
//     console.log("cgst,sgst,igst", cGst, sGst, iGst)

//     const Agg_defination = agg_defination.replace(/['"]/g, '');
//     const lrType = "automaticLR";

//     // Fetch the volumetric factor for the given aggregatorId
//     const boxDimension = JSON.parse(boxDimensions);
//     const volumetricFactorResult = await mySqlQury(`
//         SELECT volumetric_factor, minimum_chargable_weight 
//         FROM tbl_customers 
//         WHERE Aggrigator_id = ?
//       `, [AggrigatorId]);

//     if (!volumetricFactorResult.length) {
//       throw new Error(`No volumetric factor found for aggregator_id: ${AggrigatorId}`);
//     }

//     const volumetricFactor = Number(volumetricFactorResult[0].volumetric_factor);
//     if (isNaN(volumetricFactor)) {
//       throw new Error(`Invalid volumetric factor retrieved: ${volumetricFactor}`);
//     }
//     const taggedApi = `${TaggedApi}/${Category}`;

//     // Use the external function to calculate total volumetric weight
//     const totalVolumetricWeight = await computeVolumetricWeight(boxDimension, volumetricFactor);

//     // SQL query to insert data into tbl_create_lr
//     const insertSql = `
//         INSERT INTO tbl_create_lr (
//           order_id, po_id, lr_No, order_date, Tagged_api, lr_Type, consignee_Name,
//           insurance_Type, pickup_Pincode, destination_Pincode, pickup_Add, destination_Add,
//           total_Weight, total_Box, mode_Of_Payment, invoice_Value, invoice_No, eway_bill,
//           shipper_Gst, consignee_Gst,aggrigator_id,volumetric_weight,chargable_weight,eta,client_id,weight_unit
//         )
//         VALUES (?, ?, ?, NOW(), ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?,?,?,?,?)
//       `;

//     // Values to insert
//     const insertValues = [
//       orderID,
//       PONO,
//       lrNo, // Include lrNo here
//       taggedApi,
//       lrType,
//       consigneeName,
//       insuranceType,
//       pickupPincode,
//       destinationPincode,
//       pickupAdd,
//       destinationAdd,
//       totalWeight,
//       totalBox,
//       modeOfPayment,
//       CodAmount,
//       invoiceNo,
//       ewaybill,
//       shipperGst,
//       consigneeGst,
//       AggrigatorId,
//       totalVolumetricWeight,
//       chargableTotalWeight,
//       tat,
//       clientId,
//       weight_unit

//     ];
//     // Convert ltlChildLr string to array if it's not already an array
//     let ltlChildLrArray = [];

//     if (typeof ltlChildLr === 'string') {
//       ltlChildLrArray = ltlChildLr.split(',').map(item => item.trim());
//     } else if (Array.isArray(ltlChildLr)) {
//       ltlChildLrArray = ltlChildLr;
//     }

//     if (ltlChildLrArray.length > 0) {
//       let insertCount = 0;

//       for (let i = 1; i < ltlChildLrArray.length; i++) {
//         const insertLtlChildSql = `
//         INSERT INTO child_lr_data (
//           ltlChildLr, docWaybills, masterWaybills, lrNo, created_at
//         )
//         VALUES (?, ?, ?, ?, NOW())
//       `;

//         const ltlChildValues = [
//           ltlChildLrArray[i],
//           docWaybills ? docWaybills : null,
//           masterWaybills ? masterWaybills : null,
//           lrNo
//         ];

//         await mySqlQury(insertLtlChildSql, ltlChildValues);
//         insertCount++;
//       }

//       console.log(`Inserted ${insertCount} rows into tbl_ltl_child_lr`);
//     }



//     // Log the values being inserted for debugging
//     console.log("Inserting into tbl_create_lr with values:", insertValues);

//     // Execute the insert query for tbl_create_lr
//     const result = await mySqlQury(insertSql, insertValues);
//     const lr_id = result.insertId; // Get the inserted lr_id from the result

//     // Log the inserted lr_id
//     console.log("Inserted lr_id into tbl_create_lr:", lr_id);

//     // Parse additionalCharges if it's a JSON string
//     let originalAdditionalCharges = typeof aggrigatorAdditionalCharges === 'string' ? JSON.parse(aggrigatorAdditionalCharges) : aggrigatorAdditionalCharges;

//     // Check if additionalCharges is defined and has a breakdown
//     if (originalAdditionalCharges?.breakdown?.length) {
//       const insertAdditionalChargesSql = `
//           INSERT INTO tbl_lr_agg_add (charge_name, charge_value, lr, agg_id,client_id)
//           VALUES (?, ?, ?, ?,?)
//         `;
//       for (const { charge_name, value } of originalAdditionalCharges.breakdown) {
//         if (charge_name && value !== undefined) {
//           await mySqlQury(insertAdditionalChargesSql, [charge_name, value, lrNo, AggrigatorId, clientId]);
//           console.log("Inserted additional charge from client in aggrigator:", charge_name, value);
//         } else {
//           console.error("Invalid charge data from client:", { charge_name, value });
//         }
//       }
//     } else {
//       console.warn("No additional charges from client to insert or breakdown is empty.");
//     }
//     // Create array to store non-zero charges
//     const charges = [];
//     const values = [];

//     if (cGst > 0) {
//       charges.push('(?, ?, ?, ?, ?)');
//       values.push('cgst', cGst, lrNo, AggrigatorId, clientId);
//     }

//     if (sGst > 0) {
//       charges.push('(?, ?, ?, ?, ?)');
//       values.push('sgst', sGst, lrNo, AggrigatorId, clientId);
//     }

//     if (iGst > 0) {
//       charges.push('(?, ?, ?, ?, ?)');
//       values.push('igst', iGst, lrNo, AggrigatorId, clientId);
//     }
//     if (oda_Charge > 0) {
//       charges.push('(?,?,?,?,?)');
//       values.push('oda_charge', oda_Charge, lrNo, AggrigatorId, clientId);
//     }

//     if (charges.length > 0) {
//       const insertChargesSql = `
//          INSERT INTO tbl_lr_agg_add (charge_name, charge_value, lr, agg_id, client_id)
//          VALUES ${charges.join(', ')}
//        `;
//       await mySqlQury(insertChargesSql, values);
//     }
//     console.log("Inserted CGST and SGST charges:", { cGst, sGst, iGst });
//     const totalGST = cGst + sGst + iGst;

//     console.log("aggrigatorTotaladditional", aggrigatorTotaladditional);
//     // Insert into tbl_aggrigator_bidding
//     const insertBiddingSql = `
//         INSERT INTO tbl_aggrigator_bidding (
//           tagged_api,  service_type, category,
//           aggrigator_id, agg_defination, tat,
//           origin_zone, destination_zone, volumetric_factor,base_rate,total_rate,additional_charge,lr_No,total_gst,name_aggrigator
//         )
//         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?,?,?)
//       `;

//     const insertBiddingValues = [
//       TaggedApi,

//       serviceType,
//       Category,
//       AggrigatorId,
//       Agg_defination,

//       tat,
//       originZone,
//       destinationZone,
//       totalVolumetricWeight || 0, // Ensure totalVolumetricWeight is defined
//       aggrigatorBaserate,
//       total_rate,
//       aggrigatorTotaladditional,
//       lrNo,
//       totalGST,
//       nameAggrigator

//     ];

//     if (forwarderRateAndTat) {
//       try {
//         const forwarderData = JSON.parse(forwarderRateAndTat);
//         console.log("Parsed forwarder details:", forwarderData);

//         const { forwarderId, baserate: baseRate, Totalrate: totalRate, tat } = forwarderData;
//         const cgst = totalRate * 0.09; // Calculate 9% CGST
//         const sgst = totalRate * 0.09; // Calculate 9% SGST
//         const totalGST = cgst + sgst; // Total GST
//         const updatedTotalRate = totalRate + totalGST; // Update total rate to include GST
//         const additionalRate = totalRate - baseRate; // Calculate additional rate

//         // Insert into tbl_bidding_orders
//         const insertBiddingOrdersSql = `
//             INSERT INTO tbl_bidding_orders (
//               order_no, 
//               po_no, 
//               client_id, 
//               forwarder_id, 
             
//               days, 
//               allocated_amount, 
//               chosen_forwarder_id, 
//               client_lr_selection_criteria, 
//               client_rate, 
//               volumetric_weight, 
//               client_volumetric_weight, 
//               lr_id,
//               base_rate,
//               total_rate,
//               additional_rate,
//               total_gst,
//                bid_amount  -- Add this field
//             )
//             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)
//           `;

//         const insertBiddingOrdersValues = [
//           orderID,
//           PONO,
//           clientId,
//           forwarderId,
//           tat,
//           updatedTotalRate, // Use updated total rate that includes GST
//           forwarderId,
//           "cheapest",
//           tat,
//           0,
//           totalVolumetricWeight,
//           lrNo, // Changed from lrNo to lr_id to match the context
//           baseRate,
//           totalRate,
//           additionalRate,
//           totalGST,
//           totalRate
//         ];

//         await mySqlQury(insertBiddingOrdersSql, insertBiddingOrdersValues);
//         const additionalChargesSql = `
//             INSERT INTO tbl_lr_for_add (charge_name, charge_value, lr, for_id)
//             VALUES (?, ?, ?, ?)
//           `;

//         // Insert CGST and SGST charges
//         await mySqlQury(additionalChargesSql, ['cgst', cgst, lrNo, forwarderId]);
//         await mySqlQury(additionalChargesSql, ['sgst', sgst, lrNo, forwarderId]);

//         // Insert additional charges into tbl_lr_for_add
//         if (forwarderData.additionalCharges?.breakdown) {
//           const insertAdditionalChargesSql = `
//               INSERT INTO tbl_lr_for_add (charge_name, charge_value, lr, for_id)
//               VALUES (?, ?, ?, ?)
//             `;
//           for (const { charge_name, value } of forwarderData.additionalCharges.breakdown) {
//             // Skip oda_charge if forwarderOda is 0 or not present
//             if (charge_name === 'oda_charge' && (!forwarderData.forwarderOda || forwarderData.forwarderOda === 0)) {
//               continue;
//             }

//             if (charge_name && value !== undefined) {
//               await mySqlQury(insertAdditionalChargesSql, [charge_name, value, lrNo, forwarderId]);
//               console.log("Inserted additional charge from client:", charge_name, value);
//             } else {
//               console.error("Invalid charge data from client:", { charge_name, value });
//             }
//           }
//           console.log("Additional charges inserted into tbl_lr_for_add:", forwarderData.additionalCharges.breakdown);
//         }
//       } catch (error) {
//         console.error("Error parsing forwarderRateAndTat or inserting into tbl_bidding_orders:", error);
//         throw error;
//       }
//     }

//     // Log the values being inserted for bidding
//     console.log("Inserting into tbl_aggrigator_bidding with values:", insertBiddingValues);
//     await mySqlQury(insertBiddingSql, insertBiddingValues);

//     // SQL queries to update is_unprocessesd status to 0
//     await mySqlQury(`
//         UPDATE tbl_unprocessed_order
//         SET is_unprocessesd = 0
//         WHERE po_no = ?
//       `, [PONO]);

//     await mySqlQury(`
//         UPDATE tbl_boxes_dimension
//         SET is_unprocessesd = 0
//         WHERE po_no = ?
//       `, [PONO]);

//     await mySqlQury('COMMIT');

//     // Send success response
//     res.status(200).json({ message: 'LR created successfully and files uploaded.' });

//   } catch (error) {
//     await mySqlQury('ROLLBACK');
//     console.error("Error:", error);
//     res.status(500).json({ message: 'An error occurred while creating the LR.' });
//   }
// }
const saveBulkLrAutomatic = async (req, res) => {
  const lrData = req.body.lrData; // Data sent from the frontend
  console.log("Received LR data:", lrData);
  console.log("clientID", req.body.clientID)
  const clientid = req.body.clientID;
  const paymentMode = req.body.clientPaymentSystem;
  console.log("payment mode ", paymentMode)
  const ListOfPo = [];

  await mySqlQury('START TRANSACTION'); // Start MySQL transaction to ensure data integrity

  try {
    // Filter out entries with empty lr_number before processing
    const validLrData = lrData.filter(lr => lr.lr_number && lr.lr_number.trim() !== '');

    for (const lr of validLrData) {
      const { orderData, lr_number } = lr;
      console.log("lr", lr);
      console.log("orderData in the save bulk lr automatic", orderData);
      console.log("lr number", lr_number);
      //  console.log("dhjkdhshsd",dsihdisydui)
      ListOfPo.push(orderData.po_no);






      console.log("orderData in the save bulk lr automatic", orderData.additionalCharges);
      console.log("orderData in the save bulk lr automatic", orderData.forwarderTotalRateAndDetails);
      console.log("forwarder calculation", orderData.forwarderTotalRateAndDetails.additionalCharges);
      const TaggedApi = `${orderData.TaggedApi}/${orderData.category}`;

      // Insert into tbl_create_lr
      // Only proceed with insertion if lr_number has a value

      const insertLrSql = `
              INSERT INTO tbl_create_lr (
                  order_id, po_id, lr_No, order_date, Tagged_api, lr_Type, consignee_Name,
              insurance_Type, pickup_Pincode, destination_Pincode, pickup_Add, destination_Add,
              total_Weight, total_Box, mode_Of_Payment, invoice_Value, invoice_No, eway_bill,
              shipper_Gst, consignee_Gst, aggrigator_id, chargable_weight, eta, client_id,weight_unit
            )
            VALUES (?, ?, ?, NOW(), ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)
          `;

      const lrValues = [
        orderData.po_no, // order_id
        orderData.po_no, // po_id  
        lr_number, // lr_No
        TaggedApi, // Tagged_api
        'automaticLR', // lr_Type
        orderData.consignee_name || '', // consignee_Name
        orderData.insurance_type || '', // insurance_Type
        orderData.origin_pincode || '', // pickup_Pincode
        orderData.destination_pincode || '', // destination_Pincode
        orderData.warehouse_address || '', // pickup_Add
        orderData.consignee_address || '', // destination_Add
        orderData.total_weight || 0, // total_Weight
        orderData.total_boxes || 1, // total_Box
        orderData.payment_type || 'prepaid', // mode_Of_Payment
        orderData.Invoice_amount || 0, // invoice_Value
        orderData.invoice_no || '', // invoice_No
        orderData.eway_bill || '', // eway_bill
        orderData.shipper_gst || '', // shipper_Gst
        orderData.consignee_gst || '', // consignee_Gst
        orderData.Aggrigator_id, // aggrigator_id
        orderData.chargableWeight, // chargable_weight
        orderData.days || null, // eta
        clientid, // client_id
        orderData.weight_unit || null,
      ];

      await mySqlQury(insertLrSql, lrValues);

      const cgst = orderData.rate * 0.09;
      const sgst = orderData.rate * 0.09;

      const totalGST = cgst + sgst;
      const totalRate = orderData.rate + totalGST;
      const originZone = orderData.zones.origin;
      const destinationZone = orderData.zones.destination;
      console.log("orizin and destination zone", originZone, destinationZone)

      // console.log("dskdskdjksfd",sdjdsdhs)

      // Update wallet and record transaction only for non-postpaid payments
      if (paymentMode !== 'postpaid') {
        await updateWalletAndTransaction(
          clientid,
          totalRate,
          orderData.po_no,
          lr_number,
          originZone,
          destinationZone,
          TaggedApi,
          orderData.total_weight,
          orderData.weight_unit
        );
      }

      const totalAdditionalCharge = totalRate - orderData.baserate;
      console.log("all details here console", orderData.baserate, totalRate, totalGST, totalAdditionalCharge)
      // console.log("dhsdhsdhs",jhjhjhjdhjs)
      // Insert into tbl_aggrigator_bidding
      const insertBiddingSql = `
          INSERT INTO tbl_aggrigator_bidding (
            tagged_api, service_type, category,
            aggrigator_id, tat,
            base_rate, total_rate, lr_No,
            total_gst,additional_charge,origin_zone,destination_zone
          )
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?)
        `;

      const biddingValues = [
        orderData.TaggedApi,
        orderData.service_type,
        orderData.category,
        orderData.Aggrigator_id,

        orderData.days,
        orderData.baserate,
        totalRate,
        lr_number,
        totalGST,
        totalAdditionalCharge,
        originZone,
        destinationZone
      ];

      await mySqlQury(insertBiddingSql, biddingValues);
      const sgstForwarder = orderData.forwarderTotalRateAndDetails.Totalrate * 0.09;
      const cgstForwarder = orderData.forwarderTotalRateAndDetails.Totalrate * 0.09;

      const forwarderTotalGST = cgstForwarder + sgstForwarder
      const forwarderTotalRate = Number(orderData.forwarderTotalRateAndDetails.Totalrate) + Number(forwarderTotalGST);
      const forwarderAdditionalCharge = forwarderTotalRate - Number(orderData.forwarderTotalRateAndDetails.baserate);

      // Insert into tbl_bidding_orders
      const insertBiddingOrdersSql = `
          INSERT INTO tbl_bidding_orders (
            order_no, po_no, client_id, forwarder_id, 
            days, allocated_amount, chosen_forwarder_id, 
            client_lr_selection_criteria, client_rate, 
            volumetric_weight, client_volumetric_weight, 
            lr_id, base_rate, total_rate, additional_rate, total_gst
          )
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `;

      const insertBiddingOrdersValues = [
        orderData.po_no, // order_no
        orderData.po_no, // po_no
        clientid, // client_id
        orderData.forwarderTotalRateAndDetails.forwarderId || null, // forwarder_id
        orderData.forwarderTotalRateAndDetails.tat, // days
        forwarderTotalRate, // allocated_amount
        orderData.forwarderTotalRateAndDetails.forwarderId || null, // chosen_forwarder_id
        "cheapest", // client_lr_selection_criteria
        orderData.forwarderTotalRateAndDetails.Totalrate, // client_rate
        0, // volumetric_weight
        0, // client_volumetric_weight
        lr_number, // lr_id
        orderData.forwarderTotalRateAndDetails.baserate, // base_rate
        forwarderTotalRate, // total_rate
        forwarderAdditionalCharge, // additional_rate
        forwarderTotalGST // total_gst (assuming 18% GST)
      ];

      await mySqlQury(insertBiddingOrdersSql, insertBiddingOrdersValues);

      // Insert into tbl_lr_for_add if total is not zero
      if (orderData.forwarderTotalRateAndDetails.total !== 0 &&
        orderData.forwarderTotalRateAndDetails.breakdown &&
        Array.isArray(orderData.forwarderTotalRateAndDetails.breakdown)) {
        const additionalChargesSql = `
            INSERT INTO tbl_lr_for_add (charge_name, charge_value, lr, for_id,client_id)
            VALUES (?, ?, ?, ?,?)
          `;

        for (const charge of orderData.forwarderTotalRateAndDetails.breakdown) {
          // Skip oda_charge if forwarderOda is 0 or not present
          if (charge.charge_name === 'oda_charge' &&
            (orderData.forwarderTotalRateAndDetails?.forwarderOda === 0 ||
              !orderData.forwarderTotalRateAndDetails?.forwarderOda)) {
            continue;
          }

          // Calculate charge value, applying oda factor if applicable
          const chargeValue = charge.charge_name === 'oda_charge'
            ? charge.value * (orderData.forwarderTotalRateAndDetails?.forwarderOda || 1)
            : charge.value;

          await mySqlQury(additionalChargesSql, [
            charge.charge_name,
            chargeValue,
            lr_number,
            orderData.forwarderTotalRateAndDetails.forwarderId,
            clientid
          ]);
        }
      } else if (orderData.forwarderTotalRateAndDetails.total !== 0 &&
        orderData.forwarderTotalRateAndDetails.breakdown) {
        console.log("forwarder calculation", orderData.forwarderTotalRateAndDetails);
      }
      await mySqlQury(`INSERT INTO tbl_lr_for_add (charge_name, charge_value, lr, for_id,client_id) VALUES (?, ?, ?, ?,?)`,
        ['sgst', sgstForwarder, lr_number, orderData.forwarderTotalRateAndDetails.forwarderId, clientid]);
      await mySqlQury(`INSERT INTO tbl_lr_for_add (charge_name, charge_value, lr, for_id,client_id) VALUES (?, ?, ?, ?,?)`,
        ['cgst', cgstForwarder, lr_number, orderData.forwarderTotalRateAndDetails.forwarderId, clientid]);

      // Update unprocessed order status
      await mySqlQury(`
          UPDATE tbl_unprocessed_order 
          SET is_unprocessesd = 0
          WHERE po_no = ?
        `, [orderData.po_no]);

      // Update boxes dimension status  
      await mySqlQury(`
          UPDATE tbl_boxes_dimension
          SET is_unprocessesd = 0
          WHERE po_no = ?
        `, [orderData.po_no]);
      const insertLrAggAddSql = `INSERT INTO tbl_lr_agg_add (charge_name, charge_value, lr, agg_id,client_id) VALUES (?, ?, ?, ?,?)`;
      await mySqlQury(insertLrAggAddSql, ['CGST', cgst, lr_number, orderData.Aggrigator_id, clientid]);
      await mySqlQury(insertLrAggAddSql, ['SGST', sgst, lr_number, orderData.Aggrigator_id, clientid]);

      // Insert additional charges if present
      if (orderData.additionalCharges?.breakdown) {
        const insertChargesSql = `
            INSERT INTO tbl_lr_agg_add (charge_name, charge_value, lr, agg_id,client_id)
            VALUES (?, ?, ?, ?,?)
          `;

        for (const charge of orderData.additionalCharges.breakdown) {
          // Skip oda_charge if aggrigatorOdaFactor is 0
          if (charge.charge_name === 'oda_charge' && orderData?.aggrigatorOdaFactor === 0) {
            continue;
          }

          // Calculate charge value, applying oda factor if applicable
          const chargeValue = charge.charge_name === 'oda_charge'
            ? charge.value * (orderData?.aggrigatorOdaFactor || 1)
            : charge.value;

          await mySqlQury(insertChargesSql, [
            charge.charge_name,
            chargeValue,
            lr_number,
            orderData.Aggrigator_id,
            clientid
          ]);
        }
      }
    }


    await mySqlQury('COMMIT');
    res.status(200).json({ message: "LR numbers and associated data saved successfully.", ListOfPo });

  } catch (error) {
    await mySqlQury('ROLLBACK');
    console.error("Error inserting LR data:", error);
    res.status(500).json({ message: "An error occurred while saving LR numbers." });
  }
}
const createBulkLrManual = async (req, res) => {
  const lrData = req.body.lrData;
  // Data sent from the frontend
  console.log("shabbar ansari in the manual lr data:", lrData);
  // console.log("shabbar ansari in automatic manual lr",dsdsdsd)

  if (!Array.isArray(lrData) || lrData.length === 0) {
    return res.status(400).json({ message: "Invalid LR data." });
  }

  console.log("lr data", lrData);  // L
  await mySqlQury('START TRANSACTION'); // Start MySQL transaction to ensure data integrity

  try {


    const insertBiddingSql = `
            INSERT INTO tbl_aggrigator_bidding (
              tagged_api, name_aggrigator, service_type, category,
              aggrigator_id, agg_defination, total_rate, tat,
              volumetric_factor
            )
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `;
    const updateUnprocessedOrderSql = `
        UPDATE tbl_unprocessed_order
        SET is_unprocessesd = 0
        WHERE po_no = ?
      `;

    const updateBoxesDimensionSql = `
        UPDATE tbl_boxes_dimension
        SET is_unprocessesd = 0
        WHERE po_no = ?
      `;
    const insertSql = `
      INSERT INTO tbl_create_lr (
          order_id,po_id, lr_No, order_date, Tagged_api, lr_Type, consignee_Name,
          insurance_Type, pickup_Pincode, destination_Pincode, pickup_Add,
          destination_Add, total_Weight, total_Box, mode_Of_Payment, invoice_Value,
          invoice_No, eway_bill, shipper_Gst, consignee_Gst, aggrigator_id, volumetric_weight, 
          chargable_weight
      )
      VALUES (?, ?, ?,NOW(), ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?)
  `;
    const updateManualLRStatusSql = `
        UPDATE tbl_manuallrs
        SET status = 0, product_type = ?
        WHERE Lr_Awb_no = ? AND aggrigator_id = ? AND lr_forwarder = ? AND Client_id = ?
      `;

    // Loop through lrData array to insert each LR entry
    for (let i = 0; i < lrData.length; i++) {
      const data = lrData[i];

      const boxDimensions = data.boxDimensions;  // Access the boxDimensions array for each entry



      const values = [
        data.orderID,
        data.po_no,             // po_id
        data.lrNo,              // lr_No
        data.TaggedApi,         // Tagged_api
        'manualLR',          // lr_Type
        data.consigneeName,     // consignee_Name
        null,                   // insurance_Type
        data.pickupPincode,     // pickup_Pincode
        data.destinationPincode,// destination_Pincode
        data.pickupAdd,         // pickup_Add
        data.destinationAdd,    // destination_Add
        data.totalWeight,       // total_Weight
        data.totalBox,          // total_Box
        data.modeOfPayment,     // mode_Of_Payment
        data.invoiceValue,      // invoice_Value
        data.invoiceNo,         // invoice_No
        null,                   // eway_bill
        null,                   // shipper_Gst
        null,                   // consignee_Gst
        data.AggrigatorId,      // aggrigator_id
        data.totalVolumetricWeight,  // volumetric_weight
        data.chargeableWeight // chargable_weight
      ];



      await mySqlQury(insertSql, values);  // Insert each entry into the tbl_create_lr table

      // Insert bidding data into tbl_aggrigator_bidding
      const insertBiddingValues = [
        data.TaggedApi,  // Tagged_api
        data.AggrigatorName,  // Replace with actual aggregator name
        data.servise,  // Modify as per the data available
        data.category,  // Modify as per the data available
        data.AggrigatorId,   // Aggrigator ID
        'agg_defination_example',  // Modify based on actual data
        data.aggregatorTotalRate,  // total_rate
        data.aggregatorTat,   // tat
        data.totalVolumetricWeight  // volumetric_factor
      ];

      await mySqlQury(insertBiddingSql, insertBiddingValues);  // Insert into tbl_aggrigator_bidding table

      // Update the unprocessed order and boxes dimension tables
      await mySqlQury(updateUnprocessedOrderSql, [data.po_no]);
      await mySqlQury(updateBoxesDimensionSql, [data.po_no]);
      await mySqlQury(updateManualLRStatusSql, [
        data.category, // Maps to product_type
        data.lrNo,
        data.AggrigatorId,
        data.TaggedApi,
        data.clientID,
      ]);
    }

    await mySqlQury('COMMIT');  // Commit the transaction if all inserts and updates are successful
    res.status(200).json({ message: "LR numbers and associated data saved successfully." });

  } catch (error) {
    await mySqlQury('ROLLBACK'); // Rollback the transaction in case of an error
    console.error("Error inserting LR data:", error);
    res.status(500).json({ message: "An error occurred while saving LR numbers." });
  }
}
const fetchVloumetricData = async (req, res) => {
  const { aggid, poNo } = req.query; // Get aggid and poNo from query parameters
  console.log("in the fetch aggrigator volumetruices", aggid, poNo);

  try {
    // Step 1: Fetch the volumetric factor from the database based on aggid
    const volumetricFactorQuery = `
          SELECT volumetric_factor, minimum_chargable_weight 
          FROM tbl_customers 
          WHERE Aggrigator_id = ?
        `;
    const volumetricFactorResult = await mySqlQury(volumetricFactorQuery, [aggid]);

    if (volumetricFactorResult.length === 0) {
      throw new Error(`No volumetric factor found for aggregator_id: ${aggid}`);
    }

    const volumetricFactor = Number(volumetricFactorResult[0].volumetric_factor);
    if (isNaN(volumetricFactor)) {
      throw new Error(`Invalid volumetric factor retrieved: ${volumetricFactor}`);
    }

    // Step 2: Fetch the box dimension data using poNo from tbl_boxes_dimension
    const boxDataQuery = `
          SELECT id, po_no, DIMENSION, is_unprocessesd, unit,boxes
          FROM tbl_boxes_dimension 
          WHERE po_no = ?
        `;
    const boxDataResult = await mySqlQury(boxDataQuery, [poNo]);

    if (boxDataResult.length === 0) {
      throw new Error(`No box data found for PO No: ${poNo}`);
    }
    console.log("boxDataResult", boxDataResult);

    // Step 3: Calculate the total volumetric weight using the box data and volumetric factor
    const totalVolumetricWeight = await calculateVolumetricWeight(boxDataResult, volumetricFactor);

    // Combine both results
    const result = {


      totalVolumetricWeight
    };

    // Send the result back to the frontend
    res.json(result);
  } catch (error) {
    console.error("Error fetching data:", error);
    res.status(500).send("Error fetching data");
  }
}
const getAddresses = async (req, res, next) => {
  try {
    const { phoneNumber, storeId } = req.body;  // Extract both phoneNumber and storeId

    let query = '';
    let queryParams = [];

    if (phoneNumber) {
      console.log("Fetching addresses for phone number:", phoneNumber);
      query = 'SELECT * FROM tbl_customer_details WHERE phone = ?';
      queryParams = [phoneNumber];
    } else if (storeId) {
      console.log("Fetching addresses for store ID:", storeId);
      query = 'SELECT * FROM tbl_customer_details WHERE store_id = ?';
      queryParams = [storeId];
    } else {
      // If neither phoneNumber nor storeId is provided, return an error
      return res.status(400).json({ success: false, message: 'Please provide either a phone number or store ID.' });
    }

    // Execute the query with the appropriate parameters
    const results = await mySqlQury(query, queryParams);
    console.log('Results of address fetch:', results);

    // Always return a success response with the addresses
    res.status(200).json({ success: true, addresses: results });
  } catch (error) {
    console.error("Error fetching addresses:", error);
    res.status(500).json({ success: false, message: 'Server error' });
  }
}
const apiLocationId = async (req, res, next) => {
  const { id } = req.params;
  try {
    const sql = 'SELECT * FROM tbl_add_warehouse WHERE serial = ?'; // Serial is the primary key
    const [location] = await mySqlQury(sql, [id]); // Use mySqlQury function to execute the query
    console.log("shabbar in add warehouse", location);

    if (location) {
      res.status(200).json({ success: true, location: location });
    } else {
      res.status(404).json({ success: false, message: 'Location not found' });
    }
  } catch (error) {
    console.error('Error fetching location details:', error);
    res.status(500).json({ success: false, message: 'Internal Server Error' });
  }
}
const warehouse = async (req, res, next) => {
  try {
    const accessdata = await access(req.user);
    const role_data = req.user;
    const selectedClientId = req.user.selectedClientId;

    let walletBalance = 0;
    let wallet = 0;
    let pickupData = [];
    let activeTopicIds = [];

    // --- Build WHERE condition ---
    const whereCondition = (selectedClientId === 1) ? '' : `WHERE wa.client_id = ?`;

    // --- Query warehouses with dynamic WHERE ---
    const warehouseQuery = `
      SELECT wa.*, c.company_name AS client_company, c.logo_path AS client_logo 
      FROM tbl_add_warehouse wa
      LEFT JOIN tbl_admin c ON wa.client_id = c.id
      ${whereCondition}
    `;

    pickupData = (selectedClientId === 1)
      ? await mySqlQury(warehouseQuery)
      : await mySqlQury(warehouseQuery, [selectedClientId]);

    // --- Wallet query ---
    wallet = await mySqlQury(
      `SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, 
      [selectedClientId]
    );
    walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

    return res.render('pages/warehouse', {
      role_data,
      accessdata,
      bodyClass: 'profile-page',
      activePage: 'profile',
      title: 'Warehouse Details',
      layout: 'partials/layout-vertical',
      activeTopicIds,
      walletBalance,
      pickupData
    });

  } catch (error) {
    console.error('Error fetching data for warehouse:', error);
    next(error);
  }
};

const getApiToken = async (req, res) => {
  try {
    const token = await getValidDeliveryApiToken();
    res.status(200).json({ token: token });
  } catch (error) {
    console.log("Error in getting API token", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
}
const billingReport = async (req, res, next) => {
  try {
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    let walletBalance = 0;
    let vasService = 0;
    let loginDetails = null;
    let clientId = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id, first_name,vas, company_name, logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }

      // Get wallet balance for the related client
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    // Fetch profile data
    const [profile] = await mySqlQury(
      'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
      [req.user.id]
    );

    // Fetch all data from tbl_billing_section
    const billingData = await mySqlQury(
      `SELECT
            cl.lr_id,
            cl.order_date,
            cl.lr_No,
            cl.consignee_Name,
            cl.po_id,
            cl.destination_Pincode,
            cl.destination_Add,
            cl.total_Box,
            cl.status,
            uo.origin_city,
            uo.origin_pincode,
            ab.additional_charge,
            ab.total_rate,
            laa.charge_name
            FROM tbl_create_lr cl
            left join tbl_aggrigator_bidding ab on cl.lr_No = ab.lr_No
            left join tbl_lr_agg_add  laa on cl.lr_No = laa.lr
            left join tbl_unprocessed_order uo on cl.po_id = uo.po_no
           where cl.status != 0 AND cl.billing_status = 0`
    );

    const clientIdAndClientName = await mySqlQury(`SELECT id, company_name FROM tbl_admin`);

    // Fetch active topics
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [role_data.role]
    );

    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id)); // Convert to numbers
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }
    console.log("client details in the billing reports", clientId)

    // Ensure title is defined for rendering
    const title = 'Billing Reports'; // Define title for the page

    // Render the EJS file with the required data
    res.render('pages/billing-reports', {
      title, // Pass the title to the view
      loginDetails: loginDetails || {}, // Provide empty object as fallback
      profile,
      role_data,
      clientId, // Send clientId
      activeTopicIds, // Send active topic IDs
      billingData, // Send billing data
      walletBalance,
      clientIdAndClientName,
      vasService,
      role
    });
  } catch (error) {
    console.error("Error fetching billing reports:", error);
    next(error);
  }
}
const billingDataFilter = async (req, res) => {
  const { fromDate, toDate, status, clientId } = req.query;
  console.log("status in the ", status)
  if (!fromDate || !toDate) {
    return res.status(400).json({ error: 'fromDate and toDate are required' });
  }

  try {
    // const query = `
    //   SELECT
    //       cl.lr_id,
    //       cl.order_date,
    //       cl.lr_No,
    //       cl.consignee_Name,
    //       cl.po_id,
    //       cl.destination_Pincode,
    //       cl.destination_Add,
    //       cl.total_Box,
    //       cl.status,
    //       uo.origin_city,
    //       uo.origin_pincode,
    //       ab.additional_charge,
    //       ab.total_rate,
    //       laa.charge_name
    //   FROM tbl_create_lr cl
    //   inner JOIN tbl_aggrigator_bidding ab ON cl.lr_No = ab.lr_No
    //   inner JOIN tbl_lr_agg_add laa ON cl.lr_No = laa.lr
    //   inner JOIN tbl_unprocessed_order uo ON cl.po_id = uo.po_no
    //   WHERE cl.status != 0
    //        AND DATE(cl.order_date) BETWEEN ? AND ?
    // `;

    const query = `SELECT 
      cl.lr_No,
      MAX(cl.lr_id) AS lr_id,
      MAX(cl.order_date) AS order_date,
      MAX(cl.consignee_Name) AS consignee_Name,
      MAX(cl.po_id) AS po_id,
      MAX(cl.destination_Pincode) AS destination_Pincode,
      MAX(cl.destination_Add) AS destination_Add,
      MAX(cl.total_Box) AS total_Box,
      MAX(cl.status) AS status,
      MAX(uo.origin_city) AS origin_city,
      MAX(uo.origin_pincode) AS origin_pincode,
      MAX(ab.additional_charge) AS additional_charge,
      MAX(ab.total_rate) AS total_rate,
      MAX(laa.charge_name) AS charge_name
    FROM tbl_create_lr cl
    INNER JOIN tbl_aggrigator_bidding ab ON cl.lr_No = ab.lr_No
    INNER JOIN tbl_lr_agg_add laa ON cl.lr_No = laa.lr
    INNER JOIN tbl_unprocessed_order uo ON cl.po_id = uo.po_no
    WHERE cl.status != 0 AND  cl.billing_status = 0
      AND DATE(cl.order_date) BETWEEN ? AND ?
      AND cl.status = ?
       ${clientId > 0 ? "AND cl.client_id = ?" : ""}
    GROUP BY cl.lr_No;
    `

    const values = [fromDate, toDate, status, clientId];

    const result = await mySqlQury(query, values);

    res.json(result);
  } catch (error) {
    console.error('Error fetching data:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
}
const billingDateFilterForDonloadCSV = async (req, res) => {
  const { fromDate, toDate, status, clientId } = req.query;

  if (!fromDate || !toDate) {
    return res.status(400).json({ error: 'fromDate and toDate are required' });
  }

  try {
    const query = `
          SELECT 
            cl.lr_No,
            MAX(cl.lr_id) AS lr_id,
            MAX(cl.order_date) AS order_date,
            MAX(cl.consignee_Name) AS consignee_Name,
            MAX(cl.po_id) AS po_id,
            MAX(cl.destination_Pincode) AS destination_Pincode,
            MAX(cl.destination_Add) AS destination_Add,
            MAX(cl.total_Box) AS total_Box,
            MAX(cl.status) AS status,
            MAX(uo.origin_city) AS origin_city,
            MAX(uo.origin_pincode) AS origin_pincode,
            MAX(ab.additional_charge) AS additional_charge,
            MAX(ab.total_rate) AS total_rate,
            MAX(laa.charge_name) AS charge_name
          FROM tbl_create_lr cl
          INNER JOIN tbl_aggrigator_bidding ab ON cl.lr_No = ab.lr_No
          INNER JOIN tbl_lr_agg_add laa ON cl.lr_No = laa.lr
          INNER JOIN tbl_unprocessed_order uo ON cl.po_id = uo.po_no
          WHERE cl.status != 0 AND cl.billing_status = 0
            AND DATE(cl.order_date) BETWEEN ? AND ?
            AND cl.status = ?
            ${clientId > 0 ? "AND cl.client_id = ?" : ""}
          GROUP BY cl.lr_No
        `;

    // Set query values
    const values = clientId > 0 ? [fromDate, toDate, status, clientId] : [fromDate, toDate, status];

    // Get data
    const result = await mySqlQury(query, values);
    console.log("result above row loop", result)

    // Update billing_status = 1 for each record
    for (const row of result) {
      await mySqlQury(`
            UPDATE tbl_create_lr 
            SET billing_status = 1 
            WHERE lr_No = ?
          `, [row.lr_No]);
    }

    // Insert invoice entry
    const insertResult = await mySqlQury(`
          INSERT INTO tbl_invoice_billing (invoice_number) VALUES (NULL)
        `);
    const insertedId = insertResult.insertId;
    const invoiceNumber = `INV-${insertedId}`;

    await mySqlQury(`
          UPDATE tbl_invoice_billing SET invoice_number = ? WHERE id = ?
        `, [invoiceNumber, insertedId]);

    // Convert result to CSV
    const json2csvParser = new Parser();
    const csv = json2csvParser.parse(result);

    // File naming and path
    const fileName = `${invoiceNumber}.csv`;
    const downloadDir = path.join(__dirname, 'downloads');
    const filePath = path.join(downloadDir, fileName);

    // Ensure downloads directory exists
    if (!fs.existsSync(downloadDir)) {
      fs.mkdirSync(downloadDir);
    }

    // Write CSV file
    fs.writeFileSync(filePath, csv);

    // Send file for download
    res.download(filePath, fileName, (err) => {
      if (err) {
        console.error('Error sending file:', err);
        return res.status(500).json({ error: 'Failed to download file' });
      }
      // Do not send a second response here â€” download ends the response
    });

  } catch (error) {
    console.error('Error fetching data:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
}
const downloadOldInvoiceCSV = async (req, res) => {
  const { invoiceNumber } = req.query;

  if (!invoiceNumber) {
    return res.status(400).json({ error: 'invoiceNumber is required' });
  }

  try {
    const downloadDir = path.join(__dirname, 'downloads');
    const filePath = path.join(downloadDir, `${invoiceNumber}.csv`);

    // Check if file exists
    if (!fs.existsSync(filePath)) {
      return res.status(404).json({ error: 'File not found' });
    }

    // Send file
    res.download(filePath, `${invoiceNumber}.csv`, (err) => {
      if (err) {
        console.error('Error sending file:', err);
        return res.status(500).json({ error: 'Failed to download file' });
      }
    });

  } catch (error) {
    console.error('Error downloading old invoice:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
}
const addWarehouse = async (req, res) => {
  console.log("Form details received:", req.body);
  console.log("User ID:", req.user.id);
  const targetClientId = Number(req.user?.selectedClientId);

  try {
    const validationErrors = validateWarehouseData(req.body);
    if (validationErrors) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        errors: validationErrors
      });
    }
    // console.log("passed the validation ",kjahdsjkdhsjd)
    await mySqlQury('START TRANSACTION');
    const {
      warehouseName,
      pincode,
      city,
      address,
      contactPersonName,
      phoneWarehouse,
      emailWarehouse,
      time,
      state,
      slot,
      workingDays = [], // e.g., ['Monday', 'Tuesday']
      returnDetails: { address: returnAddress, pincode: returnPincode, state: returnState, city: returnCity } = {},
      clientSelection,
    } = req.body;

    const warehouse_id = uuid.v4();
    const client_id = targetClientId;

    // Validate and prepare database data
    const defaultStartTime = "09:00";
    const defaultCloseTime = "18:00";
    const timeRegex = /^[0-2][0-9]:[0-5][0-9] - [0-2][0-9]:[0-5][0-9]$/;
    const [startTime, closeTime] = time && timeRegex.test(time)
      ? time.split(' - ')
      : [defaultStartTime, defaultCloseTime];

    const dayMapping = {
      Monday: "MON",
      Tuesday: "TUE",
      Wednesday: "WED",
      Thursday: "THU",
      Friday: "FRI",
      Saturday: "SAT",
      Sunday: "SUN",
    };
    const formattedDays = workingDays.map(day => dayMapping[day]);


    // Save to the database
    const sqlQuery = `
        INSERT INTO tbl_add_warehouse (
          warehouse_id,
          warehouse_name,
          warehouse_pincode,
          warehouse_person,
          warehouse_contact_person,
          warehouse_contact_email_person,
          warehouse_city,
          warehouse_address,
          working_hours_from,
          working_hours_to,
          working_days,
          preferred_slot,
          return_warehouse_address,
          return_warehouse_pincode,
          return_warehouse_city,
          client_id,
          return_working_hours_from,
          return_working_hours_to,
          warehouse_state,
          return_warehouse_state
        )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?)
      `;

    // Execute the SQL query
    await mySqlQury(sqlQuery, [
      warehouse_id,
      warehouseName,
      pincode,
      contactPersonName,
      phoneWarehouse,
      emailWarehouse,
      city,
      address,
      time ? time.split(' - ')[0] : null, // Extract start time
      time ? time.split(' - ')[1] : null, // Extract end time
      workingDays.join(', '), // Convert array to string
      slot,
      returnAddress,
      returnPincode,
      returnCity,
      client_id,
      time ? time.split(' - ')[0] : null, // Extract start time
      time ? time.split(' - ')[1] : null,
      state,
      returnState
      // Extract end time
    ]);

    console.log("Data saved to the database successfully.");

    // Prepare data for the external API
    const businessHours = {};
    const pickUpHours = {};
    formattedDays.forEach(day => {
      businessHours[day] = { start_time: startTime, close_time: closeTime };
      pickUpHours[day] = { start_time: startTime, close_time: closeTime };
    });

    const apiData = {
      pin_code: pincode,
      city,
      state: state || "",
      country: "India",
      address_details: {
        address,
        contact_person: contactPersonName,
        phone_number: phoneWarehouse,
      },
      name: warehouseName,
      business_hours: businessHours,
      pick_up_hours: pickUpHours,
      pick_up_days: formattedDays,
      business_days: formattedDays,
      ret_address: {
        pin: returnPincode || "",
        address: returnAddress || "",
      },
    };

    console.log("API data prepared:", JSON.stringify(apiData, null, 2));

    // Get API token
    // const token = await getValidDeliveryApiToken();
    // const token = await getValidDeliveryApiToken();
    // Call the external API
    // const apiResponse = await axios.post(
    //   'https://ltl-clients-api.delhivery.com/client-warehouse/create/',
    //   apiData,
    //   {
    //     headers: {
    //       Authorization: `Bearer ${token}`,
    //       'Content-Type': 'application/json',
    //     },
    //   }
    // );
    // if (!apiResponse.data?.success) {
    //   throw new Error(apiResponse.data?.error?.message || 'LTL API call failed');
    // }

    // console.log("LTL API call succeeded.");

    // Prepare data for the Standard Case API
    const standardApiData = {
      phone: phoneWarehouse,
      city,
      name: warehouseName,
      pin: pincode,
      address,
      country: "India",
      email: emailWarehouse,
      registered_name: clientSelection,
      return_address: returnAddress || "",
      return_pin: returnPincode || "",
      return_city: returnCity || "",
      return_state: returnState || state,
      return_country: "India",
    };

    // Call the Standard Case API
    const stdToken = process.env.DELHIVERY_STD;
    if (!stdToken) {
      throw new Error('Delhivery Standard API token not configured');
    }
    console.log("standard api token", stdToken)

    let standardApiResponse;
    try {
      standardApiResponse = await axios.post(
        'https://track.delhivery.com/api/backend/clientwarehouse/create/',
        standardApiData,
        {
          headers: {
            Authorization: `Token ${stdToken}`,
            'Content-Type': 'application/json',
          },
        }
      );

      if (standardApiResponse.status !== 201) {
        // Extract error message from Delhivery API response
        let errorMessage = 'Standard API call failed';
        if (standardApiResponse.data && standardApiResponse.data.error) {
          if (Array.isArray(standardApiResponse.data.error)) {
            errorMessage = standardApiResponse.data.error[0];
          } else {
            errorMessage = standardApiResponse.data.error;
          }
        } else if (standardApiResponse.data && standardApiResponse.data.message) {
          errorMessage = standardApiResponse.data.message;
        }
        throw new Error(errorMessage);
      }
    } catch (apiError) {
      console.log("Delhivery API Error:", apiError.response?.data);
      
      // If it's a specific Delhivery error, throw it with more context
      if (apiError.response && apiError.response.data) {
        let errorMessage = 'Delhivery API call failed';
        
        if (apiError.response.data.error) {
          if (Array.isArray(apiError.response.data.error)) {
            errorMessage = apiError.response.data.error[0];
          } else {
            errorMessage = apiError.response.data.error;
          }
        } else if (apiError.response.data.message) {
          errorMessage = apiError.response.data.message;
        }
        
        // Add specific handling for common errors
        if (errorMessage.includes('already exists')) {
          errorMessage = `Warehouse "${standardApiData.name}" already exists in Delhivery system. Please use a different name.`;
        }
        
        throw new Error(errorMessage);
      }
      
      throw apiError;
    } 



    console.log("Standard API call succeeded.");
    if (standardApiResponse && standardApiResponse.data) {
      console.log("Standard API response:", standardApiResponse.data);
    }

    // QUICKFLY API Call
    console.log("Calling QUICKFLY API...");
    const quickflyToken = process.env.QUICKFLY;
    if (!quickflyToken) {
      throw new Error('QUICKFLY API token not configured');
    }
    // console.log("QUICKFLY API token:", quickflyToken);

    // Prepare data for QUICKFLY API (using same structure as Standard API)
   

    

    // Call the QUICKFLY API
    let quickflyApiResponse;
    try {
      quickflyApiResponse = await axios.post(
        'https://track.delhivery.com/api/backend/clientwarehouse/create/',
        standardApiData,
        {
          headers: {
            Authorization: `Token ${quickflyToken}`,
            'Content-Type': 'application/json',
          },
        }
      );
      console.log("quickfly api response", quickflyApiResponse)

      if (quickflyApiResponse.status !== 201) {
        // Extract error message from QUICKFLY API response
        let errorMessage = 'QUICKFLY API call failed';
        if (quickflyApiResponse.data && quickflyApiResponse.data.error) {
          if (Array.isArray(quickflyApiResponse.data.error)) {
            errorMessage = quickflyApiResponse.data.error[0];
          } else {
            errorMessage = quickflyApiResponse.data.error;
          }
        } else if (quickflyApiResponse.data && quickflyApiResponse.data.message) {
          errorMessage = quickflyApiResponse.data.message;
        }
        throw new Error(errorMessage);
      }
    } catch (quickflyApiError) {
      console.log("QUICKFLY API Error:", quickflyApiError.response?.data);
      
      // If it's a specific QUICKFLY error, throw it with more context
      if (quickflyApiError.response && quickflyApiError.response.data) {
        let errorMessage = 'QUICKFLY API call failed';
        
        if (quickflyApiError.response.data.error) {
          if (Array.isArray(quickflyApiError.response.data.error)) {
            errorMessage = quickflyApiError.response.data.error[0];
          } else {
            errorMessage = quickflyApiError.response.data.error;
          }
        } else if (quickflyApiError.response.data.message) {
          errorMessage = quickflyApiError.response.data.message;
        }
        
        // Add specific handling for common errors
        if (errorMessage.includes('already exists')) {
          errorMessage = `Warehouse "${standardApiData.name}" already exists in QUICKFLY system. Please use a different name.`;
        }
        
        throw new Error(errorMessage);
      }
      
      throw quickflyApiError;
    }

    console.log("QUICKFLY API call succeeded.");
    if (quickflyApiResponse && quickflyApiResponse.data) {
      console.log("QUICKFLY API response:", quickflyApiResponse.data);
    }
    await mySqlQury('COMMIT');

    res.status(200).json({
      message: 'Warehouse added successfully to Standard API and QUICKFLY API',
      details: {
        delhivery_standard: 'Success',
        quickfly: 'Success'
      }
    });
  } catch (error) {
    console.error("Error:", error.message);
    console.log("error in the warehouse",error.response)
    await mySqlQury('ROLLBACK');

    if (error.response) {
      // Handle axios response errors (like 400, 500 from external APIs)
      let errorMessage = 'Failed to add warehouse';
      let errorDetails = {};
      
      if (error.response.data) {
        // Extract error message from Delhivery API response
        if (error.response.data.error) {
          if (Array.isArray(error.response.data.error)) {
            errorMessage = error.response.data.error[0];
          } else {
            errorMessage = error.response.data.error;
          }
        } else if (error.response.data.message) {
          errorMessage = error.response.data.message;
        }
        
        // Include additional error details for debugging
        errorDetails = {
          status: error.response.status,
          statusText: error.response.statusText,
          apiError: error.response.data
        };
      }
      
      res.status(error.response.status).json({
        message: errorMessage,
        error: errorMessage,
        details: errorDetails,
        type: 'api_error'
      });
    } else {
      // Handle other errors (like validation errors, database errors, etc.)
      res.status(500).json({
        message: 'Internal server error',
        error: error.message,
        type: 'internal_error'
      });
    }
  }
}
const getapiWarehouseId = async (req, res) => {
  const warehouseId = req.params.id;
  try {
    const warehouseData = await mySqlQury('SELECT * FROM tbl_add_warehouse WHERE serial = ?', [warehouseId]);
    if (warehouseData.length > 0) {
      res.json(warehouseData[0]); // Send the first result
    } else {
      res.status(404).json({ message: 'Warehouse not found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
}

const getProducts = async (req, res) => {
  try {
    const user = req.user;
    const selectedClientId = user.selectedClientId || 1;

    let productsData;
    if (selectedClientId === 1) {
      // For admin, get all products
      productsData = await mySqlQury('SELECT id, category, name, price, sku, description FROM client_products');
    } else {
      // For specific client, get client-specific products
      productsData = await mySqlQury(
        'SELECT id, category, name, price, sku, description FROM client_products WHERE client_id = ?',
        [selectedClientId]
      );
    }

    res.json({
      success: true,
      products: productsData || []
    });
  } catch (error) {
    console.error('Error fetching products:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to load products',
      products: []
    });
  }
}
const putapiWarehouseId = async (req, res) => {
  console.log("Updating warehouse with ID:", req.params.id);
  const warehouseId = req.params.id;
  const {
    warehouseName,
    pincode,
    city,
    address,
    contactPersonName,
    phoneWarehouse,
    emailWarehouse,
    time,
    state,
    slot,
    workingDays = [],
    returnDetails: { address: returnAddress, pincode: returnPincode, state: returnState, city: returnCity }
  } = req.body;

  try {
    // Start transaction
    await mySqlQury('START TRANSACTION');

    // Prepare SQL query for updating the warehouse
    const sqlQuery = `
          UPDATE tbl_add_warehouse SET
              warehouse_name = ?,
              warehouse_pincode = ?,
              warehouse_city = ?,
              warehouse_address = ?,
              warehouse_person = ?,
              warehouse_contact_person = ?,
              warehouse_contact_email_person = ?,
              working_days = ?,
              preferred_slot = ?,
              return_warehouse_address = ?,
              return_warehouse_pincode = ?,
              return_warehouse_city = ?,
              warehouse_state = ?
          WHERE serial = ?`;

    // Execute the SQL query
    const indatabaseUpdate = await mySqlQury(sqlQuery, [
      warehouseName,
      pincode,
      city,
      address,
      contactPersonName,
      phoneWarehouse,
      emailWarehouse,
      workingDays.join(', '), // Convert array to string
      slot,
      returnAddress,
      returnPincode,
      returnCity,
      state,
      warehouseId
    ]);
    console.log("update in the database", indatabaseUpdate)

    // Commit the transaction


    console.log("Warehouse updated successfully.");
    const dayMapping = {
      Monday: "MON",
      Tuesday: "TUE",
      Wednesday: "WED",
      Thursday: "THU",
      Friday: "FRI",
      Saturday: "SAT",
      Sunday: "SUN",
    };

    // Prepare data for the LTL API
    //   const ltlApiData = {
    //     pin_code: "201301", // Dynamic value from the form
    //     city: "Noida", // Dynamic value from the form
    //     state: "uttar pradesh", // Dynamic value from the form
    //     country: "India", // Static value
    //     name: "warehouse std and ltl new", // Static value
    //     registered_name: "warehouse std and ltl new", // Static value

    //     address_details: {
    //         address: "B34,sector 59", // Dynamic value from the form
    //         contact_person: contactPersonName, // Dynamic value from the form
    //         phone_number: phoneWarehouse, // Dynamic value from the form
    //         email: emailWarehouse || null // Use null if email is not provided
    //     },
    //     same_as_fwd_add: true, // Assuming this is the desired value
    //     ret_address: {
    //         city: returnCity || city, // Use return city or default to city
    //         country: "India", // Static value
    //         address: returnAddress || address, // Use return address or default to address
    //         pin: returnPincode || pincode, // Use return pin or default to pincode
    //         state: returnState || state // Use return state or default to state
    //     },
    //     business_hours: {},
    //     pick_up_hours: {},
    //     pick_up_days: workingDays.map(day => dayMapping[day]), // Assuming dayMapping is defined
    //     business_days: workingDays.map(day => dayMapping[day]) // Assuming dayMapping is defined
    // };

    // // Set business hours and pick-up hours
    // workingDays.forEach(day => {
    //     ltlApiData.business_hours[dayMapping[day]] = {
    //         start_time: "09:30", // Static value
    //         close_time: "18:30" // Static value
    //     };
    //     ltlApiData.pick_up_hours[dayMapping[day]] = {
    //         start_time: "09:30", // Static value
    //         close_time: "18:30" // Static value
    //     };
    // });

    // Get the LTL API token
    // const ltlToken = await getValidDeliveryApiToken(); 
    // const ltlToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IkFTSFJFWUxPR0lTVElDQjJCQyIsInBob25lX251bWJlciI6Iis5MTk2NTAwOTcwNzYiLCJsYXN0X25hbWUiOiJBaHVqYSIsInVzZXJfdHlwZSI6IkNMIiwiaWF0IjoxNzM4MTU5MjgwLCJpc19jbGllbnRfYWRtaW4iOnRydWUsInRlbmFudCI6IkRlbGhpdmVyeSIsImF1ZCI6Ii5kZWxoaXZlcnkuY29tIiwiZmlyc3RfbmFtZSI6IkppdGVuZGVyIiwic3ViIjoidW1zOjp1c2VyOjowZmYxYzZhYS1mZDdjLTExZWUtYjc3YS0wMmMzMTEwMGZmZWQiLCJjbGllbnRfdXVpZCI6ImNtczo6Y2xpZW50OjowZmYxYzZhYi1mZDdjLTExZWUtYjc3YS0wMmMzMTEwMGZmZWQiLCJpZGxlIjoxNzM4NzY0MDgwLCJjbGllbnRfZW1haWwiOiJqaXRlbmRlckBkaXNwYXRjaC5jby5pbiIsImV4cCI6MTczODI0NTY4MCwiY2xpZW50X25hbWUiOiJBU0hSRVlMT0dJU1RJQyBCMkJDIiwidG9rZW5faWQiOiIxZDM4ZmMwOC04YTM4LTQxODYtOGVjOS05NGQ3NTc5ZDlmNzMiLCJlbWFpbCI6ImFzaHV0b3NoQGRpc3BhdGNoLmNvLmluIiwiYXBpX3ZlcnNpb24iOiJ2MiIsInRvZSI6MTczODE1OTI4MH0.KsY4l_KSP7ZGBl7NXCmsqqeAHnJWcepgQBaG-iOmE-4"
    // console.log("LTL token: " + ltlToken);

    // // Call the LTL API to update the warehouse with the fixed URL
    // const ltlApiResponse = await axios.put(
    //     `https://ltl-api.delhivery.com/client-warehouses/fb263d18-2ba3-4a97-a304-c290b8b2d00f`, // Fixed URL
    //     ltlApiData,
    //     {
    //         headers: {
    //             Authorization: `Bearer ${ltlToken}`,
    //             'Content-Type': 'application/json',
    //             'Accept': 'application/json, text/plain, */*'
    //         },
    //     }
    // );

    //   console.log("LTL API response:", ltlApiResponse.data);

    // if (!ltlApiResponse.data?.success) {
    //     throw new Error(ltlApiResponse.data?.error?.message || 'LTL API call failed');
    // }

    console.log("LTL API call succeeded.");

    // Prepare data for the Standard API
    const standardApiData = {
      phone: phoneWarehouse, // Dynamic value
      city: city, // Dynamic value
      name: warehouseName, // Static value
      pin: pincode, // Dynamic value
      address: address, // Static value
      country: "India", // Static value
      email: emailWarehouse, // Dynamic value
      registered_name: warehouseName, // Static value
      return_address: returnAddress || "", // Dynamic value
      return_pin: returnPincode || "", // Dynamic value
      return_city: returnCity || "", // Dynamic value
      return_state: returnState || state, // Dynamic value
      return_country: "India" // Static value
    };

    // Get API token for Standard API
    const stdToken = process.env.DELHIVERY_STD; // Ensure you have the token stored in your environment variables
    console.log("standared token: " + stdToken);

    // Call the Standard API to update the warehouse
    const standardApiResponse = await axios.post(
      `https://track.delhivery.com/api/backend/clientwarehouse/edit/`,
      standardApiData,
      {
        headers: {
          Authorization: `Token ${stdToken}`,
          'Content-Type': 'application/json',
        },
      }
    );

    console.log("Standard API response:", standardApiResponse.data);

    if (!standardApiResponse.data?.success) {
      throw new Error(standardApiResponse.data?.error?.message || 'Standard API call failed');
    }
    await mySqlQury('COMMIT');

    console.log("Standard API call succeeded.");

    res.status(200).json({
      message: 'Warehouse updated successfully, and both LTL and Standard APIs updated.',
    });
  } catch (error) {
    console.error("Error updating warehouse:", error.message);
    // Rollback the transaction in case of error
    await mySqlQury('ROLLBACK');
    res.status(500).json({
      message: 'Internal server error',
      error: error.message,
    });
  }
}
const postcreateOrder = async (req, res, next) => {
  try {
    // Destructure consigneeDetails and formData from req.body
    const { consigneeDetails, formData, orderid, orderDate, paymentType, additionalData } = req.body;
    console.log("req body in create order", req.body)
    const dynamicKey = Object.keys(req.body.formData)[0]; // Assuming there is only one key
    // console.log('Dynamic Key:', dynamicKey);
    // console.log(skdjskd,dsdsd)

    // Access products using the dynamic key
    const products = req.body.formData[dynamicKey]?.products;
    console.log('Products in formData:', products);
    // console.log("checking the data of request in create -order",yuwryuer)
    console.log("additional information", req.body.checkFavourOf, req.body.checkAmount, req.body.amountCash)
    // console.log("additinal information of payment type", paymentType)
    // console.log("hum hai post me create order me",shsjss)
    console.log("clientId", req.body.clientID);
    console.log("real client id", req.user)


    let client_id = null;

    // Access the user ID directly from req.user
    const userId = req.user.id;
    console.log("kksd", typeof userId); // Accessing the user ID directly

    // Set client_id based on role or user id
    if (userId === 1) {
      // console.log("in this 1");
      // If user id is 1, use the client ID from the request body
      client_id = Number(req.body.clientID); // Convert to number
    } else {
      // If user id is not 1, use the user id
      client_id = Number(userId); // Convert to number
      console.log("in this 1"); // Use the user ID directly
    }

    // Now you can use client_id as needed
    console.log("Final client_id:", client_id);

    // Now you can use client_id as needed
    console.log("Final client_id:", client_id, typeof client_id);
    // console.log("hum hai post me create order me", shsjss)


    // orderdate and payment type use to insert in the database
    const validationErrors = validateCustomerDetails(consigneeDetails, orderid, formData);

    // If there are validation errors, return them
    if (Object.keys(validationErrors).length > 0) {
      return res.status(400).json({ success: false, errors: validationErrors });
    }

    // Destructure the consignee details from the request
    const {
      name,
      address,
      email,
      pincode,
      phone,
      state, // State will be used as the destination
      city,
      nearby,
      store_id
    } = consigneeDetails;
    console.log("nearby", consigneeDetails);
    const consignee_address = `${address},Near by ${nearby},${city},${state},${pincode}`;
    console.log('customer address ', consignee_address);

    // Start a transaction
    await mySqlQury('START TRANSACTION');

    try {
      const customerDetailsQuery = `
              INSERT INTO tbl_customer_details (
                name, email, phone, address, pincode, state, city, nearby,store_id
              ) VALUES (?, ?, ?, ?, ?, ?, ?, ?,?);
            `;

      const customerDetailsValues = [
        name, email, phone, address, pincode, state, city, nearby, store_id
      ];
      console.log('phone', phone);

      await mySqlQury(customerDetailsQuery, customerDetailsValues);

      // Loop through the keys of formData (which are PO numbers)
      for (const po_current in formData) {
        if (formData.hasOwnProperty(po_current)) {
          const products = formData[po_current].products;
          const dimension = formData[po_current].boxesDimensions;
          const totalBoxes = formData[po_current].totalBoxes;
          const totalWeight = formData[po_current].totalWeigth;
          const dimensionunit = formData[po_current].dimensionUnit;
          // Assuming totalBoxes is stored in formData
          // const origin = formData[po_current].origin; // Assuming origin is stored in formData
          const destination = state; // Use state as the destination
          let amount = null;
          let checkFavourOf = null;
          let checkAmount = null;

          // Set values based on paymentType
          if (paymentType === 'cod') {
            amount = req.body.amountCash || null;
          } else if (paymentType === 'check-on-delivery') {
            checkFavourOf = req.body.checkFavourOf || null;
            checkAmount = req.body.checkAmount || null;
          }


          for (const dimen of dimension) {
            console.log("dimension", dimen)
            const dimensionText = `${dimen.length}x${dimen.breadth}x${dimen.Height}(${dimensionunit})`;
            const dimensionQuery = `
                    INSERT INTO tbl_boxes_dimension ( po_no,boxes,DIMENSION) VALUES (?,?,?)
                  `;
            const dimensionValues = [
              po_current,
              dimen.quantityBox,
              dimensionText
            ];
            await mySqlQury(dimensionQuery, dimensionValues)
          }

          // Insert the products into tbl_order_products table
          console.log("sjdgsdjs", products)
          for (const product of products) {
            console.log("products", product)

            const getWarehouseDetailsQuery = `
        SELECT warehouse_city,warehouse_name,warehouse_contact_person, warehouse_state, warehouse_pincode,warehouse_contact_email_person 
        FROM tbl_add_warehouse 
        WHERE warehouse_name = ?;
    `;

            // Assuming you have a function to execute this query and get results
            const warehouseDetails = await mySqlQury(getWarehouseDetailsQuery, [product.poLocation]);

            // Check if you got any results
            if (warehouseDetails.length > 0) {
              const warehouse_city = warehouseDetails[0].warehouse_city.trim();
              const warehouse_state = warehouseDetails[0].warehouse_state.trim();
              const warehouse_pincode = warehouseDetails[0].warehouse_pincode.trim();
              const warehouse_address = warehouseDetails[0].warehouse_address.trim();
              const warehouse_contact_person = warehouseDetails[0].warehouse_contact_person.trim();
              const warehouse_contact_email_person = warehouseDetails[0].warehouse_contact_email_person.trim();
              console.log("here warehouse email", warehouse_contact_email_person)


              const productQuery = `
                  INSERT INTO tbl_unprocessed_order (
                    order_id, po_no, product_name,consignee_name, quantity, category, order_value, hsn_id, origin, destination_state,destination_city, total_boxes,consignee_address
                    ,order_date,payment_type,total_weight,destination_pincode,Amount, Check_Favour_Of, Check_Amount,origin_city, origin_state, origin_pincode,warehouse_address,warehouse_contact_person,consignee_phone
                    ,client_id,consignee_email,	warehouse_email
                  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);
                `;

              const productValues = [
                orderid, // Order ID
                po_current, // PO Number
                product.productName, // Product Name
                name,
                product.quantity, // Quantity
                product.category, // Category
                product.orderValue, // Order Value
                product.hsnId, // HSN ID
                product.poLocation, // Origin (Assuming it's in formData)
                destination,
                city, // Use state as the destination
                totalBoxes, // Total Boxes (Assuming it's in formData)
                consignee_address,
                orderDate,
                paymentType,
                totalWeight,
                pincode,
                amount,
                checkFavourOf,
                checkAmount,
                warehouse_city, // Warehouse city
                warehouse_state, // Warehouse state
                warehouse_pincode,
                warehouse_address,
                warehouse_contact_person,
                phone,
                client_id,
                email,
                warehouse_contact_email_person
              ];

              const res = await mySqlQury(productQuery, productValues);
              console.log("in order craeet oreder", res);


            }
          }


        }

      }

      // Commit the transaction
      await mySqlQury('COMMIT');

      res.status(200).json({ success: true, message: "Order created successfully" });
    } catch (error) {
      // Roll back the transaction if an error occurs
      await mySqlQury('ROLLBACK');
      console.error("Error:", error);
      res.status(500).json({ success: false, message: "Error processing the request" });
    }
  } catch (error) {
    console.error("Error:", error);
    res.status(500).json({ success: false, message: "Error processing the request" });
  }
}
const createOrderSingle = async (req, res, next) => {
  try {
    // Extract all required data from request body
    console.log("req.body", req.body)
    // console.log("dhsjdhsjdhsjdf",dsjdhsjdh)
    const {
      orderid,
      consigneeDetails,
      products,
      orderDate,
      paymentType,
      additionalData,
      totalWeight,
      unit,
      totalBoxes,
      weightUnit,
      boxes,
      clientID,
      wareHouseselectedid,
      poOrder,
      invoiceAmount,
      InvoiceNo
    } = req.body;

    console.log("Received order data:", {
      orderid,
      consigneeDetails,
      totalBoxes,
      totalWeight,
      weightUnit,
      invoiceAmount,
      InvoiceNo,
      orderDate
    });

    // Validate customer details and order data
    const validationErrors = validateCustomerDetails(consigneeDetails, orderid, {
      products,
      boxes,
      totalWeight,
      totalBoxes,
      poOrder,
      invoiceAmount,
      InvoiceNo,
      orderDate
    });

    // If there are validation errors, return them
    if (Object.keys(validationErrors).length > 0) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: validationErrors
      });
    }

    // Extract consignee details
    const { name, email, phone, address, pincode, state, city, nearby, alternate_phone } = consigneeDetails;

    // Determine order type based on weight and boxes
    let order_type = "LTL";
    if (totalWeight <= 30 && totalBoxes <= 1) {
      order_type = "Standard";
    }
    console.log("Order Type:", order_type);

    // Determine client ID based on user role
    const userId = req.user.id;
    // let finalClientID = userId === 1 ? Number(clientID) : Number(userId);

    // Set payment-related values
    let amount = null;
    let checkFavourOf = null;
    let checkAmount = null;

    if (paymentType === 'cod') {
      amount = additionalData?.amountCash || null;
    } else if (paymentType === 'check-on-delivery') {
      checkFavourOf = additionalData?.checkFavourOf || null;
      checkAmount = additionalData?.checkAmount || null;
    }

    // Construct full consignee address
    const consignee_address = `${address}, Near by ${nearby}, ${city}, ${state}, ${pincode}`;
    console.log('Customer Address:', consignee_address);

    // Start database transaction
    await mySqlQury('START TRANSACTION');

    try {
      // Insert customer details
      const customerDetailsQuery = `
            INSERT INTO tbl_customer_details (
              name, email, phone, address, pincode, state, city, nearby
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?);
          `;
      await mySqlQury(customerDetailsQuery, [
        name, email, phone, consignee_address, pincode, state, city, nearby
      ]);

      // Insert box dimensions
      const boxInsertQuery = `
            INSERT INTO tbl_boxes_dimension (
              po_no, boxes, DIMENSION, unit
            ) VALUES (?, ?, ?, ?);
          `;

      for (const box of boxes) {
        const { quantity, length, breadth, height } = box;
        const dimension = `${length}x${breadth}x${height}`;
        await mySqlQury(boxInsertQuery, [poOrder, quantity, dimension, unit]);
      }

      // Insert product details
      const productInsertQuery = `
            INSERT INTO tbl_products (
              product_name, category, quantity, order_value, hsn_id, po_no
            ) VALUES (?, ?, ?, ?, ?, ?);
          `;

      for (const product of products) {
        if (product.quantity && product.orderValue) {
          await mySqlQury(productInsertQuery, [
            product.productName,
            product.category,
            product.quantity,
            product.orderValue,
            product.hsnId,
            poOrder
          ]);
        }
      }

      // Fetch warehouse details
      const warehouseDetails = await mySqlQury(
        `SELECT warehouse_city, warehouse_name, warehouse_contact_person, warehouse_address,
                    warehouse_state, warehouse_pincode, warehouse_contact_email_person 
             FROM tbl_add_warehouse 
             WHERE serial = ?`,
        [wareHouseselectedid]  // Changed from wareHouseselectedid[0] to wareHouseselectedid  in case of new create order it should be wareHouseselectedid
      );

      if (!warehouseDetails.length) {
        throw new Error('Warehouse not found');
      }

      const warehouse = warehouseDetails[0];

      // Insert order details
      const orderInsertQuery = `
            INSERT INTO tbl_unprocessed_order (
              order_id, po_no, consignee_name, consignee_phone, consignee_email, consignee_address,
               payment_type, total_weight, total_boxes, origin, destination_state,
              destination_city, destination_pincode, Amount, Check_Favour_Of, Check_Amount,
              origin_city, origin_state, origin_pincode, warehouse_name, warehouse_contact_person,
              client_id, warehouse_email, order_type, Invoice_amount, invoice_no, warehouse_address,
              weight_unit,consignee_alternate_mobile
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?);
          `;

      const orderResult = await mySqlQury(orderInsertQuery, [
        orderid,
        poOrder,
        name,
        phone,
        email,
        consignee_address,

        paymentType,
        totalWeight,
        totalBoxes,
        warehouse.warehouse_state,
        state,
        city,
        pincode,
        amount,
        checkFavourOf,
        checkAmount,
        warehouse.warehouse_city,
        warehouse.warehouse_state,
        warehouse.warehouse_pincode,
        warehouse.warehouse_name,
        warehouse.warehouse_contact_person,
        clientID,
        warehouse.warehouse_contact_email_person,
        order_type,
        invoiceAmount,
        InvoiceNo,
        warehouse.warehouse_address,
        weightUnit,
        alternate_phone || "NA"
      ]);

      // Generate and insert dispatch LR details
      const orderId = orderResult.insertId;
      const dsDocketNo = `DOCDS-${orderId}`;

      await mySqlQury(
        `INSERT INTO tbl_dispatch_lr (order_id, po_no, ds_docket_no) VALUES (?, ?, ?)`,
        [orderid, poOrder, dsDocketNo]
      );

      // Commit transaction
      await mySqlQury('COMMIT');

      res.status(200).json({
        success: true,
        message: 'Order created successfully',
        docketNo: dsDocketNo
      });

    } catch (error) {
      await mySqlQury('ROLLBACK');
      console.error('Error during order creation:', error);
      res.status(500).json({
        success: false,
        message: 'Error in creating order',
        error: error.message
      });
    }

  } catch (error) {
    console.error('Error in handling request:', error);
    res.status(500).json({
      success: false,
      message: 'Error in processing the request',
      error: error.message
    });
  }
}
const apiCreateOrderExpress = async (req, res) => {
  const validation = validateExpressCreateOrderData(req.body);
  if (!validation.valid) {
    return res.status(400).json({ success: false, message: validation.message });
  }

  const {
    orderID,
    refid,
    invoiceNumber,
    paymentMode,
    collectableAmount,
    consigneeDetails,
    billingDetails: billingFromClient,
    boxes,
    total_Weight,
    productsDetails,
    grandTotal,
    totalQty,
    totalTax,
    totalDiscount,
    warehouseID
  } = req.body;

  let clientid = req.user.selectedClientId;

  if (clientid == 1) {
    const [warehouseDetails] = await mySqlQury(`SELECT client_id FROM tbl_add_warehouse WHERE serial = ?`, [warehouseID]);
    clientid = warehouseDetails.client_id;
  }

  const totalBox = boxes.length;

  try {
    await mySqlQury('START TRANSACTION');

    // âœ… 1. Insert into tbl_exp_orders
    const orderInsertQuery = `
      INSERT INTO tbl_exp_orders 
        (ref_number, orderid, payment_mode, collectable_amount, warehouse_id, total_weight, grand_total, total_qty, total_tax, total_discount, is_unprocessed, client_id, box_qty, invoice_no)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;
    const orderParams = [
      refid,
      orderID,
      paymentMode,
      collectableAmount,
      warehouseID,
      total_Weight,
      grandTotal,
      totalQty,
      totalTax,
      totalDiscount,
      1,
      clientid,
      totalBox,
      invoiceNumber
    ];
    const orderResult = await mySqlQury(orderInsertQuery, orderParams);
    const orderId = orderResult.insertId;

    // âœ… 2. Prepare billingDetails logic
    let billingDetails = {};

    if (consigneeDetails.billingSameAsShipping) {
      billingDetails = {
        billing_first_name: consigneeDetails.firstName,
        billing_last_name: consigneeDetails.lastName,
        billing_email: consigneeDetails.email,
        billing_phone: consigneeDetails.phone,
        billing_alternate_phone: consigneeDetails.alternatePhone,
        billing_address_line1: consigneeDetails.addressLine1,
        billing_address_line2: consigneeDetails.addressLine2,
        billing_landmark: consigneeDetails.landmark,
        billing_country: consigneeDetails.country,
        billing_state: consigneeDetails.state,
        billing_city: consigneeDetails.city,
        billing_pincode: consigneeDetails.pincode
      };
    } else {
      billingDetails = {
        billing_first_name: billingFromClient?.billing_first_name || '',
        billing_last_name: billingFromClient?.billing_last_name || '',
        billing_email: billingFromClient?.billing_email || '',
        billing_phone: billingFromClient?.billing_phone || '',
        billing_alternate_phone: billingFromClient?.billing_alternate_phone || '',
        billing_address_line1: billingFromClient?.billing_address_line1 || '',
        billing_address_line2: billingFromClient?.billing_address_line2 || '',
        billing_landmark: billingFromClient?.billing_landmark || '',
        billing_country: billingFromClient?.billing_country || '',
        billing_state: billingFromClient?.billing_state || '',
        billing_city: billingFromClient?.billing_city || '',
        billing_pincode: billingFromClient?.billing_pincode || ''
      };
    }

    // âœ… 3. Insert into tbl_exp_consignee_details
    const consigneeInsertQuery = `
      INSERT INTO tbl_exp_consignee_details 
        (
          order_id,
          first_name, last_name, email, phone, alternate_phone,
          address_line1, address_line2, landmark, country, state, city, pincode,
          billing_same_as_shipping,
          billing_first_name, billing_last_name, billing_email, billing_phone, billing_alternate_phone,
          billing_address_line1, billing_address_line2, billing_landmark, billing_country, billing_state, billing_city, billing_pincode
        )
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;

    const consigneeParams = [
      orderId,
      consigneeDetails.firstName,
      consigneeDetails.lastName,
      consigneeDetails.email,
      consigneeDetails.phone,
      consigneeDetails.alternatePhone,
      consigneeDetails.addressLine1,
      consigneeDetails.addressLine2,
      consigneeDetails.landmark,
      consigneeDetails.country,
      consigneeDetails.state,
      consigneeDetails.city,
      consigneeDetails.pincode,
      consigneeDetails.billingSameAsShipping ? 1 : 0,

      billingDetails.billing_first_name,
      billingDetails.billing_last_name,
      billingDetails.billing_email,
      billingDetails.billing_phone,
      billingDetails.billing_alternate_phone,
      billingDetails.billing_address_line1,
      billingDetails.billing_address_line2,
      billingDetails.billing_landmark,
      billingDetails.billing_country,
      billingDetails.billing_state,
      billingDetails.billing_city,
      billingDetails.billing_pincode
    ];

    await mySqlQury(consigneeInsertQuery, consigneeParams);

    // âœ… 4. Insert boxes
    for (const box of boxes) {
      const boxInsertQuery = `
        INSERT INTO tbl_exp_boxes_details 
          (order_id, package_type, length, breadth, height, dimension_unit, weight, weight_unit)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `;
      const boxParams = [
        orderId,
        box.packageType,
        box.length,
        box.breadth,
        box.height,
        box.dimensionUnit,
        box.weight,
        box.weightUnit
      ];
      await mySqlQury(boxInsertQuery, boxParams);
    }

    // âœ… 5. Insert products
    for (const product of productsDetails) {
      const productInsertQuery = `
        INSERT INTO tbl_exp_product_details 
          (order_id, category, name, price, sku, quantity, discount_value, discount_type, tax_type)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `;
      const productParams = [
        orderId,
        product.category,
        product.name,
        product.price,
        product.sku,
        product.quantity,
        product.discountValue || 0,
        product.discountType || 'Flat',
        product.taxType || 'None'
      ];
      await mySqlQury(productInsertQuery, productParams);
    }

    await mySqlQury('COMMIT');

    res.json({ success: true, message: 'Order created successfully!', orderId });

  } catch (error) {
    await mySqlQury('ROLLBACK');
    console.error('Order creation error:', error);
    res.status(500).json({ success: false, message: 'Failed to create order', error: error.message });
  }
};

const createOrderMulti = async (req, res, next) => {
  try {
    const orderData = req.body; // Order data sent from the frontend
    console.log("req.body", req.user)

    console.log('Received multiple order data:', orderData);
    const validationErrors = validateMultiOrderData(orderData);
    if (validationErrors) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        errors: validationErrors
      });
    }

    // Destructure the necessary fields from the orderData
    // const { orderid, orderDate, consigneeDetails, clientID, poData, wareHouseselectedid } = orderData;
    const { orderid, orderDate, consigneeDetails, clientID, poData, wareHouseselectedid } = orderData;
    const { name, email, phone, address, pincode, state, city, nearby } = consigneeDetails;
    // console.log("order data",orderData,jsagdhjdgh)
    // Initialize variables for payment details
    let amount = null;
    let checkFavourOf = null;
    let checkAmount = null;

    // Process each PO in poData
    await mySqlQury('START TRANSACTION');

    try {
      // Insert consignee details into tbl_customer_details
      const customerDetailsQuery = `
                  INSERT INTO tbl_customer_details (
                      name, email, phone, address, pincode, state, city, nearby
                  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?);
              `;
      const customerDetailsValues = [name, email, phone, address, pincode, state, city, nearby];
      await mySqlQury(customerDetailsQuery, customerDetailsValues);

      // Process each PO in poData
      for (let i = 0; i < poData.length; i++) {
        // const { wpid: poOrder, paymentType, InvoiceAmount, InvoiceNo, products, boxes, totalBoxes, additionalData,weightUnit,totalWeight } = poData[i];
        const { wpid: poOrder, paymentType, InvoiceAmount, InvoiceNo, products, boxes, totalBoxes, additionalData, weightUnit, totalWeight, warehouseId } = poData[i];//would be warehouseId in case of the new create order
        // const warehouseId = wareHouseselectedid[i];//in case of the new create order it should be warehouseId

        // Set payment details based on payment type
        if (paymentType === 'cod') {
          amount = additionalData.amountCash || null;
          checkFavourOf = additionalData.checkFavourOf || null;
          checkAmount = additionalData.checkAmount || null;
        } else if (paymentType === 'check-on-delivery') {
          checkFavourOf = additionalData.checkFavourOf || null;
          checkAmount = additionalData.checkAmount || null;
        } else {
          amount = null; // For prepaid, amount is not applicable
        }

        console.log("Payment Type:", paymentType, "Amount:", amount, "Check Favour Of:", checkFavourOf, "Check Amount:", checkAmount);

        // Insert product details into tbl_products
        const productInsertQuery = `
                      INSERT INTO tbl_products (
                          product_name, category, quantity, order_value, hsn_id, po_no
                      ) VALUES (?, ?, ?, ?, ?, ?);
                  `;
        for (const product of products) {
          console.log("each products details", product)
          const { product_name, category, quantity, order_value, hsn_id } = product;
          if (quantity && order_value) {
            const productValues = [product_name, category, quantity, order_value, hsn_id, poOrder];
            await mySqlQury(productInsertQuery, productValues);
          }
        }

        // Insert box details into tbl_boxes_dimension
        const boxInsertQuery = `
                      INSERT INTO tbl_boxes_dimension (
                          po_no, boxes, DIMENSION, unit
                      ) VALUES (?, ?, ?, ?);
                  `;
        for (const box of boxes) {
          const { boxQuantity, length, breadth, height } = box;
          const dimension = `${length}x${breadth}x${height}`;
          const boxValues = [poOrder, boxQuantity, dimension, 'cm']; // Assuming unit is 'cm'
          await mySqlQury(boxInsertQuery, boxValues);
        }

        // Retrieve warehouse details and insert into tbl_unprocessed_order
        const getWarehouseDetailsQuery = `
                      SELECT warehouse_city, warehouse_name, warehouse_contact_person, warehouse_address,
                             warehouse_state, warehouse_pincode, warehouse_contact_email_person 
                      FROM tbl_add_warehouse 
                      WHERE serial = ?;
                  `;
        const warehouseDetails = await mySqlQury(getWarehouseDetailsQuery, [warehouseId]);
        if (warehouseDetails.length > 0) {
          const warehouse = warehouseDetails[0];
          const {
            warehouse_city, warehouse_state, warehouse_pincode, warehouse_name,
            warehouse_contact_person, warehouse_contact_email_person, warehouse_address,
          } = warehouse;

          const orderInsertQuery = `
                      INSERT INTO tbl_unprocessed_order (
                          order_id, po_no, consignee_name, consignee_phone, consignee_email, consignee_address,
                          order_date, payment_type, total_weight, total_boxes, origin, destination_state,
                          destination_city, destination_pincode, Amount, Check_Favour_Of, Check_Amount,
                          origin_city, origin_state, origin_pincode, warehouse_name, warehouse_contact_person,
                          client_id, warehouse_email, Invoice_amount, invoice_no, warehouse_address,weight_unit
                      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);
                      `;

          const orderValues = [
            orderid,             // order_id
            poOrder,             // po_no
            name,                // consignee_name
            phone,               // consignee_phone
            email,               // consignee_email
            address,             // consignee_address
            orderDate,           // order_date
            paymentType,         // payment_type
            totalWeight,                // total_weight (if applicable)
            totalBoxes,          // total_boxes
            warehouse_state,     // origin (warehouse state as origin)
            state,               // destination_state (state as destination state)
            city,                // destination_city
            pincode,             // destination_pincode
            amount,              // Amount
            checkFavourOf,       // Check_Favour_Of
            checkAmount,         // Check_Amount
            warehouse_city,      // origin_city (warehouse city as origin city)
            warehouse_state,     // origin_state (warehouse state as origin state)
            warehouse_pincode,   // origin_pincode (warehouse pincode as origin pincode)
            warehouse_name,      // warehouse_name
            warehouse_contact_person, // warehouse_contact_person
            clientID,            // client_id
            warehouse_contact_email_person, // warehouse_email
            InvoiceAmount,       // Invoice_amount
            InvoiceNo,           // invoice_no
            warehouse_address,
            weightUnit     // warehouse_address
          ];

          const result = await mySqlQury(orderInsertQuery, orderValues);

          // Get the insertId from the result
          const lrId = result.insertId;
          const dsDocketNo = `DOCDS-${lrId}`;

          // Insert into tbl_dispatch_lr
          const dispatchLRInsertQuery = `
                          INSERT INTO tbl_dispatch_lr (
                              order_id, po_no, ds_docket_no
                          ) VALUES (?, ?, ?);
                      `;
          await mySqlQury(dispatchLRInsertQuery, [orderid, poOrder, dsDocketNo]);
        }
      }

      // Commit the transaction if all operations succeed
      await mySqlQury('COMMIT');
      res.status(201).json({ message: 'Multiple orders created successfully', status: 'success' });

    } catch (innerError) {
      // Rollback transaction on error
      await mySqlQury('ROLLBACK');
      console.error('Transaction failed, rolling back:', innerError);
      res.status(500).json({ message: 'Error creating multiple orders', error: innerError.message });
    }
  } catch (error) {
    console.error('Error starting transaction:', error);
    res.status(500).json({ message: 'Error initiating order creation', error: error.message });
  }
}
const getUnprocessedOrder = async (req, res) => {
  try {
    console.log('in unprocessed orders')
    const accessdata = await access(req.user);
    const role_data = req.user;
    const role = req.user.role;
    const lang_data = req.language_data;
    const language_name = req.lang;
    const notification_data = await mySqlQury(`SELECT * FROM tbl_notification WHERE received = '${role_data.id}' ORDER BY id DESC LIMIT 3`);
    const sql = 'SELECT * FROM tbl_unprocessed_order WHERE is_unprocessesd = 1 ORDER BY id DESC';
    const result = await mySqlQury(sql);
    console.log('here data from', result)
    // res.status(200).json({ data: result })
    // Render the EJS template
    if (role_data.role == 1) {
      res.render('unprocessed_orders', {
        role_data: role_data,
        accessdata: accessdata,
        lang_data: lang_data,
        language_name: language_name,
        notification_data: notification_data,
        result: result,
        role



      });
    } else {
      res.redirect('/index');
    }
  } catch (error) {
    console.log('error', error)
  }
}
const getbulkOrderDetails = async (req, res, next) => {
  try {
    console.log("Loading the bulk order details route");

    const { po_no } = req.query;
    if (!po_no) {
      return res.status(400).json({ message: 'PO numbers are required.' });
    }

    const poNumbers = po_no.split(',').map(po => po.trim());
    console.log("PO Numbers received:", poNumbers);

    // Updated SQL queries with correct table structure
    const sql = `
          SELECT 
            po.po_no, 
            po.Invoice_amount, 
            po.total_boxes, 
            po.payment_type,
            po.invoice_no,
            po.Amount,
            po.weight_unit, 
            po.destination_pincode,
            po.destination_state,
            po.destination_city,
            po.origin_pincode, 
            po.client_id,
            po.consignee_name,
            po.consignee_phone,
            po.order_date,
            po.consignee_address,
            po.warehouse_address,
            po.warehouse_contact_person,
            po.warehouse_name,
            po.origin,
            po.origin_state,
            po.origin_city,
            po.origin_pincode,
            po.total_weight,
            GROUP_CONCAT(
              JSON_OBJECT(
                'id', bd.id,
                'po_no', bd.po_no,
                'boxes', bd.boxes,
                'DIMENSION', bd.DIMENSION,
                'is_unprocessesd', bd.is_unprocessesd,
                'unit', bd.unit
              )
            ) as box_dimensions
      FROM tbl_unprocessed_order po
          LEFT JOIN tbl_boxes_dimension bd ON po.po_no = bd.po_no
          WHERE po.is_unprocessesd = 1 
          AND po.po_no IN (?)
          GROUP BY po.po_no, po.Invoice_amount, po.total_boxes, po.payment_type,
            po.invoice_no, po.Amount, po.weight_unit, po.destination_pincode,
            po.destination_state, po.destination_city, po.origin_pincode, po.client_id,
            po.consignee_name, po.consignee_phone, po.order_date, po.consignee_address,
            po.warehouse_address, po.warehouse_contact_person, po.warehouse_name,
            po.origin, po.origin_state, po.origin_city, po.origin_pincode, po.total_weight
        `;

    const productsSql = `
          SELECT * FROM tbl_products 
          WHERE po_no IN (?)
        `;

    // Execute both queries
    const [orders, products] = await Promise.all([
      mySqlQury(sql, [poNumbers]),
      mySqlQury(productsSql, [poNumbers])
    ]);

    // Process the results to parse the box_dimensions JSON string
    const processedResults = orders.map(order => {
      try {
        let boxDimensions = [];

        if (order.box_dimensions) {
          // Split the concatenated JSON objects
          const dimensionsArray = order.box_dimensions.split('},{');

          boxDimensions = dimensionsArray.map(dimString => {
            // Clean up the JSON string
            dimString = dimString.replace(/^{/, '').replace(/}$/, '');
            dimString = '{' + dimString + '}';

            try {
              return JSON.parse(dimString);
            } catch (e) {
              console.error('Error parsing dimension:', dimString, e);
              return null;
            }
          }).filter(dim => dim !== null);
        }

        // Get products for this order
        const orderProducts = products.filter(product => product.po_no === order.po_no);

        return {
          ...order,
          box_dimensions: boxDimensions,
          products: orderProducts
        };
      } catch (e) {
        console.error('Error processing order:', order.po_no, e);
        return {
          ...order,
          box_dimensions: [],
          products: []
        };
      }
    });

    // Log for debugging
    console.log("Processed Results:", JSON.stringify(processedResults, null, 2));

    if (processedResults.length === 0) {
      return res.status(404).json({
        message: 'No unprocessed orders found for the given PO numbers.'
      });
    }

    // Send the processed data
    return res.status(200).json({
      message: 'Bulk order details fetched successfully',
      data: processedResults
    });

  } catch (error) {
    console.error("Error fetching bulk order details:", error);
    return res.status(500).json({
      message: 'An error occurred while fetching bulk order details',
      error: error.message
    });
  }
}
const getAggrigatorDetails = async (req, res, next) => {
  try {
    const { orderDetails, aggregatorId } = req.query;
    console.log("orders details in get_aggrigator_details", orderDetails, aggregatorId)

    if (!orderDetails || !aggregatorId) {
      return res.status(400).json({ message: 'Order details and aggregator ID are required' });
    }

    let aggrigatorDetails = [];
    const serviceTypeResult = await mySqlQury(
      `SELECT service_type, binded_with_forwarder FROM tbl_aggrigator WHERE id = ?`,
      [aggregatorId]
    );

    const serviceType = serviceTypeResult.length ? serviceTypeResult[0].service_type : null;
    const bindedWithForwarder = serviceTypeResult.length ? serviceTypeResult[0].binded_with_forwarder : null;

    // const parsedOrderDetails = JSON.parse(orderDetails);

    for (const order of orderDetails) {
      const { po_no, Invoice_amount, total_boxes, payment_type, destination_pincode, origin_pincode, client_id, total_weight, weight_unit, boxDimensions, cod } = order;

      if (!origin_pincode || !destination_pincode || !total_weight || !total_boxes || !payment_type) {
        return res.status(400).json({ message: 'Missing required fields in order details.' });
      }

      const pickupPincodeDetails = await mySqlQury(
        `SELECT city, state, Zone FROM tbl_master_pincode WHERE pincode = ?`,
        [origin_pincode]
      );
      const destinationPincodeDetails = await mySqlQury(
        `SELECT city, state, Zone FROM tbl_master_pincode WHERE pincode = ?`,
        [destination_pincode]
      );

      if (!pickupPincodeDetails.length || !destinationPincodeDetails.length) {
        return res.status(404).json({ error: 'One or both pincodes not found in tbl_master_pincode' });
      }

      const pickupCity = pickupPincodeDetails[0].city;
      const pickupState = pickupPincodeDetails[0].state;
      let pickupZone = pickupPincodeDetails[0].Zone;
      const destinationCity = destinationPincodeDetails[0].city;
      const destinationState = destinationPincodeDetails[0].state;
      let destinationZone = destinationPincodeDetails[0].Zone;
      console.log("pickup zone and destination zone", destinationZone, pickupZone, destinationPincodeDetails, pickupPincodeDetails)

      // Get aggregator details directly
      const partner = await mySqlQury(
        `SELECT 
                a.id, 
                a.Aggrigator_company_name as name, 
                a.service_type, 
                a.aggrigator_type as category, 
                a.logo_path as tagged_logo, 
                a.dispatch_agg, 
                a.binded_with_forwarder, 
                a.aggrigator_type,
                cu.minimum_chargable_weight, 
                cu.volumetric_factor
             FROM tbl_aggrigator a
             JOIN tbl_customers cu ON a.id = cu.Aggrigator_id
             WHERE a.id = ?`,
        [aggregatorId]
      );

      if (!partner.length) {
        return res.status(404).json({ error: 'No aggregator found for the provided ID.' });
      }
      console.log("aggregator details", partner)

      let rates = [];
      let forwarderTotalRateAndDetails = [];


      console.log("Processing aggregator:", partner);

      const forwarderTable = `tbl_zone_mapping_Aggrigator_${partner[0].id}`;
      const tatTable = `tbl_TAT_Aggrigator_${partner[0].id}`;
      console.log("tables ", forwarderTable, tatTable);
      let taggedApi = null;
      let selectedForwarderId = null;
      let lowestRate = Infinity;
      let selectedForwarderDetails = null;


      if (partner[0].binded_with_forwarder === 2 || partner[0].binded_with_forwarder === 1) {
        console.log("forwarder details in the ==2");

        const forwarderDetails = await mySqlQury(
          `SELECT 
                  af.Forwarder_id, 
                  af.tagged_api, 
                  af.service_type, 
                  vd.minimum_chargable_weight, 
                  vd.volumetric_factor
               FROM tbl_aggrigator_forwarder af
               LEFT JOIN tbl_vendor_details vd ON af.Forwarder_id = vd.id
               WHERE af.Aggrigator_id = ?`,
          [partner[0].id]
        );

        console.log("Forwarder Details in volumetric data details:", forwarderDetails);

        if (forwarderDetails.length) {
          for (const forwarder of forwarderDetails) {
            console.log("forwarder details in the --2 and the ", forwarder.Forwarder_id, forwarder.service_type)
            let forwarderId = null;
            let forwarderTaggedApi = forwarder.tagged_api;
            let serviceType = forwarder.service_type;
            let totalRate = null;
            let tat = null;

            if (serviceType === "LTL") {
              console.log("forwarder details in the --2 in the case LTL")
              forwarderId = forwarder.Forwarder_id;
              forwarderTaggedApi = forwarder.tagged_api;
              serviceType = forwarder.service_type;

              const pickupZoneQuery = `SELECT Zone FROM tbl_zone_mapping_${forwarderId} WHERE City = ? OR State = ?`;
              const destinationZoneQuery = `SELECT Zone FROM tbl_zone_mapping_${forwarderId} WHERE City = ? OR State = ?`;

              console.log("pickupcity and destination details", pickupCity, pickupState, destinationCity, destinationState)
              const pickupZoneResult = await mySqlQury(pickupZoneQuery, [pickupCity, pickupState]);
              const destinationZoneResult = await mySqlQury(destinationZoneQuery, [destinationCity, destinationState]);

              const originZone = pickupZoneResult.length > 0 ? pickupZoneResult[0].Zone : null;
              const destinationZone = destinationZoneResult.length > 0 ? destinationZoneResult[0].Zone : null;
              console.log("shabbar in ltl case of forwarder details", originZone, destinationZone, forwarderId);

              const rateResult = await mySqlQury(
                `SELECT rate FROM tbl_vendor_rates WHERE zone_origin = ? AND zone_destination = ? AND vendor_id = ?`,
                [originZone, destinationZone, forwarderId]
              );
              console.log("rate result", rateResult)
              const tatResult = await mySqlQury(
                `SELECT days FROM tbl_tat_${forwarderId} WHERE zone_origin = ? AND zone_destination = ?`,
                [originZone, destinationZone]
              );
              const totalVolumetricWeight = await calculateVolumetricWeightLTL(boxDimensions, forwarder.volumetric_factor);
              console.log("total volumetric weight", totalVolumetricWeight)
              const minimumChargableWeight = Number(forwarder.minimum_chargable_weight);

              const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);

              const maxWeight = Math.max(weightInKg, totalVolumetricWeight, minimumChargableWeight);
              console.log("Maximum Weight Used for Base Value Calculation:", maxWeight);

              const base_value = rateResult.length > 0 ? Number(rateResult[0].rate) * Math.ceil(maxWeight) : 0;
              console.log("Base Value", base_value);

              console.log("Base Value in forwarder", base_value)
              console.log("rate and tat in the case of forwarder binded in vendor in case of ltl", tatResult)

              if (rateResult.length && tatResult.length) {
                const rate = Number(rateResult[0].rate);
                tat = tatResult[0].days;

                const additionalChargesResult = await calculateAdditionalChargesForwarder(
                  forwarderId,
                  weightInKg,
                  total_boxes,
                  paymentType,
                  rate,
                  base_value,
                  clientBaseValue,
                  cod
                );
                console.log("Additional charges in forwarder ltl:", additionalChargesResult);

                // Use totalCharge from the result object for rate calculation
                totalRate = Number(base_value) + Number(additionalChargesResult.totalCharge);

                if (totalRate < lowestRate) {
                  lowestRate = totalRate;
                  selectedForwarderId = forwarderId;
                  taggedApi = forwarderTaggedApi;
                }

                forwarderTotalRateAndDetails.push({
                  forwarderId: forwarderId,
                  baserate: Number(base_value),
                  Totalrate: Number(totalRate),
                  tat: tat,
                  taggedApi: forwarderTaggedApi,
                  additionalCharges: {
                    total: additionalChargesResult.totalCharge,
                    breakdown: additionalChargesResult.chargesBreakdown
                  }
                });
              }
              selectedForwarderDetails = forwarderTotalRateAndDetails.find(detail => detail.forwarderId === selectedForwarderId);
              console.log("selected forwarder details", selectedForwarderDetails)
            }
            else if (serviceType === "standard") {
              console.log("in standard mode in forwarder", forwarderTaggedApi)
              if (['expressbees', 'delhivery'].includes(forwarderTaggedApi.toLowerCase())) {
                const isServiceable = await checkServiceability(
                  forwarderTaggedApi,
                  pickupPincode,
                  destination_pincode,
                  total_weight,
                  payment_type,
                  clientBaseValue,
                  weight_unit
                );

                if (!isServiceable) {
                  console.log(`Skipping ${forwarderTaggedApi} as route is not serviceable`);
                  continue;
                }
                else {
                  console.log(`Processing ${forwarderTaggedApi} as it is within-city serviceable`);
                }
              }
              forwarderId = forwarder.Forwarder_id
              forwarderTaggedApi = forwarder.tagged_api
              serviceType = forwarder.service_type;
              console.log("forwarder details in the --2 in the standard", pickupCity, destinationCity, partner.Aggrigator_id);

              const originZone = await determineForwarderOriginZone(
                forwarderId,
                pickupCity,
                destinationCity,
                pickupState,
                destinationState,
                pickupZone,
                destinationZone
              );

              console.log("Origin zone determined for forwarder:", originZone, forwarderId, forwarder.company_name);


              if (originZone) {
                // First calculate volumetric weight to compare with actual weight
                const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);
                console.log("converted weight in kg:", weightInKg);
                const boxDimensionsQuery = await mySqlQury('SELECT * FROM tbl_boxes_dimension WHERE po_no = ?', [po_no]);
                const boxDimensions = boxDimensionsQuery.length > 0 ? boxDimensionsQuery[0] : null;
                console.log("box dimensions", boxDimensions)
                console.log("box dimensions in the case of forwarder", boxDimensionsQuery)

                const totalVolumetricWeight = await calculateVolumetricWeight(boxDimensionsQuery, partner.volumetric_factor);
                console.log("total volumetric weight in std forwarder:", totalVolumetricWeight);

                // Determine the higher weight between actual and volumetric
                const higherWeight = Math.max(weightInKg, totalVolumetricWeight);
                console.log("higher weight between actual and volumetric:", higherWeight);

                // Convert to grams for API call
                const weightInGrams = higherWeight * 1000;
                console.log("weight in grams for rate calculation:", weightInGrams);

                // Get rate based on the higher weight
                const { rate, maxWeight } = await findRateForwarder(forwarderId, originZone, weightInGrams);
                console.log("forwarder rate:", rate);
                console.log("forwarder max weight:", maxWeight);

                const standardTATResult = await mySqlQury(
                  `SELECT days 
                       FROM tbl_standard_tat
                       WHERE zone = ? AND vendor_id = ?`,
                  [originZone, forwarderId]
                );

                if (standardTATResult.length) {
                  console.log("rate calculator in the api in rate.length", rate);
                  tat = standardTATResult[0].days;
                  console.log("TAT of forwarder:", tat);

                  // Calculate base value using the rate
                  const base_value = Number(rate);
                  console.log("Base Value in std forwarder:", base_value);

                  const additionalChargesResult = await calculateAdditionalChargesForwarder(
                    forwarderId,
                    weightInKg,
                    total_boxes,
                    paymentType,
                    rate,
                    base_value,
                    clientBaseValue,
                    cod
                  );
                  console.log("Additional charges in forwarder:", additionalChargesResult);

                  // Use totalCharge from the result object for rate calculation
                  totalRate = Number(rate) + Number(additionalChargesResult.totalCharge);

                  if (totalRate < lowestRate) {
                    lowestRate = totalRate;
                    selectedForwarderId = forwarderId;
                    taggedApi = forwarderTaggedApi;
                  }

                  forwarderTotalRateAndDetails.push({
                    forwarderId: forwarderId,
                    baserate: Number(rate),
                    Totalrate: totalRate,
                    tat: tat,
                    taggedApi: forwarderTaggedApi,
                    additionalCharges: {
                      total: additionalChargesResult.totalCharge,
                      breakdown: additionalChargesResult.chargesBreakdown
                    }
                  });
                  selectedForwarderDetails = forwarderTotalRateAndDetails.find(detail => detail.forwarderId === selectedForwarderId);
                  console.log("selected forwarder details", selectedForwarderDetails)
                }
              } else {
                console.log("No origin zone found for standard service");
              }
            }
          }
        }
      }

      try {
        let chargableWeight = 0;
        if (partner.service_type === 'LTL') {
          console.log("in the case of servise type ltl", partner.Aggrigator_id)
          const pickupZoneDetails = await mySqlQury(
            `SELECT zone FROM ?? WHERE city = ? OR state = ?`,
            [forwarderTable, pickupCity, pickupState]
          );

          const destinationZoneDetails = await mySqlQury(
            `SELECT zone FROM ?? WHERE city = ? OR state = ?`,
            [forwarderTable, destinationCity, destinationState]
          );
          console.log("pickup details and destination details", pickupCity, pickupState, destinationCity, destinationState)

          console.log("pickupZone", pickupZoneDetails, destinationZoneDetails, partner.Aggrigator_id);

          if (pickupZoneDetails.length && destinationZoneDetails.length) {
            const rateDetails = await mySqlQury(
              `SELECT rate FROM tbl_client_rates 
                 WHERE Aggrigator_id = ? 
                 AND zone_origin = ? 
                 AND zone_destination = ?`,
              [
                partner.Aggrigator_id,
                pickupZoneDetails[0].zone,
                destinationZoneDetails[0].zone,
              ]
            );
            console.log("shabbar ansari", rateDetails, partner.Aggrigator_id, pickupZoneDetails[0].zone, destinationZoneDetails[0].zone)

            const tatDetails = await mySqlQury(
              `SELECT days FROM ?? 
                 WHERE Aggrigator_id = ? 
                 AND zone_origin = ? 
                 AND zone_destination = ?`,
              [
                tatTable,
                partner.Aggrigator_id,
                pickupZoneDetails[0].zone,
                destinationZoneDetails[0].zone
              ]
            );
            console.log("tat details", tatDetails)
            const tat = tatDetails[0].days;
            console.log("partner minumum weight", partner.minimum_chargable_weight, partner.volumetric_factor)
            const totalVolumetricWeight = await calculateVolumetricWeightLTL(boxDimensions, partner.volumetric_factor);
            console.log("total volumetric weight", totalVolumetricWeight);

            const minimumChargableWeight = Number(partner.minimum_chargable_weight);

            const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);

            const maxWeight = Math.max(weightInKg, totalVolumetricWeight, minimumChargableWeight);
            chargableWeight = maxWeight;
            console.log("Maximum Weight Used for Base Value Calculation:", maxWeight);

            if (rateDetails.length > 0) {
              const rate = Number(rateDetails[0].rate);
              const base_value = rate * Math.ceil(maxWeight);
              console.log("Base Value", base_value);

              if (tatDetails.length) {
                const additionalChargesResult = await calculateAdditionalCharges(
                  partner.Aggrigator_id,
                  weightInKg,
                  total_boxes,
                  paymentType,
                  rate,
                  base_value,
                  clientBaseValue,
                  cod
                );
                console.log("aggrigator additinal total breakdown", additionalChargesResult)

                console.log("here in the additional charges aggrigator ltl ", rate, additionalChargesResult.totalCharge);

                const totalRate = Number(base_value) + Number(additionalChargesResult.totalCharge);
                console.log("selected forwarder details in the case of aggrigator ltl", selectedForwarderDetails)

                rates.push({
                  Aggrigator: partner.Aggrigator_company_name,
                  rate: totalRate,
                  baserate: Number(base_value),
                  forwarderTotalRateAndDetails: selectedForwarderDetails,
                  days: tat,
                  AggrigatorLogo: partner.tagged_logo,
                  additionalCharges: {
                    total: additionalChargesResult.totalCharge,
                    breakdown: additionalChargesResult.chargesBreakdown || []
                  },
                  category: partner.aggrigator_type,
                  service_type: partner.service_type,
                  TaggedApi: partner.tagged_api, // Use the aggregator's tagged_api instead of forwarder's
                  agg_defination: partner.agg_defination,
                  Aggrigator_id: partner.Aggrigator_id,
                  chargableWeight: chargableWeight,
                  weight_unit: 'kg',
                  zones: {
                    origin: pickupZoneDetails[0].zone,
                    destination: destinationZoneDetails[0].zone
                  },
                  shipmentType: 'LTL'
                });
              } else {
                rates.push({
                  forwarder: partner.name,
                  rate: null,
                  Aggrigator_id: partner.Aggrigator_id,
                  message: 'No LTL rates found'
                });
              }
            } else {
              rates.push({
                forwarder: partner.name,
                rate: null,
                Aggrigator_id: partner.Aggrigator_id,
                message: 'No LTL rates found for this route'
              });
            }
          }
        }
        else {
          console.log("pickup zone in the else in standard", pickupZone, destinationZone);
          // Use the helper function to determine origin zone
          const originZone = await determineOriginZoneAggregator(
            partner.Aggrigator_id,
            pickupCity,
            destinationCity,
            pickupState,
            destinationState,
            pickupZone,
            destinationZone
          );

          // If no zone is found after all checks
          if (!originZone) {
            console.log("No origin zone found for standard service");
            rates.push({
              forwarder: partner.name,
              rate: null,
              Aggrigator_id: partner.Aggrigator_id,
              message: 'No valid zone found for shipment'
            });
            return;
          }

          // Continue with the rest of your code using the determined originZone
          console.log("Origin zone found: ", originZone);

          console.log("origin zone found: ", originZone);
          console.log("weight unit", weight_unit)
          // First calculate volumetric weight to compare with actual weight
          const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);
          console.log("converted weight in kg:", weightInKg);

          const totalVolumetricWeight = await calculateVolumetricWeight(boxDimensions, partner.volumetric_factor);
          console.log("total volumetric weight in std:", totalVolumetricWeight);

          // Determine the higher weight between actual and volumetric
          const higherWeight = Math.max(weightInKg, totalVolumetricWeight);
          console.log("higher weight between actual and volumetric:", higherWeight);

          // Convert to grams for API call
          const weightInGrams = higherWeight * 1000;
          console.log("weight in grams for rate calculation:", weightInGrams);

          // Get rate based on the higher weight
          const { rate, maxWeight } = await findRateAggrigator(partner.Aggrigator_id, originZone, weightInGrams);
          console.log("aggrigator rate:", rate);
          console.log("aggrigator max weight:", maxWeight);

          const standardTATResult = await mySqlQury(
            `SELECT days 
                 FROM tbl_std_agg_tat 
                 WHERE zone = ? AND aggrigator_id = ?`,
            [originZone, partner.Aggrigator_id]
          );
          console.log("standardTAT result:", standardTATResult);

          if (rate) {
            const tat = standardTATResult[0]?.days;
            console.log("TAT of aggrigator:", tat);

            // Check if we need to use minimum chargeable weight
            // const minimumChargableWeight = Number(maxWeight);
            // const maxWeightChargable = Math.max(higherWeight, minimumChargableWeight);
            // chargableWeight = maxWeightChargable;
            // console.log("Maximum Weight Used for Base Value Calculation in std aggrigator:", maxWeightChargable);

            // Calculate base value using the rate from findRateAggrigator
            const base_value = Number(rate);
            console.log("Base Value in std aggrigator:", base_value);

            const additionalChargesResult = await calculateAdditionalCharges(
              partner.Aggrigator_id,
              weightInKg,
              total_boxes,
              paymentType,
              rate,
              base_value,
              clientBaseValue,
              cod
            );

            console.log("here in the additional charges ", rate, additionalChargesResult.totalCharge);

            const totalRate = Number(rate) + Number(additionalChargesResult.totalCharge);
            console.log("selected forwarder details in the case of aggrigator", selectedForwarderDetails)

            rates.push({
              Aggrigator: partner.Aggrigator_company_name,

              rate: totalRate,
              baserate: Number(rate),
              forwarderTotalRateAndDetails: selectedForwarderDetails,
              days: tat,
              AggrigatorLogo: partner.tagged_logo,
              additionalCharges: {
                total: additionalChargesResult.totalCharge,
                breakdown: additionalChargesResult.chargesBreakdown || []
              },
              category: partner.aggrigator_type,
              service_type: partner.service_type,
              TaggedApi: taggedApi,
              weight_unit: 'gm',
              agg_defination: partner.agg_defination,
              Aggrigator_id: partner.Aggrigator_id,
              chargableWeight: weight_unit === 'gm' ? higherWeight * 1000 : higherWeight,
              zones: {
                origin: pickupZone,
                destination: destinationZone
              },
              shipmentType: 'Standard'
            });
          } else {
            rates.push({
              forwarder: partner.name,
              rate: null,
              Aggrigator_id: partner.Aggrigator_id,
              message: 'No standard rate found'
            });
          }
        }

      } catch (error) {
        console.error('Error fetching forwarding partners:', error);
      }

      aggrigatorDetails.push({
        po_no,
        rates
      });
    }

    res.status(200).json({
      message: 'Bulk LR details processed successfully!',
      data: aggrigatorDetails,
      serviceType,
      bindedWithForwarder
    });

  } catch (error) {
    console.error('Error processing bulk LR:', error);
    res.status(500).json({ message: 'Internal server error.' });
  }
}

const getPo = async (req, res) => {
  try {
    console.log("Loading the krishna route");

    // Get the PO number from the URL parameters
    const { poNo } = req.params;
    console.log("PO Number:", poNo);

    if (!poNo) {
      console.error("PO number is missing in the request.");
      return res.status(400).json({ message: 'PO number is required.' });
    }

    // Define the SQL query to get details for the specific PO number
    const sql = `
      SELECT
        po.po_no,
        po.Invoice_amount,
        po.total_boxes,
        po.payment_type,
        po.destination_pincode,
        po.origin_pincode,
        po.client_id,
        po.total_weight,
        po.weight_unit,
        lr.lr_No,
        lr.chargable_weight,
        lr.invoice_Value,
        lr.eta,
        po.order_id,
        po.consignee_name,
        po.consignee_address,
        po.origin_city,
        po.origin_state,
        po.destination_city,
        po.destination_state,
        po.order_date,
        po.invoice_no,
        po.hsn_id,
        po.Amount,
        po.warehouse_address,
        ds.ds_docket_no,

        prod.product_name,
        prod.quantity,
        prod.order_value,
        lr.aggrigator_id,
        agg.logo_path as logo_right,
        agg.aggrigator_type
      FROM
        tbl_unprocessed_order po
      LEFT JOIN
        tbl_create_lr lr ON po.po_no = lr.po_id
      LEFT JOIN
        tbl_boxes_dimension bd ON po.po_no = bd.po_no
      LEFT JOIN
        tbl_dispatch_lr ds ON po.po_no = ds.po_no
      LEFT JOIN
        tbl_products prod ON po.po_no = prod.po_no
      LEFT JOIN
        tbl_aggrigator agg ON lr.aggrigator_id = agg.id
      WHERE
        po.po_no = ?
    `;

    // console.log("Executing SQL Query:", sql);
    const result = await mySqlQury(sql, [poNo]);

    if (!result || result.length === 0) {
      console.warn("No data found for PO Number:", poNo);
      return res.status(404).json({ message: 'No unprocessed order found for the given PO number.' });
    }

    const orderDetails = result[0]; // Extract the first record for order details
    const clientId = orderDetails.client_id;

    if (!clientId) {
      return res.status(404).json({ message: 'Client ID not found for the given PO number.' });
    }

    // Query to fetch client details from tbl_admin
    const clientDetailsSql = `
      SELECT
        client.company_name,
        client.company_address,
        logo_path,
        client.gst
      FROM
        tbl_admin client
      WHERE
        client.id = ?
    `;
   
    // Fetch client and product details concurrently
    const [clientDetails] = await Promise.all([
      mySqlQury(clientDetailsSql, [clientId]),
      // No need to fetch product details again, they're already in the `result`
    ]);

    if (!clientDetails || clientDetails.length === 0) {
      console.warn("Client details not found for client ID:", clientId);
      return res.status(404).json({ message: 'No client details found for the given client ID.' });
    }

    // console.log("Order details fetched successfully:", result);

    // Extract product details from the result
    const productDetails = result.map(item => ({
      product_name: item.product_name,
      quantity: item.quantity,
      order_value: item.order_value,  // Corrected to order_value
    }));

    // Return the response with the order, client, and product details
    return res.status(200).json({
      message: 'Order details fetched successfully',
      data: {
        orderDetails,  // Return the first matching result for order details
        clientDetails: clientDetails[0] || {},  // Return client details, or empty object if not found
        productDetails,  // Return all product details
      }
    });

  } catch (error) {
    console.error("Error fetching order details:", error);
    return res.status(500).json({ message: 'An error occurred while fetching the order details', error: error.message });
  }
}
const getBulkOrderDetails = async (req, res, next) => {
  try {
    console.log("Loading the bulk order details route");

    // Get the po_no from query parameters (can be comma-separated)
    const { po_no } = req.query;
    if (!po_no) {
      return res.status(400).json({ message: 'PO numbers are required.' });
    }

    // Split the po_no string into an array of PO numbers
    const poNumbers = po_no.split(',').map(po => po.trim());

    console.log("PO Numbers received:", poNumbers);

    // Define the SQL query to get details for multiple POs
    const sql = `
      SELECT po.po_no, po.Invoice_amount, po.total_boxes, po.payment_type, 
             po.destination_pincode, po.origin_pincode, po.client_id, po.total_weight
      FROM tbl_unprocessed_order po
      WHERE po.is_unprocessesd = 1 AND po.po_no IN (?)
    `;

    // Execute the query using your custom mySqlQury function
    const result = await mySqlQury(sql, [poNumbers]);

    // Check if data is found
    if (result.length === 0) {
      return res.status(404).json({ message: 'No unprocessed orders found for the given PO numbers.' });
    }

    // Send the data to the frontend
    return res.status(200).json({
      message: 'Bulk order details fetched successfully',
      data: result
    });

  } catch (error) {
    console.error("Error fetching bulk order details:", error);
    return res.status(500).json({ message: 'An error occurred while fetching bulk order details' });
  }
}
const postgetForwarderDetails = async (req, res) => {
  const {
    po_no,
    invoice_amount,
    aggregatorId,
    origin_pincode,
    destination_pincode,
    total_boxes,
    total_weight,
    payment_type
  } = req.body;

  // Validate required fields
  if (!po_no || !aggregatorId || !origin_pincode || !destination_pincode || !total_boxes || !total_weight || !payment_type) {
    return res.status(400).json({ error: 'Missing required fields.' });
  }
  console.log("in the route get_forwarder_details", req.body)

  try {
    // Fetch city and state details for pickup and destination
    const originPincodeDetails = await mySqlQury(
      `SELECT city, state FROM tbl_master_pincode WHERE pincode = ?`,
      [origin_pincode]
    );
    const destinationPincodeDetails = await mySqlQury(
      `SELECT city, state FROM tbl_master_pincode WHERE pincode = ?`,
      [destination_pincode]
    );

    if (!originPincodeDetails.length || !destinationPincodeDetails.length) {
      return res.status(404).json({ error: 'One or both pincodes not found in tbl_master_pincode.' });
    }

    const originCity = originPincodeDetails[0].city;
    const originState = originPincodeDetails[0].state;
    const destinationCity = destinationPincodeDetails[0].city;
    const destinationState = destinationPincodeDetails[0].state;

    // Fetch forwarders tagged to the aggregator
    const forwarderDetails = await mySqlQury(
      `SELECT Forwarder_id, tagged_api, service_type, Aggrigator_id 
           FROM tbl_aggrigator_forwarder 
           WHERE Aggrigator_id = ?`,
      [aggregatorId]
    );

    if (!forwarderDetails.length) {
      return res.status(404).json({ error: 'No forwarder details found for the given aggregator.' });
    }

    const rates = [];
    let lowestRate = Infinity;
    let selectedForwarder = null;

    for (const forwarder of forwarderDetails) {
      const forwarderId = forwarder.Forwarder_id;
      const serviceType = forwarder.service_type;
      const taggedApi = forwarder.tagged_api;

      let totalRate = null;
      let tat = null;

      if (serviceType === 'LTL') {
        // Fetch LTL zones and rates
        const originZoneResult = await mySqlQury(
          `SELECT Zone FROM tbl_zone_mapping_${forwarderId} WHERE City = ? OR State = ?`,
          [originCity, originState]
        );
        const destinationZoneResult = await mySqlQury(
          `SELECT Zone FROM tbl_zone_mapping_${forwarderId} WHERE City = ? OR State = ?`,
          [destinationCity, destinationState]
        );

        const originZone = originZoneResult.length > 0 ? originZoneResult[0].Zone : null;
        const destinationZone = destinationZoneResult.length > 0 ? destinationZoneResult[0].Zone : null;

        const rateResult = await mySqlQury(
          `SELECT rate FROM tbl_vendor_rates WHERE zone_origin = ? AND zone_destination = ? AND vendor_id = ?`,
          [originZone, destinationZone, forwarderId]
        );

        const tatResult = await mySqlQury(
          `SELECT days FROM tbl_tat_${forwarderId} WHERE zone_origin = ? AND zone_destination = ?`,
          [originZone, destinationZone]
        );

        if (rateResult.length && tatResult.length) {
          const rate = rateResult[0].rate;
          tat = tatResult[0].days;

          const additionalCharges = await calculateAdditionalChargesForwarder(
            forwarderId,
            total_weight,
            total_boxes,
            payment_type,
            rate,
            invoice_amount
          );

          totalRate = rate + additionalCharges;
        }
      } else if (serviceType === 'standard') {
        // Fetch standard zones and rates
        let originZone = null;

        const zoneResult = await mySqlQury(
          `SELECT zone FROM tbl_standard_zone_map 
               WHERE vendor_id = ? AND rule = 'WITHIN-NCR' AND city = ?`,
          [forwarderId, originCity]
        );

        if (zoneResult.length) {
          originZone = zoneResult[0].zone;
        } else if (originCity === destinationCity) {
          const cityZoneResult = await mySqlQury(
            `SELECT zone FROM tbl_standard_zone_map WHERE vendor_id = ? AND rule = 'WITHIN-CITY'`,
            [forwarderId]
          );
          originZone = cityZoneResult.length ? cityZoneResult[0].zone : null;
        }

        if (!originZone) {
          const roiZoneResult = await mySqlQury(
            `SELECT zone FROM tbl_standard_zone_map WHERE vendor_id = ? AND rule = 'WITHIN-ROI'`,
            [forwarderId]
          );
          originZone = roiZoneResult.length ? roiZoneResult[0].zone : null;
        }
        const rate = await findRateForwarder(forwarderId, originZone, total_weight);
        const tatResult = await mySqlQury(
          `SELECT days FROM tbl_standard_tat WHERE zone = ? AND vendor_id = ?`,
          [originZone, forwarderId]
        );

        if (tatResult.length) {
          tat = tatResult[0].days;

          const additionalCharges = await calculateAdditionalChargesForwarder(
            forwarderId,
            total_weight,
            total_boxes,
            payment_type,
            rate,
            invoice_amount
          );

          totalRate = rate + additionalCharges;
        }
      }

      if (totalRate !== null && tat !== null) {
        if (totalRate < lowestRate) {
          lowestRate = totalRate;
          selectedForwarder = { forwarderId, totalRate, tat, taggedApi };
        }

        rates.push({
          forwarderId,
          totalRate,
          tat,
        });
      }
    }

    if (!selectedForwarder) {
      return res.status(404).json({ error: 'No suitable forwarder found.' });
    }

    // Send response with the best forwarder and all rates
    res.json({
      selectedForwarder,
      taggedApi: selectedForwarder.taggedApi,
      rates,
    });
  } catch (error) {
    console.error('Error processing forwarder details:', error);
    res.status(500).json({ error: 'Internal server error.' });
  }
}
const apiBulkForwardingPartners = async (req, res) => {
  try {
    const { orders } = req.body; // Accept orders in the request body
    console.log("Request body data", { orders });

    // Validate that orders is an array and has at least one order
    if (!Array.isArray(orders) || orders.length === 0) {
      return res.status(400).json({ error: 'At least one order is required' });
    }

    // Initialize an array to hold results for all orders
    let allRates = [];

    // Iterate over each order
    for (const order of orders) {
      const {
        po_no,
        invoice_amount,
        total_boxes,
        payment_type,
        destination_pincode,
        origin_pincode,
        client_id,
        total_weight,
        type
      } = order;

      // Validate order parameters
      if (!client_id || !origin_pincode || !destination_pincode || !total_weight || !total_boxes || !payment_type) {
        return res.status(400).json({ error: 'Client ID, Origin Pincode, Destination Pincode, total weight, total boxes, and payment type are required for each order' });
      }

      // Fetch city and state details for pickup and destination
      const originPincodeDetails = await mySqlQury(
        `SELECT city, state, Zone FROM tbl_master_pincode WHERE pincode = ?`,
        [origin_pincode]
      );
      const destinationPincodeDetails = await mySqlQury(
        `SELECT city, state, Zone FROM tbl_master_pincode WHERE pincode = ?`,
        [destination_pincode]
      );

      if (!originPincodeDetails.length || !destinationPincodeDetails.length) {
        return res.status(404).json({ error: 'One or both pincodes not found in tbl_master_pincode' });
      }

      const originCity = originPincodeDetails[0].city;
      const originState = originPincodeDetails[0].state;
      const originZone = originPincodeDetails[0].Zone;
      const destinationCity = destinationPincodeDetails[0].city;
      const destinationState = destinationPincodeDetails[0].state;
      const destinationZone = destinationPincodeDetails[0].Zone;

      // Fetch forwarding partners based on client_id
      const forwardingPartners = await mySqlQury(
        `SELECT c.id, c.Aggrigator_id, c.name, c.service_type, c.category, c.tagged_api, c.tagged_logo, a.dispatch_agg, a.binded_with_forwarder, a.aggrigator_type
             FROM tbl_client_aggrigator c
             JOIN tbl_aggrigator a ON c.Aggrigator_id = a.id
             WHERE c.client_id = ?`,
        [client_id]
      );
      console.log("check forwarding partners", forwardingPartners)

      if (!forwardingPartners.length) {
        return res.status(404).json({ error: 'No forwarding partners found for the provided client ID.' });
      }

      let rates = [];
      let aggrigatordetils = [];


      for (const partner of forwardingPartners) {
        let aggrigatorid = null;
        let aggregatorTotalRate = null;
        let aggregatorTat = null;
        let taggedApiAggrigator = null;
        let taggedAggrigatorLogo = null;
        let aggrigatorCategory = null;
        let aggrigatorserviseType = null;

        console.log("partner calculation: " + partner.tagged_api)
        taggedApiAggrigator = partner.tagged_api
        aggrigatorid = forwardingPartners[0].Aggrigator_id;
        console.log("aggregator: " + aggrigatorid)
        taggedAggrigatorLogo = partner.tagged_logo
        aggrigatorCategory = partner.category;
        aggrigatorserviseType = partner.service_type;
        // let aggregatorTotalRate = null; // To store the aggregator's total rate
        // let aggregatorTat = null; // To store the aggregator's TAT
        let originZone = null;
        let standardTATResult = null;
        const forwarderTable = `tbl_zone_mapping_aggrigator_${partner.Aggrigator_id}`;
        const tatTable = `tbl_TAT_Aggrigator_${partner.Aggrigator_id}`;
        console.log("tables ", forwarderTable, tatTable);


        // Check if the partner is bound with a forwarder
        if (partner.binded_with_forwarder === 2 || partner.binded_with_forwarder === 1) {
          console.log("Processing partner:", partner);
          let totalRate = null;
          let tat = null;

          // Fetch the Forwarder_id, tagged_api, and service_type for each partner
          const forwarderDetails = await mySqlQury(
            `SELECT Forwarder_id, tagged_api, service_type FROM tbl_aggrigator_forwarder WHERE Aggrigator_id = ?`,
            [partner.Aggrigator_id]
          );

          if (forwarderDetails.length) {
            let lowestRate = Infinity; // Initialize to a high value for comparison
            let selectedForwarderId = null;
            let taggedApi = null;

            // Loop through the forwarders to calculate Totalrate and find the one with the lowest Totalrate
            for (const forwarder of forwarderDetails) {
              console.log("Forwarder details:", forwarder);
              const forwarderId = forwarder.Forwarder_id;
              const forwarderTaggedApi = forwarder.tagged_api; // Get the tagged_api for this forwarder
              const serviceType = forwarder.service_type; // Determine the service type let totalRate = null;
              let tat = null;

              if (serviceType === "LTL") {
                console.log("Processing LTL for forwarder:", forwarderId);
                // LTL case
                const pickupZoneQuery = `SELECT Zone FROM tbl_zone_mapping_${forwarderId} WHERE City = ? OR State = ?`;
                const destinationZoneQuery = `SELECT Zone FROM tbl_zone_mapping_${forwarderId} WHERE City = ? OR State = ?`;

                // Fetch zones for pickup and destination
                const pickupZoneResult = await mySqlQury(pickupZoneQuery, [originCity, originState]);
                const destinationZoneResult = await mySqlQury(destinationZoneQuery, [destinationCity, destinationState]);

                const originZone = pickupZoneResult.length > 0 ? pickupZoneResult[0].Zone : null;
                const destinationZone = destinationZoneResult.length > 0 ? destinationZoneResult[0].Zone : null;

                // Fetch rate and TAT for LTL
                const rateResult = await mySqlQury(
                  `SELECT rate FROM tbl_vendor_rates WHERE zone_origin = ? AND zone_destination = ? AND vendor_id = ?`,
                  [originZone, destinationZone, forwarderId]
                );
                const tatResult = await mySqlQury(
                  `SELECT days FROM tbl_tat_${forwarderId} WHERE zone_origin = ? AND zone_destination = ?`,
                  [originZone, destinationZone]
                );

                if (rateResult.length && tatResult.length) {
                  const rate = rateResult[0].rate;
                  tat = tatResult[0].days;

                  // Calculate additional charges
                  const additionalCharges = await calculateAdditionalChargesForwarder(
                    forwarderId,
                    total_weight,
                    total_boxes,
                    payment_type,
                    rate,
                    invoice_amount
                  );

                  // Calculate total rate
                  totalRate = rate + additionalCharges;
                }
              } else if (serviceType === "standard") {

                console.log("Processing standard for forwarder:", forwarderId);
                // Standard case: Check various rules to determine the origin zone
                let originZone = null;

                let zoneResult = await mySqlQury(
                  `SELECT zone FROM tbl_standard_zone_map WHERE vendor_id = ? AND rule = 'WITHIN-NCR' AND city = ? AND city = ?`,
                  [forwarderId, originCity, destinationCity]
                );

                originZone = zoneResult.length > 0 ? zoneResult[0].zone : null;

                if (!originZone && pickupCity === destinationCity) {
                  zoneResult = await mySqlQury(
                    `SELECT zone 
                         FROM tbl_standard_zone_map 
                         WHERE vendor_id = ? 
                           AND rule = 'WITHIN-CITY'`,
                    [forwarderId]
                  );
                  originZone = zoneResult.length > 0 ? zoneResult[0].zone : null;
                  console.log("origin zone from WITHIN-CITY: ", originZone);
                }

                // Step 3: If still no zone found, check 'WITHIN-ZONE' rule using pickupZone and destinationZone
                if (!originZone && pickupZone === destinationZone) {
                  zoneResult = await mySqlQury(
                    `SELECT zone 
                         FROM tbl_standard_zone_map 
                         WHERE vendor_id = ? 
                           AND rule = 'WITHIN-ZONE'`,
                    [forwarderId]
                  );
                  originZone = zoneResult.length > 0 ? zoneResult[0].zone : null;
                  console.log("origin zone from WITHIN-ZONE: ", originZone);
                }

                // Step 4: If still no zone found, check 'WITHIN-METRO' rule using destinationCity
                if (!originZone) {
                  zoneResult = await mySqlQury(
                    `SELECT zone 
                         FROM tbl_standard_zone_map 
                         WHERE vendor_id = ? 
                           AND rule = 'WITHIN-METRO' 
                           AND city = ?`,
                    [forwarderId, destinationCity]
                  );
                  originZone = zoneResult.length > 0 ? zoneResult[0].zone : null;
                  console.log("origin zone from WITHIN-METRO: ", originZone);
                }

                // Step 5: If still no zone found, check 'WITHIN-SPECIAL-ZONE' using pickupState or destinationState
                if (!originZone) {
                  zoneResult = await mySqlQury(
                    `SELECT zone 
                         FROM tbl_standard_zone_map 
                         WHERE vendor_id = ? 
                           AND rule = 'WITHIN-SPECIAL-ZONE' 
                           AND (state = ? OR state = ?)`,
                    [forwarderId, pickupState, destinationState]
                  );
                  originZone = zoneResult.length > 0 ? zoneResult[0].zone : null;
                  console.log("origin zone from WITHIN-SPECIAL-ZONE: ", originZone);
                }

                // Step 6: If still no zone found, check 'WITHIN-ROI' rule
                if (!originZone) {
                  zoneResult = await mySqlQury(
                    `SELECT zone 
                         FROM tbl_standard_zone_map 
                         WHERE vendor_id = ? 
                           AND rule = 'WITHIN-ROI'`,
                    [forwarderId]
                  );
                  originZone = zoneResult.length > 0 ? zoneResult[0].zone : null;
                  console.log("origin zone from WITHIN-ROI: ", originZone);
                }
                // console.log("origin zone from WITHIN-ROI: ", originZone.split(' ')[1]);
                console.log("origin zone from WITHIN-ROI: ", originZone, forwarderId)

                const rate = await findRateForwarder(forwarderId, originZone, total_weight);
                const standardTATResult = await mySqlQury(
                  `SELECT days FROM tbl_standard_tat WHERE zone = ? AND vendor_id = ?`,
                  [originZone, forwarderId]
                );

                if (standardTATResult.length) {
                  tat = standardTATResult[0].days;

                  // Calculate additional charges
                  const additionalCharges = await calculateAdditionalChargesForwarder(
                    forwarderId,
                    total_weight,
                    total_boxes,
                    payment_type,
                    rate,
                    invoice_amount
                  );

                  // Calculate total rate
                  totalRate = rate + additionalCharges;
                }
              }

              // Compare and select the forwarder with the lowest rate
              if (totalRate !== null && tat !== null) {
                if (totalRate < lowestRate) {
                  lowestRate = totalRate;
                  selectedForwarderId = forwarderId;
                  taggedApi = forwarderTaggedApi; // Update taggedApi with the forwarder's tagged_api
                }

                // Push forwarder details to the result array
                rates.push({
                  forwarderId: forwarderId,
                  Totalrate: totalRate,
                  tat: tat, // Add TAT details
                });
              }
            }
            console.log("Lowest rate found:", lowestRate, "for forwarder ID:", selectedForwarderId);
          }
        } else {
          console.log(" nothing");
        }
        if (partner.service_type === "LTL") {
          console.log("in the case of servise type ltl")
          // Fetch zone details for both pickup and destination for LTL shipments
          const pickupZoneDetails = await mySqlQury(
            `SELECT zone FROM ?? WHERE city = ? OR state = ?`,
            [forwarderTable, originCity, originState]
          );

          const destinationZoneDetails = await mySqlQury(
            `SELECT zone FROM ?? WHERE city = ? OR state = ?`,
            [forwarderTable, destinationCity, destinationState]
          );

          console.log("pickupZone", pickupZoneDetails, destinationZoneDetails);

          if (pickupZoneDetails.length && destinationZoneDetails.length) {
            // LTL Shipment Handling
            const rateDetails = await mySqlQury(
              `SELECT rate FROM tbl_client_rates 
                     WHERE Aggrigator_id = ? 
                     AND zone_origin = ? 
                     AND zone_destination = ?`,
              [
                partner.Aggrigator_id,
                pickupZoneDetails[0].zone,
                destinationZoneDetails[0].zone,
              ]
            );
            console.log("shabbar ansari", rateDetails);

            // Fetch TAT days from the TAT table for LTL
            const tatDetails = await mySqlQury(
              `SELECT days FROM ?? 
                     WHERE Aggrigator_id = ? 
                     AND zone_origin = ? 
                     AND zone_destination = ?`,
              [
                tatTable,
                partner.Aggrigator_id,
                pickupZoneDetails[0].zone,
                destinationZoneDetails[0].zone
              ]
            );
            console.log("tat details", tatDetails);

            if (tatDetails.length) {
              // Calculate additional charge and apply to base rate
              const additionalCharge = await calculateAdditionalCharges(
                partner.Aggrigator_id,
                total_weight,
                total_boxes,
                payment_type,
                rateDetails[0].rate,
                invoice_amount
              );

              const totalRate = rateDetails[0].rate + additionalCharge;
              aggregatorTotalRate = totalRate;
              aggregatorTat = tatDetails[0].days;
              console.log("Aggregator LTL total rate", aggregatorTotalRate);
              console.log("Aggregator LTL TAT", aggregatorTat);
            }
          }


        } else {
          // Handle standard case (WITHIN-NCR and WITHIN-CITY)
          console.log("Pickup zone in standard case", pickupZone, destinationZone);

          let zoneResult = await mySqlQury(
            `SELECT zone 
                 FROM tbl_std_agg_zone_map 
                 WHERE aggrigator_id = ? 
                   AND rule = 'WITHIN-NCR' 
                   AND city = ? AND city = ?`,
            [partner.Aggrigator_id, pickupCity, destinationCity]
          );

          originZone = zoneResult.length > 0 ? zoneResult[0].zone : null;
          console.log("Origin zone from WITHIN-NCR:", originZone);

          if (!originZone && pickupCity === destinationCity) {
            zoneResult = await mySqlQury(
              `SELECT zone 
                   FROM tbl_std_agg_zone_map 
                   WHERE aggrigator_id = ? 
                     AND rule = 'WITHIN-CITY'`,
              [partner.Aggrigator_id]
            );
            originZone = zoneResult.length > 0 ? zoneResult[0].zone : null;
            console.log("origin zone from WITHIN-CITY: ", originZone);
          }

          // Step 3: If still no zone found, check 'WITHIN-ZONE' rule using pickupZone and destinationZone
          if (!originZone && pickupZone === destinationZone) {
            zoneResult = await mySqlQury(
              `SELECT zone 
                   FROM tbl_std_agg_zone_map 
                   WHERE aggrigator_id = ? 
                     AND rule = 'WITHIN-ZONE'`,
              [partner.Aggrigator_id]
            );
            originZone = zoneResult.length > 0 ? zoneResult[0].zone : null;
            console.log("origin zone from WITHIN-ZONE: ", originZone);
          }

          // Step 4: If still no zone found, check 'WITHIN-METRO' rule using destinationCity
          if (!originZone) {
            zoneResult = await mySqlQury(
              `SELECT zone 
                   FROM tbl_std_agg_zone_map 
                   WHERE aggrigator_id = ? 
                     AND rule = 'WITHIN-METRO' 
                     AND city = ?`,
              [partner.Aggrigator_id, destinationCity]
            );
            originZone = zoneResult.length > 0 ? zoneResult[0].zone : null;
            console.log("origin zone from WITHIN-METRO: ", originZone);
          }

          // Step 5: If still no zone found, check 'WITHIN-SPECIAL-ZONE' using pickupState or destinationState
          if (!originZone) {
            zoneResult = await mySqlQury(
              `SELECT zone 
                   FROM tbl_std_agg_zone_map 
                   WHERE aggrigator_id = ? 
                     AND rule = 'WITHIN-SPECIAL-ZONE' 
                     AND (state = ? OR state = ?)`,
              [partner.Aggrigator_id, pickupState, destinationState]
            );
            originZone = zoneResult.length > 0 ? zoneResult[0].zone : null;
            console.log("origin zone from WITHIN-SPECIAL-ZONE: ", originZone);
          }

          // Step 6: If still no zone found, check 'WITHIN-ROI' rule
          if (!originZone) {
            zoneResult = await mySqlQury(
              `SELECT zone 
                   FROM tbl_std_agg_zone_map 
                   WHERE aggrigator_id = ? 
                     AND rule = 'WITHIN-ROI'`,
              [partner.Aggrigator_id]
            );
            originZone = zoneResult.length > 0 ? zoneResult[0].zone : null;
            console.log("origin zone from WITHIN-ROI: ", originZone);
          }

          // If no zone is found after all checks
          if (!originZone) {
            console.log("No origin zone found for standard service");
            rates.push({
              forwarder: partner.name,
              rate: null,
              Aggrigator_id: partner.Aggrigator_id,
              message: 'No valid zone found for shipment'
            });
            return;
          }

          if (originZone) {
            // Fetch rate and TAT based on the zone
            aggregatorTotalRate = await findRateAggrigator(partner.Aggrigator_id, originZone, total_weight);
            console.log("Aggregator standard rate", aggregatorTotalRate);

            standardTATResult = await mySqlQury(
              `SELECT days 
                   FROM tbl_std_agg_tat 
                   WHERE zone = ? AND aggrigator_id = ?`,
              [originZone, partner.Aggrigator_id]
            );
            aggregatorTat = standardTATResult.length ? standardTATResult[0].days : null;
            console.log("Aggregator standard TAT", aggregatorTat);
          }
        }
        aggrigatordetils.push({
          aggrigator: aggrigatorid,
          aggregatorTotalRate,
          aggregatorTat,
          taggedApiAggrigator,
          taggedAggrigatorLogo,
          aggrigatorCategory,
          aggrigatorserviseType
        })


        // from here i want to calculation of aggrigator rate and tat of aggrigator from table like this 
      }
      allRates.push({
        aggrigatordetils,
        po_no,
        rates,

        // Include aggregator's TAT for all partners
      });
    }
    console.log("All rates found:", allRates)

    res.status(200).json({ allRates });
  } catch (error) {
    console.error("Error processing bulk forwarding partners:", error);
    return res.status(500).json({ error: 'An error occurred while processing the request' });
  }
}
const getUnprocessedOrderDetails = async (req, res, next) => {
  try {
    console.log("Loading the unprocessed order details route");

    const { po_no } = req.query; // Get the po_no from query parameters
    // console.log("PO Number received:", po_no);

    // Define the queries
    let sql1 = 'SELECT * FROM tbl_unprocessed_order WHERE is_unprocessesd = 1';
    // let sql2 = 'SELECT * FROM tbl_boxes_dimension WHERE is_unprocessesd = 1';
    let sql2 = 'SELECT * FROM tbl_boxes_dimension';
    let sql3 = 'SELECT * FROM tbl_products';
    const queryParams = [];

    // Add filters if po_no is provided
    if (po_no) {
      sql1 += ' AND po_no = ?';
      sql2 += ' WHERE po_no = ?';
      sql3 += ' WHERE po_no = ?';
      queryParams.push(po_no);
    }

    // Fetch dispatch LR
    const dispatchLr = await mySqlQury(
      'SELECT ds_docket_no FROM tbl_dispatch_lr WHERE po_no = ?',
      [po_no]
    );
    const docketDispatch = dispatchLr.length ? dispatchLr[0].ds_docket_no : null;
    // console.log("Dispatch LR:", docketDispatch);

    // Execute queries concurrently
    const [result1, result2, result3] = await Promise.all([
      mySqlQury(sql1, queryParams),
      mySqlQury(sql2, queryParams),
      mySqlQury(sql3, queryParams),
    ]);

    // console.log("Unprocessed Orders:", result1);
    // console.log("Box Dimensions:", result2);
    // console.log("Products:", result3);

    // Validate results before accessing their properties
    if (!result1.length) {
      return res.status(404).json({ error: "No unprocessed orders found." });
    }

    const aggrigatorOrForwarder = result1[0]?.client_id || null;

    // Fetch additional data
    const clientName =
      aggrigatorOrForwarder &&
      (await mySqlQury(
        'SELECT company_name, gst FROM tbl_admin WHERE id = ?',
        [aggrigatorOrForwarder]
      ));

    const clientRelations =
      aggrigatorOrForwarder &&
      (await mySqlQury(
        `
            SELECT a.*
            FROM tbl_client_aggrigator ca
            JOIN tbl_aggrigator a ON a.id = ca.Aggrigator_id
            WHERE ca.client_id = ? AND a.Status = 1
            `,
        [aggrigatorOrForwarder]
      ));

    // Determine client ID based on role
    let clientId = req.user.id === 1 ? result1[0]?.client_id : req.user.id;

    const clients = await mySqlQury(
      'SELECT * FROM tbl_customers WHERE client_id = ?',
      [clientId]
    );

    // Respond with combined data
    res.status(200).json({
      unprocessedOrders: result1,
      boxDimensions: result2,
      products: result3,
      clients,
      clientRelations: clientRelations || [],
      clientName: clientName || [],
      docketDispatch,
    });
  } catch (error) {
    console.error("Error fetching unprocessed orders:", error);
    res.status(500).json({ message: 'Internal Server Error', error: error.message });
  }
} 
const apiCalculateExpressRate =  async (req, res) => {
  try {
    const role_data = req.user;
    console.log("here in the express-rate")
   
    const { type, pickupPincode, destinationPincode,total_weight,total_boxes,paymentType,clientBaseValue,boxDimensions,cod,weight_unit } = req.query;
    // console.log("client id ",clientId)
    console.log("collectable amount as cod and the clientbasevalue",cod,clientBaseValue)
    // console.log("dhsdjhsdfjs",dsjdgsd)
    let clientId = req.query.clientId ?? req.user.selectedClientId;
    console.log("req params data in calci",type,clientId,pickupPincode,destinationPincode,total_weight,total_boxes,paymentType,clientBaseValue,weight_unit)
      //  console.log("dhsdjhsdfjs",dsjdgsd)
    if (!clientId || !pickupPincode || !destinationPincode) {
      return res.status(400).json({ error: 'Client ID, Pickup Pincode, Destination Pincode, and Forwarder Type are required' });
    }
    console.log("client list",clientId)
   
    const pickupPincodeDetails = await mySqlQury(
      `SELECT city, state,Zone FROM tbl_master_pincode WHERE pincode = ?`,
      [pickupPincode]
    );
    const destinationPincodeDetails = await mySqlQury(
      `SELECT city, state,Zone FROM tbl_master_pincode WHERE pincode = ?`,
      [destinationPincode]
    );

    if (!pickupPincodeDetails.length || !destinationPincodeDetails.length) {
      return res.status(404).json({ error: 'One or both pincodes not found in tbl_master_pincode' });
    }

    const pickupCity = pickupPincodeDetails[0].city;
    const pickupState = pickupPincodeDetails[0].state;
    let pickupZone = pickupPincodeDetails[0].Zone;
    const destinationCity = destinationPincodeDetails[0].city;
    const destinationState = destinationPincodeDetails[0].state;
    let destinationZone = destinationPincodeDetails[0].Zone;
    let zoneType = '';
    console.log("pickup zone and destination zone", destinationZone,pickupZone,destinationPincodeDetails,pickupPincodeDetails)
    const [checkBusinessCode] = await mySqlQury(`select exp_volume FROM tbl_admin WHERE id=?`,[clientId]);
    console.log("check businessCode",checkBusinessCode)
    

    
      // If exp_volume is 0 or null, use the current logic (no business_volume filter)
      // For COD payments, exclude DTDC courier
      const logisticsPartners = await mySqlQury(
        `SELECT 
            lp.id AS Aggrigator_id, 
            lp.name, 
            lp.tagged_api, 
            lp.volumetric_factor
         FROM tbl_client_lp clp
         JOIN tbl_logistics_partner lp ON clp.logictics_partner_id = lp.id
         JOIN tbl_courier_details cd ON lp.courier_id = cd.id
         WHERE 
           clp.client_id = ? 
           AND clp.status = 1 
           AND clp.disable_by_superadmin = 0
           AND LOWER(cd.courier_type) = 'express'
           ${paymentType?.toLowerCase() === 'cod' ? "AND UPPER(cd.Tagged_api) != 'DTDC'" : ''}`,
        [clientId]
      );


    if (!logisticsPartners.length) {
      return res.status(404).json({ error: 'No logistics/aggrigator partners found for the provided client ID and service type.' });
    }
    console.log("logistics/aggrigator partners",logisticsPartners)

    let rates = [] ;
    let forwarderTotalRateAndDetails = []; //this is for the forwarder rate and details or  courierrate details

    for (const partner of logisticsPartners) {
      console.log(`\nðŸ”„ Processing partner: ${partner.name} (${partner.tagged_api})`);
      console.log(`   Partner ID: ${partner.Aggrigator_id}`);
      console.log(`   Tagged API: ${partner.tagged_api}`);
    
     
      let selectedForwarderId = null;
      let lowestRate = Infinity;
      let selectedForwarderDetails = null;
      let volumetricWeight=null;

      let forwarder_service_id = null;
      let originZone = null;
      let maxWeightForwarder = 0;
      let tatDays = 0;
      let delhiveryApiVariant = 0;
      let minSlab = null;
      let maxSlab = null;
      const forwarderDetails = await mySqlQury(
        `SELECT
            lp.courier_id AS Forwarder_id,
            lp.tagged_api,
            cd.service_type,
            cd.service_type AS forwarder_service_type,
            cd.delhivery_api_variant,
            cd.volumetric_factor,
            expws.min_weight,
            expws.max_weight
         FROM tbl_logistics_partner lp
         LEFT JOIN tbl_courier_details cd ON lp.courier_id = cd.id
         LEFT JOIN tbl_exp_weightslabs expws ON lp.courier_id =expws.courier_id
         WHERE lp.id = ?`,
        [partner.Aggrigator_id]
      );
    
        console.log("Forwarder Details in volumetric data details:", forwarderDetails);
      
        if (forwarderDetails.length) {
          let forwarderSuccess = false; // Add this flag to track success
          
          for (const forwarder of forwarderDetails) {
            console.log("forwarder details in the --2 and the ",forwarder.Forwarder_id,forwarder.service_type)
            let forwarderId = null;
            let forwarderTaggedApi = forwarder.tagged_api;
            let serviceType = forwarder.service_type;
            let totalRate = null;
            let tat = null;
            let forwarderServiceId = forwarder.forwarder_service_type;
            delhiveryApiVariant = forwarder.delhivery_api_variant;
            minSlab = forwarder.min_weight;
            maxSlab = forwarder.max_weight;
            

      
           
              console.log("in standard mode in forwarder",forwarderTaggedApi)
              if (['xpressbees', 'delhivery'].includes(forwarderTaggedApi.toLowerCase())) {
                console.log(`ðŸ” Checking serviceability for ${forwarderTaggedApi}...`);
                const isServiceable = await checkServiceability(
                  forwarderTaggedApi,
                  pickupPincode,
                  destinationPincode,
                  total_weight,
                  paymentType,
                  clientBaseValue,
                  weight_unit
                );
            
                if (!isServiceable) {
                  console.log(`âŒ ${forwarderTaggedApi} - Route is NOT serviceable`);
                  continue; // Skip to next forwarder
                }
                else {
                  console.log(`âœ… ${forwarderTaggedApi} - Route IS serviceable, proceeding with rate calculation`);
                }
              }
              forwarderId =  forwarder.Forwarder_id
             forwarderTaggedApi = forwarder.tagged_api
             serviceType = forwarder.service_type;
              console.log("forwarder details in the --2 in the standard", pickupCity, destinationCity, partner.Aggrigator_id);
              
              originZone = await determineForwarderOriginZone(
                forwarderId,
                pickupCity,
                destinationCity,
                pickupState,
                destinationState,
                pickupZone,
                destinationZone
              );
              switch(originZone) {
                case 'A':
                  zoneType = 'WITHIN NCR';
                  break;
                case 'B':
                  zoneType = 'WITHIN CITY';
                  break;
                case 'C':
                  zoneType = 'WITHIN-STATE';
                  break;
                case 'D':
                  zoneType = 'WITHIN-ZONE';
                  break;
                case 'E':
                  zoneType = 'WITHIN-METRO';
                  break;
                case 'F':
                  zoneType = 'WITHIN-SPECIAL ZONE';
                  break;
                case 'G':
                  zoneType = 'ROI';
                  break;
                default:
                  zoneType = originZone; // fallback to original value
              }

              
              console.log("Origin zone determined for forwarder:", originZone, forwarderId, forwarder.company_name);
              console.log("origin zone in the forwarder",originZone)
              // console.log("djghs",djghs)
              
              if (originZone) {
                forwarderSuccess = true; // Mark that at least one forwarder succeeded
                // First calculate volumetric weight to compare with actual weight
                console.log("weight_unit",weight_unit,total_weight)
                const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);
                console.log("converted weight in kg:", weightInKg);
                
                const totalVolumetricWeight = await calculateVolumetricWeight(boxDimensions, partner.volumetric_factor);
                console.log("total volumetric weight in std forwarder:", totalVolumetricWeight);
                
                // Determine the higher weight between actual and volumetric
                const higherWeight = Math.max(weightInKg, totalVolumetricWeight);
                console.log("higher weight between actual and volumetric:", higherWeight);
                
                // Convert to grams for API call
                const weightInGrams = higherWeight * 1000;
                console.log("weight in grams for rate calculation:", weightInGrams);
                
                // Get rate based on the higher weight
                const {rate, maxWeight} = await findRateForwarder(forwarderId, originZone, weightInGrams);
                console.log("forwarder rate:", rate);
                console.log("forwarder max weight:", maxWeight);
                maxWeightForwarder = maxWeight
            
                const standardTATResult = await mySqlQury(
                  `SELECT days
                   FROM tbl_exp_tat
                   WHERE zone = ? AND courier_id = ?`,
                  [originZone, forwarderId]
                );
            
                if (standardTATResult.length) {
                  console.log("rate calculator in the api in rate.length", rate);
                  tat = standardTATResult[0].days;
                  tatDays = tat;
                  console.log("TAT of forwarder:", tat);
                  
                  // Calculate base value using the rate
                  const base_value = Number(rate);
                  console.log("Base Value in std forwarder:", base_value);
          
                  const additionalChargesResult = await calculateAdditionalChargesForwarder(
                    forwarderId,
                    weightInKg,
                    total_boxes,
                    paymentType,
                    rate,
                    base_value,
                    clientBaseValue,
                    cod
                  );
                  console.log("Additional charges in forwarder:", additionalChargesResult);
                  
                  // Use totalCharge from the result object for rate calculation
                  totalRate = Number(rate) + Number(additionalChargesResult.totalCharge);
                  
                  if (totalRate < lowestRate) {
                    lowestRate = totalRate;
                    selectedForwarderId = forwarderId;
                    taggedApi = forwarderTaggedApi;
                    forwarder_service_id = forwarderServiceId;
                  }
                  
                  forwarderTotalRateAndDetails.push({
                    forwarderId: forwarderId,
                    baserate:Number(rate),
                    Totalrate: totalRate,
                    tat: tat,
                    taggedApi: forwarderTaggedApi,
                    additionalCharges: {
                      total: additionalChargesResult.totalCharge,
                      breakdown: additionalChargesResult.chargesBreakdown
                    },
                    minSlab,
                    maxSlab
                  });
                  selectedForwarderDetails = forwarderTotalRateAndDetails.find(detail => detail.forwarderId === selectedForwarderId);
                }
              } else {
                console.log("No origin zone found for this forwarder");
              }
            
          }
          
          // Only proceed to aggregator if no forwarder succeeded
          if (!forwarderSuccess) {
            console.log("No forwarder succeeded, proceeding to aggregator calculation");
            
            // Reset originZone to use pickupZone for aggregator calculation
            originZone = pickupZone;
            console.log("Using pickupZone for aggregator:", originZone);
          }
        }
      
      
      try {
        let chargableWeight = 0;
       
      
          console.log("pickup zone in the else in standard", pickupZone, destinationZone);
      
         
          
          // If no zone is found after all checks
          if (!originZone) {
            console.log("No origin zone found for standard service");
            rates.push({
              forwarder: partner.name,
              rate: null,
              Aggrigator_id: partner.Aggrigator_id,
              message: 'No valid zone found for shipment'
            });
            continue;
          }
          
          // Continue with the rest of your code using the determined originZone
          console.log("Origin zone found: ", originZone);
      
          console.log("origin zone found: ", originZone);
          console.log("weight unit",weight_unit)
          // First calculate volumetric weight to compare with actual weight
          const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);
          console.log("converted weight in kg:", weightInKg);
          
          const totalVolumetricWeight = await calculateVolumetricWeight(boxDimensions, partner.volumetric_factor);
          console.log("total volumetric weight in ecom ", totalVolumetricWeight);
          
          // Determine the higher weight between actual and volumetric
          const higherWeight = Math.max(weightInKg, totalVolumetricWeight);
          chargableWeight = higherWeight;
          volumetricWeight=totalVolumetricWeight;
          console.log("higher weight between actual and volumetric:in ecom", higherWeight);
          
          // Convert to grams for API call
          const weightInGrams = higherWeight * 1000;
          console.log("weight in grams for rate calculation: in ecom", weightInGrams);
          
          // Get rate based on the higher weight
          const {rate, maxWeight} = await findRateAggrigator(partner.Aggrigator_id, originZone, weightInGrams,maxWeightForwarder);
          console.log("aggrigator rate: in ecom", rate);
          console.log("aggrigator max weight: in ecom", maxWeight);
      
         
      
          if (tatDays) {
            
            
            
    
            // Calculate base value using the rate from findRateAggrigator
            const base_value = Number(rate);
            console.log("Base Value in std aggrigator:", base_value);
    
            const additionalChargesResult = await calculateAdditionalCharges(
              partner.Aggrigator_id,
              weightInKg,
              total_boxes,
              paymentType,
              rate,
              base_value,
              clientBaseValue,
              cod
            );
            
            console.log("here in the additional charges ", rate, additionalChargesResult.totalCharge);
            
            const totalRate = Number(rate) + Number(additionalChargesResult.totalCharge);
            
            rates.push({
              Aggrigator: partner.name,
              
              rate: totalRate,
              baserate: Number(rate),
              forwarderTotalRateAndDetails: selectedForwarderDetails,
              days: tatDays,
              additionalCharges: {
                total: additionalChargesResult.totalCharge,
                breakdown: additionalChargesResult.chargesBreakdown || []
              },
              TaggedApi: taggedApi,
              forwarderServiceType: forwarder_service_id,
              weight_unit: 'gm',
              Aggrigator_id: partner.Aggrigator_id,
              chargableWeight: chargableWeight,
              volumetricWeight: volumetricWeight,
              zones: {
                origin: pickupZone,
                destination: destinationZone,
                zoneType: zoneType
              },
              shipmentType: 'Standard',
              delhiveryApiVariant,
              minSlab,
              maxSlab
            });
          } else {
            rates.push({
              forwarder: partner.name,
              rate: null,
              Aggrigator_id: partner.Aggrigator_id,
              message: 'No standard rate found'
            });
          }
       
      
      } catch (error) {
        console.error('Error fetching forwarding partners:', error);
      }
      
      // Log final status for this partner
      const partnerRates = rates.filter(rate => rate.Aggrigator_id === partner.Aggrigator_id);
      const hasSuccessfulRates = partnerRates.some(rate => rate.rate !== null);
      console.log(`   ðŸ“Š Partner ${partner.name} final status: ${hasSuccessfulRates ? 'âœ… HAS rates' : 'âŒ NO rates'}`);
      if (partnerRates.length > 0) {
        console.log(`   ðŸ“‹ Partner rates found: ${partnerRates.length}`);
      }
      
    }
    
    console.log("rate length", rates.length);
    
    // Log token cache efficiency for Xpressbees
    const fetchExpressBeesToken = require('../services/fetchExpressBeesToken.js');
    const cacheStatus = fetchExpressBeesToken.getXpressbeesTokenCacheStatus();
    console.log("ðŸ”‘ Xpressbees Token Cache Status:", cacheStatus);

    // REFINED LOGIC: Check if we should return "no courier serviceable" response
    // Only return this response when ALL logistics partners are ONLY Xpressbees and Delhivery AND ALL are unserviceable
    // If DTDC or any other partner is present, DON'T return this response
    
    // Check if there are any partners OTHER than Xpressbees and Delhivery (like DTDC)
    const hasOtherPartners = logisticsPartners.some(partner => 
      !['delhivery', 'xpressbees'].includes(partner.tagged_api.toLowerCase())
    );
    
    // Get only Xpressbees and Delhivery partners
    const delhiveryXpressbeesPartners = logisticsPartners.filter(partner => 
      ['delhivery', 'xpressbees'].includes(partner.tagged_api.toLowerCase())
    );
    
    // Check if ALL Xpressbees and Delhivery partners are unserviceable
    const allDelhiveryXpressbeesUnserviceable = delhiveryXpressbeesPartners.length > 0 && 
      delhiveryXpressbeesPartners.every(partner => {
        // Check if this partner has any successful rates
        return !rates.some(rate => rate.Aggrigator_id === partner.Aggrigator_id && rate.rate !== null);
      });
    
    console.log("Serviceability Check:", {
      totalPartners: logisticsPartners.length,
      hasOtherPartners: hasOtherPartners,
      delhiveryXpressbeesCount: delhiveryXpressbeesPartners.length,
      allDelhiveryXpressbeesUnserviceable: allDelhiveryXpressbeesUnserviceable,
      partnerTypes: logisticsPartners.map(p => p.tagged_api)
    });
    
    // If we have other partners (like DTDC) OR if Delhivery/Xpressbees are serviceable, proceed normally
    if (hasOtherPartners || !allDelhiveryXpressbeesUnserviceable) {
      // Step 1: Include all delhiveryApiVariant === 0
      const variant0Rates = rates.filter(rate => rate.delhiveryApiVariant === 0);
     
      // Step 2: Filter rates with delhiveryApiVariant === 1 or 2
      const variant1and2Rates = rates.filter(rate => rate.delhiveryApiVariant === 1 || rate.delhiveryApiVariant === 2);
     
      // Step 3: Group variant1and2Rates by minSlab + maxSlab and pick the one with lowest Totalrate
      const groupedVariants = {};
     
      variant1and2Rates.forEach(rate => {
        const key = `${rate.minSlab}-${rate.maxSlab}`;
        const currentTotalRate = rate.forwarderTotalRateAndDetails?.Totalrate ?? Infinity;
     
        if (!groupedVariants[key] || currentTotalRate < (groupedVariants[key].forwarderTotalRateAndDetails?.Totalrate ?? Infinity)) {
          groupedVariants[key] = rate;
        }
      });
     
      // Step 4: Combine variant0Rates with the best rates from each group
      const finalRates = [...variant0Rates, ...Object.values(groupedVariants)];

      console.log("Total rates:", finalRates);
      // console.log("errror intenstially",djsdhjsd)
      res.status(200).json({ rates: finalRates });
    } else {
      // ONLY Xpressbees and Delhivery are present (no DTDC or others) AND ALL are unserviceable
      console.log("No any courier is serviceable - ONLY Xpressbees and Delhivery partners present and ALL are unserviceable");
      console.log("Partners found:", delhiveryXpressbeesPartners.map(p => p.tagged_api));
      res.status(404).json({ 
        error: 'No any courier is serviceable',
        message: 'All available logistics partners (Xpressbees/Delhivery) are not serviceable for this route. No other courier options available.',
        availablePartners: delhiveryXpressbeesPartners.map(p => p.tagged_api),
        reason: 'Only Xpressbees and Delhivery partners configured, and none are serviceable for this route'
      });
    }

} catch (error) {
console.error('Error fetching forwarding partners:', error);
if (!res.headersSent) {
  res.status(500).json({ error: 'Internal Server Error' });
}
}
}

const apiCalculateEcomRate = async (req, res) => {
  try {
    const role_data = req.user;
    console.log("here in the express-rate")
   
    const { type, pickupPincode, destinationPincode,total_weight,total_boxes,paymentType,clientBaseValue,boxDimensions,cod,weight_unit } = req.query;
    // console.log("client id ",clientId)
    console.log("collectable amount as cod and the clientbasevalue",cod,clientBaseValue)
    // console.log("dhsdjhsdfjs",dsjdgsd)
    let clientId = req.query.clientId ?? req.user.selectedClientId;
    console.log("req params data in calci",type,clientId,pickupPincode,destinationPincode,total_weight,total_boxes,paymentType,clientBaseValue,weight_unit)
      //  console.log("dhsdjhsdfjs",dsjdgsd)
    if (!clientId || !pickupPincode || !destinationPincode) {
      return res.status(400).json({ error: 'Client ID, Pickup Pincode, Destination Pincode, and Forwarder Type are required' });
    }
    console.log("client list",clientId)
   
    const pickupPincodeDetails = await mySqlQury(
      `SELECT city, state,Zone FROM tbl_master_pincode WHERE pincode = ?`,
      [pickupPincode]
    );
    const destinationPincodeDetails = await mySqlQury(
      `SELECT city, state,Zone FROM tbl_master_pincode WHERE pincode = ?`,
      [destinationPincode]
    );

    if (!pickupPincodeDetails.length || !destinationPincodeDetails.length) {
      return res.status(404).json({ error: 'One or both pincodes not found in tbl_master_pincode' });
    }

    const pickupCity = pickupPincodeDetails[0].city;
    const pickupState = pickupPincodeDetails[0].state;
    let pickupZone = pickupPincodeDetails[0].Zone;
    const destinationCity = destinationPincodeDetails[0].city;
    const destinationState = destinationPincodeDetails[0].state;
    let destinationZone = destinationPincodeDetails[0].Zone;
    let zoneType = '';
    console.log("pickup zone and destination zone", destinationZone,pickupZone,destinationPincodeDetails,pickupPincodeDetails)
    const [checkBusinessCode] = await mySqlQury(`select exp_volume FROM tbl_admin WHERE id=?`,[clientId]);
    console.log("check businessCode",checkBusinessCode)
    

    
      // If exp_volume is 0 or null, use the current logic (no business_volume filter)
      // For COD payments, exclude DTDC courier
      const logisticsPartners = await mySqlQury(
        `SELECT 
            lp.id AS Aggrigator_id, 
            lp.name, 
            lp.tagged_api, 
            lp.volumetric_factor
         FROM tbl_client_lp clp
         JOIN tbl_logistics_partner lp ON clp.logictics_partner_id = lp.id
         JOIN tbl_courier_details cd ON lp.courier_id = cd.id
         WHERE 
           clp.client_id = ? 
           AND clp.status = 1 
           AND clp.disable_by_superadmin = 0
           AND LOWER(cd.courier_type) = 'ecom'
           ${paymentType?.toLowerCase() === 'cod' ? "AND UPPER(cd.Tagged_api) != 'DTDC'" : ''}`,
        [clientId]
      );
    


    if (!logisticsPartners.length) {
      return res.status(404).json({ error: 'No logistics/aggrigator partners found for the provided client ID and service type.' });
    }
    console.log("logistics/aggrigator partners",logisticsPartners)

    let rates = [] ;
    let forwarderTotalRateAndDetails = []; //this is for the forwarder rate and details or  courierrate details

    for (const partner of logisticsPartners) {
      console.log(`\nðŸ”„ Processing partner: ${partner.name} (${partner.tagged_api})`);
      console.log(`   Partner ID: ${partner.Aggrigator_id}`);
      console.log(`   Tagged API: ${partner.tagged_api}`);
    
     
      let selectedForwarderId = null;
      let lowestRate = Infinity;
      let selectedForwarderDetails = null;
      let volumetricWeight=null;

      let forwarder_service_id = null;
      let originZone = null;
      let maxWeightForwarder = 0;
      let tatDays = 0;
      let delhiveryApiVariant = 0;
      let minSlab = null;
      let maxSlab = null;
    
        const forwarderDetails = await mySqlQury(
          `SELECT
              lp.courier_id AS Forwarder_id,
              lp.tagged_api,
              cd.service_type,
              cd.service_type AS forwarder_service_type,
              cd.delhivery_api_variant,
              cd.volumetric_factor,
              ecomws.min_weight,
              ecomws.max_weight
           FROM tbl_logistics_partner lp
           LEFT JOIN tbl_courier_details cd ON lp.courier_id = cd.id
           LEFT JOIN tbl_ecom_weightslabs ecomws ON lp.courier_id = ecomws.courier_id
           WHERE lp.id = ?`,
          [partner.Aggrigator_id]
        );
    
        console.log("Forwarder Details in volumetric data details:", forwarderDetails);
      
        if (forwarderDetails.length) {
          let forwarderSuccess = false; // Add this flag to track success
          
          for (const forwarder of forwarderDetails) {
            console.log("forwarder details in the --2 and the ",forwarder.Forwarder_id,forwarder.service_type)
            let forwarderId = null;
            let forwarderTaggedApi = forwarder.tagged_api;
            let serviceType = forwarder.service_type;
            let totalRate = null;
            let tat = null;
            let forwarderServiceId = forwarder.forwarder_service_type;
            delhiveryApiVariant = forwarder.delhivery_api_variant;
            minSlab = forwarder.min_weight;
            maxSlab = forwarder.max_weight;
            

      
           
              console.log("in standard mode in forwarder",forwarderTaggedApi)
              if (['xpressbees', 'delhivery'].includes(forwarderTaggedApi.toLowerCase())) {
                console.log(`ðŸ” Checking serviceability for ${forwarderTaggedApi}...`);
                const isServiceable = await checkServiceability(
                  forwarderTaggedApi,
                  pickupPincode,
                  destinationPincode,
                  total_weight,
                  paymentType,
                  clientBaseValue,
                  weight_unit
                );
            
                if (!isServiceable) {
                  console.log(`âŒ ${forwarderTaggedApi} - Route is NOT serviceable`);
                  continue; // Skip to next forwarder
                }
                else {
                  console.log(`âœ… ${forwarderTaggedApi} - Route IS serviceable, proceeding with rate calculation`);
                }
              }
              forwarderId =  forwarder.Forwarder_id
             forwarderTaggedApi = forwarder.tagged_api
             serviceType = forwarder.service_type;
              console.log("forwarder details in the --2 in the standard", pickupCity, destinationCity, partner.Aggrigator_id);
              
              originZone = await determineForwarderOriginEcomZone(
                forwarderId,
                pickupCity,
                destinationCity,
                pickupState,
                destinationState,
                pickupZone,
                destinationZone
              );
              switch(originZone) {
                case 'A':
                  zoneType = 'WITHIN NCR';
                  break;
                case 'B':
                  zoneType = 'WITHIN CITY';
                  break;
                case 'C':
                  zoneType = 'WITHIN-STATE';
                  break;
                case 'D':
                  zoneType = 'WITHIN-ZONE';
                  break;
                case 'E':
                  zoneType = 'WITHIN-METRO';
                  break;
                case 'F':
                  zoneType = 'WITHIN-SPECIAL ZONE';
                  break;
                case 'G':
                  zoneType = 'ROI';
                  break;
                default:
                  zoneType = originZone; // fallback to original value
              }

              
              console.log("Origin zone determined for forwarder:", originZone, forwarderId, forwarder.company_name);
              console.log("origin zone in the forwarder",originZone)
              // console.log("djghs",djghs)
              
              if (originZone) {
                forwarderSuccess = true; // Mark that at least one forwarder succeeded
                // First calculate volumetric weight to compare with actual weight
                console.log("weight_unit",weight_unit,total_weight)
                const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);
                console.log("converted weight in kg:", weightInKg);
                
                const totalVolumetricWeight = await calculateVolumetricWeight(boxDimensions, partner.volumetric_factor);
                console.log("total volumetric weight in std forwarder:", totalVolumetricWeight);
                
                // Determine the higher weight between actual and volumetric
                const higherWeight = Math.max(weightInKg, totalVolumetricWeight);
                console.log("higher weight between actual and volumetric:", higherWeight);
                
                // Convert to grams for API call
                const weightInGrams = higherWeight * 1000;
                console.log("weight in grams for rate calculation:", weightInGrams);
                
                // Get rate based on the higher weight
                const {rate, maxWeight} = await findRateForwarderEcom(forwarderId, originZone, weightInGrams);
                console.log("forwarder rate:", rate);
                console.log("forwarder max weight:", maxWeight);
                maxWeightForwarder = maxWeight
            
                const standardTATResult = await mySqlQury(
                  `SELECT days 
                   FROM tbl_ecom_tat
                   WHERE zone = ? AND courier_id = ?`,
                  [originZone, forwarderId]
                );
            
                if (standardTATResult.length) {
                  console.log("rate calculator in the api in rate.length", rate);
                  tat = standardTATResult[0].days;
                  tatDays = tat;
                  console.log("TAT of forwarder:", tat);
                  
                  // Calculate base value using the rate
                  const base_value = Number(rate);
                  console.log("Base Value in std forwarder:", base_value);
          
                  const additionalChargesResult = await calculateAdditionalChargesForwarderEcom(
                    forwarderId,
                    weightInKg,
                    total_boxes,
                    paymentType,
                    rate,
                    base_value,
                    clientBaseValue,
                    cod
                  );
                  console.log("Additional charges in forwarder:", additionalChargesResult);
                  
                  // Use totalCharge from the result object for rate calculation
                  totalRate = Number(rate) + Number(additionalChargesResult.totalCharge);
                  
                  if (totalRate < lowestRate) {
                    lowestRate = totalRate;
                    selectedForwarderId = forwarderId;
                    taggedApi = forwarderTaggedApi;
                    forwarder_service_id = forwarderServiceId;
                  }
                  
                  forwarderTotalRateAndDetails.push({
                    forwarderId: forwarderId,
                    baserate:Number(rate),
                    Totalrate: totalRate,
                    tat: tat,
                    taggedApi: forwarderTaggedApi,
                    additionalCharges: {
                      total: additionalChargesResult.totalCharge,
                      breakdown: additionalChargesResult.chargesBreakdown
                    },
                    minSlab,
                    maxSlab
                  });
                  selectedForwarderDetails = forwarderTotalRateAndDetails.find(detail => detail.forwarderId === selectedForwarderId);
                }
              } else {
                console.log("No origin zone found for this forwarder");
              }
            
          }
          
          // Only proceed to aggregator if no forwarder succeeded
          if (!forwarderSuccess) {
            console.log("No forwarder succeeded, proceeding to aggregator calculation");
            
            // Reset originZone to use pickupZone for aggregator calculation
            originZone = pickupZone;
            console.log("Using pickupZone for aggregator:", originZone);
          }
        }
      
      
      try {
        let chargableWeight = 0;
       
      
          console.log("pickup zone in the else in standard", pickupZone, destinationZone);
      
         
          
          // If no zone is found after all checks
          if (!originZone) {
            console.log("No origin zone found for standard service");
            rates.push({
              forwarder: partner.name,
              rate: null,
              Aggrigator_id: partner.Aggrigator_id,
              message: 'No valid zone found for shipment'
            });
            continue;
          }
          
          // Continue with the rest of your code using the determined originZone
          console.log("Origin zone found: ", originZone);
      
          console.log("origin zone found: ", originZone);
          console.log("weight unit",weight_unit)
          // First calculate volumetric weight to compare with actual weight
          const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);
          console.log("converted weight in kg:", weightInKg);
          
          const totalVolumetricWeight = await calculateVolumetricWeight(boxDimensions, partner.volumetric_factor);
          console.log("total volumetric weight in ecom ", totalVolumetricWeight);
          
          // Determine the higher weight between actual and volumetric
          const higherWeight = Math.max(weightInKg, totalVolumetricWeight);
          chargableWeight = higherWeight;
          volumetricWeight=totalVolumetricWeight;
          console.log("higher weight between actual and volumetric:in ecom", higherWeight);
          
          // Convert to grams for API call
          const weightInGrams = higherWeight * 1000;
          console.log("weight in grams for rate calculation: in ecom", weightInGrams);
          
          // Get rate based on the higher weight
          const {rate, maxWeight} = await findRateAggrigatorEcom(partner.Aggrigator_id, originZone, weightInGrams,maxWeightForwarder);
          console.log("aggrigator rate: in ecom", rate);
          console.log("aggrigator max weight: in ecom", maxWeight);
      
         
      
          if (tatDays) {
            
            
            
    
            // Calculate base value using the rate from findRateAggrigator
            const base_value = Number(rate);
            console.log("Base Value in std aggrigator:", base_value);
    
            const additionalChargesResult = await calculateAdditionalChargesEcom(
              partner.Aggrigator_id,
              weightInKg,
              total_boxes,
              paymentType,
              rate,
              base_value,
              clientBaseValue,
              cod
            );
            
            console.log("here in the additional charges ", rate, additionalChargesResult.totalCharge);
            
            const totalRate = Number(rate) + Number(additionalChargesResult.totalCharge);
            
            rates.push({
              Aggrigator: partner.name,
              
              rate: totalRate,
              baserate: Number(rate),
              forwarderTotalRateAndDetails: selectedForwarderDetails,
              days: tatDays,
              additionalCharges: {
                total: additionalChargesResult.totalCharge,
                breakdown: additionalChargesResult.chargesBreakdown || []
              },
              TaggedApi: taggedApi,
              forwarderServiceType: forwarder_service_id,
              weight_unit: 'gm',
              Aggrigator_id: partner.Aggrigator_id,
              chargableWeight: chargableWeight,
              volumetricWeight: volumetricWeight,
              zones: {
                origin: pickupZone,
                destination: destinationZone,
                zoneType: zoneType
              },
              shipmentType: 'Standard',
              delhiveryApiVariant,
              minSlab,
              maxSlab
            });
          } else {
            rates.push({
              forwarder: partner.name,
              rate: null,
              Aggrigator_id: partner.Aggrigator_id,
              message: 'No standard rate found'
            });
          }
       
      
      } catch (error) {
        console.error('Error fetching forwarding partners:', error);
      }
      
      // Log final status for this partner
      const partnerRates = rates.filter(rate => rate.Aggrigator_id === partner.Aggrigator_id);
      const hasSuccessfulRates = partnerRates.some(rate => rate.rate !== null);
      console.log(`   ðŸ“Š Partner ${partner.name} final status: ${hasSuccessfulRates ? 'âœ… HAS rates' : 'âŒ NO rates'}`);
      if (partnerRates.length > 0) {
        console.log(`   ðŸ“‹ Partner rates found: ${partnerRates.length}`);
      }
      
    }
    
    console.log("rate length", rates.length);
    
    // Log token cache efficiency for Xpressbees
    const fetchExpressBeesToken = require('../services/fetchExpressBeesToken.js');
    const cacheStatus = fetchExpressBeesToken.getXpressbeesTokenCacheStatus();
    console.log("ðŸ”‘ Xpressbees Token Cache Status:", cacheStatus);

    // REFINED LOGIC: Check if we should return "no courier serviceable" response
    // Only return this response when ALL logistics partners are ONLY Xpressbees and Delhivery AND ALL are unserviceable
    // If DTDC or any other partner is present, DON'T return this response
    
    // Check if there are any partners OTHER than Xpressbees and Delhivery (like DTDC)
    const hasOtherPartners = logisticsPartners.some(partner => 
      !['delhivery', 'xpressbees'].includes(partner.tagged_api.toLowerCase())
    );
    
    // Get only Xpressbees and Delhivery partners
    const delhiveryXpressbeesPartners = logisticsPartners.filter(partner => 
      ['delhivery', 'xpressbees'].includes(partner.tagged_api.toLowerCase())
    );
    
    // Check if ALL Xpressbees and Delhivery partners are unserviceable
    const allDelhiveryXpressbeesUnserviceable = delhiveryXpressbeesPartners.length > 0 && 
      delhiveryXpressbeesPartners.every(partner => {
        // Check if this partner has any successful rates
        return !rates.some(rate => rate.Aggrigator_id === partner.Aggrigator_id && rate.rate !== null);
      });
    
    console.log("Serviceability Check:", {
      totalPartners: logisticsPartners.length,
      hasOtherPartners: hasOtherPartners,
      delhiveryXpressbeesCount: delhiveryXpressbeesPartners.length,
      allDelhiveryXpressbeesUnserviceable: allDelhiveryXpressbeesUnserviceable,
      partnerTypes: logisticsPartners.map(p => p.tagged_api)
    });
    
    // If we have other partners (like DTDC) OR if Delhivery/Xpressbees are serviceable, proceed normally
    if (hasOtherPartners || !allDelhiveryXpressbeesUnserviceable) {
      // Step 1: Include all delhiveryApiVariant === 0
      const variant0Rates = rates.filter(rate => rate.delhiveryApiVariant === 0);
     
      // Step 2: Filter rates with delhiveryApiVariant === 1 or 2
      const variant1and2Rates = rates.filter(rate => rate.delhiveryApiVariant === 1 || rate.delhiveryApiVariant === 2);
     
      // Step 3: Group variant1and2Rates by minSlab + maxSlab and pick the one with lowest Totalrate
      const groupedVariants = {};
     
      variant1and2Rates.forEach(rate => {
        const key = `${rate.minSlab}-${rate.maxSlab}`;
        const currentTotalRate = rate.forwarderTotalRateAndDetails?.Totalrate ?? Infinity;
     
        if (!groupedVariants[key] || currentTotalRate < (groupedVariants[key].forwarderTotalRateAndDetails?.Totalrate ?? Infinity)) {
          groupedVariants[key] = rate;
        }
      });
     
      // Step 4: Combine variant0Rates with the best rates from each group
      const finalRates = [...variant0Rates, ...Object.values(groupedVariants)];

      console.log("Total rates:", finalRates);
      res.status(200).json({ rates: finalRates });
    } else {
      // ONLY Xpressbees and Delhivery are present (no DTDC or others) AND ALL are unserviceable
      console.log("No any courier is serviceable - ONLY Xpressbees and Delhivery partners present and ALL are unserviceable");
      console.log("Partners found:", delhiveryXpressbeesPartners.map(p => p.tagged_api));
      res.status(404).json({ 
        error: 'No any courier is serviceable',
        message: 'All available logistics partners (Xpressbees/Delhivery) are not serviceable for this route. No other courier options available.',
        availablePartners: delhiveryXpressbeesPartners.map(p => p.tagged_api),
        reason: 'Only Xpressbees and Delhivery partners configured, and none are serviceable for this route'
      });
    }

} catch (error) {
console.error('Error fetching forwarding partners:', error);
if (!res.headersSent) {
  res.status(500).json({ error: 'Internal Server Error' });
}
}
}

const apiForwardingPartners = async (req, res) => {
  try {
    const role_data = req.user;

    const { type, clientId, pickupPincode, destinationPincode, total_weight, total_boxes, paymentType, clientBaseValue, boxDimensions, cod, weight_unit } = req.query;
    console.log("client id ", clientId)
    console.log("req params data in calci", type, clientId, pickupPincode, destinationPincode, total_weight, total_boxes, paymentType, clientBaseValue, weight_unit)
    if (!clientId || !pickupPincode || !destinationPincode) {
      return res.status(400).json({ error: 'Client ID, Pickup Pincode, Destination Pincode, and Forwarder Type are required' });
    }

    const pickupPincodeDetails = await mySqlQury(
      `SELECT city, state,Zone FROM tbl_master_pincode WHERE pincode = ?`,
      [pickupPincode]
    );
    const destinationPincodeDetails = await mySqlQury(
      `SELECT city, state,Zone FROM tbl_master_pincode WHERE pincode = ?`,
      [destinationPincode]
    );

    if (!pickupPincodeDetails.length || !destinationPincodeDetails.length) {
      return res.status(404).json({ error: 'One or both pincodes not found in tbl_master_pincode' });
    }

    const pickupCity = pickupPincodeDetails[0].city;
    const pickupState = pickupPincodeDetails[0].state;
    let pickupZone = pickupPincodeDetails[0].Zone;
    const destinationCity = destinationPincodeDetails[0].city;
    const destinationState = destinationPincodeDetails[0].state;
    let destinationZone = destinationPincodeDetails[0].Zone;
    console.log("pickup zone and destination zone", destinationZone, pickupZone, destinationPincodeDetails, pickupPincodeDetails)

    const forwardingPartners = await mySqlQury(
      `SELECT c.id, c.Aggrigator_id, c.name, c.service_type, c.category, c.tagged_api, c.tagged_logo, 
                  a.dispatch_agg, a.aggrigator_type, a.Aggrigator_company_name, 
                  cu.minimum_chargable_weight, cu.volumetric_factor
           FROM tbl_client_aggrigator c
           JOIN tbl_aggrigator a ON c.Aggrigator_id = a.id
           JOIN tbl_customers cu ON a.id = cu.Aggrigator_id
           WHERE c.client_id = ? AND c.status = 1`,
      [clientId]
    );

    if (!forwardingPartners.length) {
      return res.status(404).json({ error: 'No forwarding partners found for the provided client ID and service type.' });
    }
    console.log("forwarding partners", forwardingPartners)

    let rates = [];
    let forwarderTotalRateAndDetails = [];

    for (const partner of forwardingPartners) {
      console.log("Processing partner:", partner);

      const forwarderTable = `tbl_zone_mapping_Aggrigator_${partner.Aggrigator_id}`;
      const tatTable = `tbl_TAT_Aggrigator_${partner.Aggrigator_id}`;
      console.log("tables ", forwarderTable, tatTable);
      let taggedApi = null;
      let selectedForwarderId = null;
      let lowestRate = Infinity;
      let selectedForwarderDetails = null;
      let volumetricWeight = null;
      let forwarderOda = 0;
      let aggrigatorOda = 0;
      let forwarder_service_id = null;


      if (partner.binded_with_forwarder === 2 || partner.binded_with_forwarder === 1) {
        console.log("forwarder details in the ==2");

        const forwarderDetails = await mySqlQury(
          `SELECT 
                  af.Forwarder_id, 
                  af.tagged_api, 
                  af.service_type, 
                  vd.service_type as forwarder_service_type,
                  vd.minimum_chargable_weight, 
                  vd.volumetric_factor
               FROM tbl_aggrigator_forwarder af
               LEFT JOIN tbl_vendor_details vd ON af.Forwarder_id = vd.id
               WHERE af.Aggrigator_id = ?`,
          [partner.Aggrigator_id]
        );

        console.log("Forwarder Details in volumetric data details:", forwarderDetails);
        if (forwarderDetails.length) {
          for (const forwarder of forwarderDetails) {
            console.log("forwarder details in the --2 and the ", forwarder.Forwarder_id, forwarder.service_type)
            let forwarderId = null;
            let forwarderTaggedApi = forwarder.tagged_api;
            let serviceType = forwarder.service_type;
            let totalRate = null;
            let tat = null;
            let forwarderServiceId = forwarder.forwarder_service_type;


            if (serviceType === "LTL") {
              console.log("forwarder details in the --2 in the case LTL")
              forwarderId = forwarder.Forwarder_id;
              forwarderTaggedApi = forwarder.tagged_api;
              serviceType = forwarder.service_type;
              forwarderOda = await checkOdaStatus(forwarderTaggedApi, pickupPincode, destinationPincode);

              const pickupZoneQuery = `SELECT Zone FROM tbl_zone_mapping_${forwarderId} WHERE City = ? OR State = ?`;
              const destinationZoneQuery = `SELECT Zone FROM tbl_zone_mapping_${forwarderId} WHERE City = ? OR State = ?`;

              console.log("pickupcity and destination details", pickupCity, pickupState, destinationCity, destinationState)
              const pickupZoneResult = await mySqlQury(pickupZoneQuery, [pickupCity, pickupState]);
              const destinationZoneResult = await mySqlQury(destinationZoneQuery, [destinationCity, destinationState]);

              const originZone = pickupZoneResult.length > 0 ? pickupZoneResult[0].Zone : null;
              const destinationZone = destinationZoneResult.length > 0 ? destinationZoneResult[0].Zone : null;
              console.log("shabbar in ltl case of forwarder details", originZone, destinationZone, forwarderId);

              const rateResult = await mySqlQury(
                `SELECT rate FROM tbl_vendor_rates WHERE zone_origin = ? AND zone_destination = ? AND vendor_id = ?`,
                [originZone, destinationZone, forwarderId]
              );
              console.log("rate result", rateResult)
              const tatResult = await mySqlQury(
                `SELECT days FROM tbl_tat_${forwarderId} WHERE zone_origin = ? AND zone_destination = ?`,
                [originZone, destinationZone]
              );
              const totalVolumetricWeight = await calculateVolumetricWeightLTL(boxDimensions, forwarder.volumetric_factor);
              console.log("total volumetric weight", totalVolumetricWeight)
              const minimumChargableWeight = Number(forwarder.minimum_chargable_weight);

              const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);

              const maxWeight = Math.max(weightInKg, totalVolumetricWeight, minimumChargableWeight);
              console.log("Maximum Weight Used for Base Value Calculation:", maxWeight);

              const base_value = rateResult.length > 0 ? Number(rateResult[0].rate) * Math.ceil(maxWeight) : 0;
              console.log("Base Value", base_value);

              console.log("Base Value in forwarder", base_value)
              console.log("rate and tat in the case of forwarder binded in vendor in case of ltl", tatResult)

              if (rateResult.length && tatResult.length) {
                const rate = Number(rateResult[0].rate);
                tat = tatResult[0].days;

                const additionalChargesResult = await calculateAdditionalChargesForwarder(
                  forwarderId,
                  weightInKg,
                  total_boxes,
                  paymentType,
                  rate,
                  base_value,
                  clientBaseValue,
                  cod
                );
                console.log("Additional charges in forwarder ltl:", additionalChargesResult);

                // Use totalCharge from the result object for rate calculation
                totalRate = Number(base_value) + Number(additionalChargesResult.totalCharge);

                if (totalRate < lowestRate) {
                  lowestRate = totalRate;
                  selectedForwarderId = forwarderId;
                  taggedApi = forwarderTaggedApi;
                  forwarder_service_id = forwarderServiceId;
                }

                forwarderTotalRateAndDetails.push({
                  forwarderId: forwarderId,
                  forwarderOda: forwarderOda,
                  baserate: Number(base_value),
                  Totalrate: Number(totalRate),
                  tat: tat,
                  taggedApi: forwarderTaggedApi,
                  additionalCharges: {
                    total: additionalChargesResult.totalCharge,
                    breakdown: additionalChargesResult.chargesBreakdown
                  }
                });
              }
              selectedForwarderDetails = forwarderTotalRateAndDetails.find(detail => detail.forwarderId === selectedForwarderId);
            }
            else if (serviceType === "standard") {
              console.log("in standard mode in forwarder", forwarderTaggedApi)
              if (['expressbees', 'delhivery'].includes(forwarderTaggedApi.toLowerCase())) {
                const isServiceable = await checkServiceability(
                  forwarderTaggedApi,
                  pickupPincode,
                  destinationPincode,
                  total_weight,
                  paymentType,
                  clientBaseValue,
                  weight_unit
                );

                if (!isServiceable) {
                  console.log(`Skipping ${forwarderTaggedApi} as route is not serviceable`);
                  continue;
                }
                else {
                  console.log(`Processing ${forwarderTaggedApi} as it is within-city serviceable`);
                }
              }
              forwarderId = forwarder.Forwarder_id
              forwarderTaggedApi = forwarder.tagged_api
              serviceType = forwarder.service_type;
              console.log("forwarder details in the --2 in the standard", pickupCity, destinationCity, partner.Aggrigator_id);

              const originZone = await determineForwarderOriginZone(
                forwarderId,
                pickupCity,
                destinationCity,
                pickupState,
                destinationState,
                pickupZone,
                destinationZone
              );

              console.log("Origin zone determined for forwarder:", originZone, forwarderId, forwarder.company_name);


              if (originZone) {
                // First calculate volumetric weight to compare with actual weight
                const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);
                console.log("converted weight in kg:", weightInKg);

                const totalVolumetricWeight = await calculateVolumetricWeight(boxDimensions, partner.volumetric_factor);
                console.log("total volumetric weight in std forwarder:", totalVolumetricWeight);

                // Determine the higher weight between actual and volumetric
                const higherWeight = Math.max(weightInKg, totalVolumetricWeight);
                console.log("higher weight between actual and volumetric:", higherWeight);

                // Convert to grams for API call
                const weightInGrams = higherWeight * 1000;
                console.log("weight in grams for rate calculation:", weightInGrams);

                // Get rate based on the higher weight
                const { rate, maxWeight } = await findRateForwarder(forwarderId, originZone, weightInGrams);
                console.log("forwarder rate:", rate);
                console.log("forwarder max weight:", maxWeight);

                const standardTATResult = await mySqlQury(
                  `SELECT days 
                       FROM tbl_standard_tat
                       WHERE zone = ? AND vendor_id = ?`,
                  [originZone, forwarderId]
                );

                if (standardTATResult.length) {
                  console.log("rate calculator in the api in rate.length", rate);
                  tat = standardTATResult[0].days;
                  console.log("TAT of forwarder:", tat);

                  // Calculate base value using the rate
                  const base_value = Number(rate);
                  console.log("Base Value in std forwarder:", base_value);

                  const additionalChargesResult = await calculateAdditionalChargesForwarder(
                    forwarderId,
                    weightInKg,
                    total_boxes,
                    paymentType,
                    rate,
                    base_value,
                    clientBaseValue,
                    cod
                  );
                  console.log("Additional charges in forwarder:", additionalChargesResult);

                  // Use totalCharge from the result object for rate calculation
                  totalRate = Number(rate) + Number(additionalChargesResult.totalCharge);

                  if (totalRate < lowestRate) {
                    lowestRate = totalRate;
                    selectedForwarderId = forwarderId;
                    taggedApi = forwarderTaggedApi;
                    forwarder_service_id = forwarderServiceId;
                  }

                  forwarderTotalRateAndDetails.push({
                    forwarderId: forwarderId,
                    baserate: Number(rate),
                    Totalrate: totalRate,
                    tat: tat,
                    taggedApi: forwarderTaggedApi,
                    additionalCharges: {
                      total: additionalChargesResult.totalCharge,
                      breakdown: additionalChargesResult.chargesBreakdown
                    }
                  });
                  selectedForwarderDetails = forwarderTotalRateAndDetails.find(detail => detail.forwarderId === selectedForwarderId);
                }
              } else {
                console.log("No origin zone found for standard service");
              }
            }
          }
        }
      }

      try {
        let chargableWeight = 0;
        if (partner.service_type === 'LTL') {
          console.log("in the case of servise type ltl", partner.Aggrigator_id)
          const pickupZoneDetails = await mySqlQury(
            `SELECT zone FROM ?? WHERE city = ? OR state = ?`,
            [forwarderTable, pickupCity, pickupState]
          );

          const destinationZoneDetails = await mySqlQury(
            `SELECT zone FROM ?? WHERE city = ? OR state = ?`,
            [forwarderTable, destinationCity, destinationState]
          );
          console.log("pickup details and destination details", pickupCity, pickupState, destinationCity, destinationState)

          console.log("pickupZone", pickupZoneDetails, destinationZoneDetails, partner.Aggrigator_id);

          if (pickupZoneDetails.length && destinationZoneDetails.length) {
            const rateDetails = await mySqlQury(
              `SELECT rate FROM tbl_client_rates 
                   WHERE Aggrigator_id = ? 
                   AND zone_origin = ? 
                   AND zone_destination = ?`,
              [
                partner.Aggrigator_id,
                pickupZoneDetails[0].zone,
                destinationZoneDetails[0].zone,
              ]
            );
            console.log("shabbar ansari", rateDetails, partner.Aggrigator_id, pickupZoneDetails[0].zone, destinationZoneDetails[0].zone)

            const tatDetails = await mySqlQury(
              `SELECT days FROM ?? 
                   WHERE Aggrigator_id = ? 
                   AND zone_origin = ? 
                   AND zone_destination = ?`,
              [
                tatTable,
                partner.Aggrigator_id,
                pickupZoneDetails[0].zone,
                destinationZoneDetails[0].zone
              ]
            );
            console.log("tat details", tatDetails)
            const tat = tatDetails[0].days;
            console.log("partner minumum weight", partner.minimum_chargable_weight, partner.volumetric_factor)
            const totalVolumetricWeight = await calculateVolumetricWeightLTL(boxDimensions, partner.volumetric_factor);
            console.log("total volumetric weight", totalVolumetricWeight);
            volumetricWeight = totalVolumetricWeight;


            const minimumChargableWeight = Number(partner.minimum_chargable_weight);

            const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);

            const maxWeight = Math.max(weightInKg, totalVolumetricWeight, minimumChargableWeight);
            chargableWeight = maxWeight;

            console.log("Maximum Weight Used for Base Value Calculation:", maxWeight);

            if (rateDetails.length > 0) {
              const rate = Number(rateDetails[0].rate);
              const base_value = rate * Math.ceil(maxWeight);
              console.log("Base Value", base_value);

              if (tatDetails.length) {
                const additionalChargesResult = await calculateAdditionalCharges(
                  partner.Aggrigator_id,
                  weightInKg,
                  total_boxes,
                  paymentType,
                  rate,
                  base_value,
                  clientBaseValue,
                  cod
                );
                console.log("aggrigator additinal total breakdown", additionalChargesResult)

                console.log("here in the additional charges aggrigator ltl ", rate, additionalChargesResult.totalCharge);

                const totalRate = Number(base_value) + Number(additionalChargesResult.totalCharge);
                const aggrigatorOda = await checkOdaStatus(partner.tagged_api, pickupPincode, destinationPincode);


                rates.push({
                  Aggrigator: partner.Aggrigator_company_name,
                  total_weight: weightInKg,
                  base_value: Number(base_value),
                  agrrigatorrate: rate,
                  paymentType: paymentType,
                  aggrigatorOdaFactor: aggrigatorOda,
                  rate: totalRate,
                  baserate: Number(base_value),
                  forwarderTotalRateAndDetails: selectedForwarderDetails,
                  days: tat,
                  AggrigatorLogo: partner.tagged_logo,
                  additionalCharges: {
                    total: additionalChargesResult.totalCharge,
                    breakdown: additionalChargesResult.chargesBreakdown || []
                  },
                  forwarderServiceType: forwarder_service_id,
                  category: partner.aggrigator_type,
                  service_type: partner.service_type,
                  TaggedApi: partner.tagged_api, // Use the aggregator's tagged_api instead of forwarder's
                  agg_defination: partner.agg_defination,
                  Aggrigator_id: partner.Aggrigator_id,
                  chargableWeight: chargableWeight,
                  volumetricWeight: volumetricWeight,
                  weight_unit: 'kg',
                  zones: {
                    origin: pickupZoneDetails[0].zone,
                    destination: destinationZoneDetails[0].zone
                  },
                  shipmentType: 'LTL'
                });
              } else {
                rates.push({
                  forwarder: partner.name,
                  rate: null,
                  Aggrigator_id: partner.Aggrigator_id,
                  message: 'No LTL rates found'
                });
              }
            } else {
              rates.push({
                forwarder: partner.name,
                rate: null,
                Aggrigator_id: partner.Aggrigator_id,
                message: 'No LTL rates found for this route'
              });
            }
          }
        }
        else {
          console.log("pickup zone in the else in standard", pickupZone, destinationZone);

          // Use the helper function to determine origin zone
          const originZone = await determineOriginZoneAggregator(
            partner.Aggrigator_id,
            pickupCity,
            destinationCity,
            pickupState,
            destinationState,
            pickupZone,
            destinationZone
          );

          // If no zone is found after all checks
          if (!originZone) {
            console.log("No origin zone found for standard service");
            rates.push({
              forwarder: partner.name,
              rate: null,
              Aggrigator_id: partner.Aggrigator_id,
              message: 'No valid zone found for shipment'
            });
            return;
          }

          // Continue with the rest of your code using the determined originZone
          console.log("Origin zone found: ", originZone);

          console.log("origin zone found: ", originZone);
          console.log("weight unit", weight_unit)
          // First calculate volumetric weight to compare with actual weight
          const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);
          console.log("converted weight in kg:", weightInKg);

          const totalVolumetricWeight = await calculateVolumetricWeight(boxDimensions, partner.volumetric_factor);
          console.log("total volumetric weight in std:", totalVolumetricWeight);

          // Determine the higher weight between actual and volumetric
          const higherWeight = Math.max(weightInKg, totalVolumetricWeight);
          chargableWeight = higherWeight;
          volumetricWeight = totalVolumetricWeight;
          console.log("higher weight between actual and volumetric:", higherWeight);

          // Convert to grams for API call
          const weightInGrams = higherWeight * 1000;
          console.log("weight in grams for rate calculation:", weightInGrams);
             // Get rate based on the higher weight
          const { rate, maxWeight } = await findRateAggrigator(partner.Aggrigator_id, originZone, weightInGrams);
          console.log("aggrigator rate:", rate);
          console.log("aggrigator max weight:", maxWeight);

          const standardTATResult = await mySqlQury(
            `SELECT days 
                 FROM tbl_std_agg_tat 
                 WHERE zone = ? AND aggrigator_id = ?`,
            [originZone, partner.Aggrigator_id]
          );
          console.log("standardTAT result:", standardTATResult);

          if (rate) {
            const tat = standardTATResult[0]?.days;
            console.log("TAT of aggrigator:", tat);
            const base_value = Number(rate);
            console.log("Base Value in std aggrigator:", base_value);

            const additionalChargesResult = await calculateAdditionalCharges(
              partner.Aggrigator_id,
              weightInKg,
              total_boxes,
              paymentType,
              rate,
              base_value,
              clientBaseValue,
              cod
            );

            console.log("here in the additional charges ", rate, additionalChargesResult.totalCharge);

            const totalRate = Number(rate) + Number(additionalChargesResult.totalCharge);

            rates.push({
              Aggrigator: partner.Aggrigator_company_name,

              rate: totalRate,
              baserate: Number(rate),
              forwarderTotalRateAndDetails: selectedForwarderDetails,
              days: tat,
              AggrigatorLogo: partner.tagged_logo,
              additionalCharges: {
                total: additionalChargesResult.totalCharge,
                breakdown: additionalChargesResult.chargesBreakdown || []
              },
              category: partner.aggrigator_type,
              service_type: partner.service_type,
              TaggedApi: taggedApi,
              forwarderServiceType: forwarder_service_id,
              weight_unit: 'gm',
              agg_defination: partner.agg_defination,
              Aggrigator_id: partner.Aggrigator_id,
              chargableWeight: chargableWeight,
              volumetricWeight: volumetricWeight,
              zones: {
                origin: pickupZone,
                destination: destinationZone
              },
              shipmentType: 'Standard'
            });
          } else {
            rates.push({
              forwarder: partner.name,
              rate: null,
              Aggrigator_id: partner.Aggrigator_id,
              message: 'No standard rate found'
            });
          }
        }

      } catch (error) {
        console.error('Error fetching forwarding partners:', error);
      }

    }

    console.log("Total rates:", rates);

    res.status(200).json({ rates });

  } catch (error) {
    console.error('Error fetching forwarding partners:', error);
    if (!res.headersSent) {
      res.status(500).json({ error: 'Internal Server Error' });
    }
  }
}

const apiAggrigatorPartnersPincode = async (req, res) => {
  try {
    const role_data = req.user;

    const { type, clientId, pickupPincode, destinationPincode, total_weight, total_boxes, paymentType, clientBaseValue, boxDimensions, cod, weight_unit } = req.query;
    console.log("client id ", clientId)
    console.log("req params data in calci", type, clientId, pickupPincode, destinationPincode, total_weight, total_boxes, paymentType, clientBaseValue, weight_unit)
    if (!clientId || !pickupPincode || !destinationPincode) {
      return res.status(400).json({ error: 'Client ID, Pickup Pincode, Destination Pincode, and Forwarder Type are required' });
    }

    const pickupPincodeDetails = await mySqlQury(
      `SELECT city, state,Zone FROM tbl_master_pincode WHERE pincode = ?`,
      [pickupPincode]
    );
    const destinationPincodeDetails = await mySqlQury(
      `SELECT city, state,Zone FROM tbl_master_pincode WHERE pincode = ?`,
      [destinationPincode]
    );

    if (!pickupPincodeDetails.length || !destinationPincodeDetails.length) {
      return res.status(404).json({ error: 'One or both pincodes not found in tbl_master_pincode' });
    }

    const pickupCity = pickupPincodeDetails[0].city;
    const pickupState = pickupPincodeDetails[0].state;
    let pickupZone = pickupPincodeDetails[0].Zone;
    const destinationCity = destinationPincodeDetails[0].city;
    const destinationState = destinationPincodeDetails[0].state;
    let destinationZone = destinationPincodeDetails[0].Zone;
    console.log("pickup zone and destination zone", destinationZone, pickupZone, destinationPincodeDetails, pickupPincodeDetails)

    const forwardingPartners = await mySqlQury(
      `SELECT c.id, c.Aggrigator_id, c.name, c.service_type, c.category, c.tagged_api, c.tagged_logo, 
                  a.dispatch_agg, a.binded_with_forwarder, a.aggrigator_type, a.Aggrigator_company_name, 
                  cu.minimum_chargable_weight, cu.volumetric_factor
           FROM tbl_client_aggrigator c
           JOIN tbl_aggrigator a ON c.Aggrigator_id = a.id
           JOIN tbl_customers cu ON a.id = cu.Aggrigator_id
           WHERE c.client_id = ? AND c.status = 1`,
      [clientId]
    );

    if (!forwardingPartners.length) {
      return res.status(404).json({ error: 'No forwarding partners found for the provided client ID and service type.' });
    }
    console.log("forwarding partners", forwardingPartners)

    let rates = [];
    let forwarderTotalRateAndDetails = [];

    for (const partner of forwardingPartners) {
      console.log("Processing partner:", partner);

      const forwarderTable = `tbl_zone_mapping_Aggrigator_${partner.Aggrigator_id}`;
      const tatTable = `tbl_TAT_Aggrigator_${partner.Aggrigator_id}`;
      console.log("tables ", forwarderTable, tatTable);
      let taggedApi = null;
      let selectedForwarderId = null;
      let lowestRate = Infinity;
      let selectedForwarderDetails = null;
      let volumetricWeight = null;

      if (partner.binded_with_forwarder === 2 || partner.binded_with_forwarder === 1) {
        console.log("forwarder details in the ==2");

        const forwarderDetails = await mySqlQury(
          `SELECT 
              af.Forwarder_id, 
              af.tagged_api, 
              af.service_type, 
              vd.minimum_chargable_weight, 
              vd.volumetric_factor
           FROM tbl_aggrigator_forwarder af
           LEFT JOIN tbl_vendor_details vd ON af.Forwarder_id = vd.id
           WHERE af.Aggrigator_id = ?`,
          [partner.Aggrigator_id]
        );

        console.log("Forwarder Details in volumetric data details:", forwarderDetails);

        if (forwarderDetails.length) {
          for (const forwarder of forwarderDetails) {
            console.log("forwarder details in the --2 and the ", forwarder.Forwarder_id, forwarder.service_type)
            let forwarderId = null;
            let forwarderTaggedApi = forwarder.tagged_api;
            let serviceType = forwarder.service_type;
            let totalRate = null;
            let tat = null;

            if (serviceType === "LTL") {
              console.log("forwarder details in the --2 in the case LTL")
              forwarderId = forwarder.Forwarder_id;
              forwarderTaggedApi = forwarder.tagged_api;
              serviceType = forwarder.service_type;

              const pickupZoneQuery = `SELECT Zone FROM tbl_zone_mapping_${forwarderId} WHERE City = ? OR State = ?`;
              const destinationZoneQuery = `SELECT Zone FROM tbl_zone_mapping_${forwarderId} WHERE City = ? OR State = ?`;

              console.log("pickupcity and destination details", pickupCity, pickupState, destinationCity, destinationState)
              const pickupZoneResult = await mySqlQury(pickupZoneQuery, [pickupCity, pickupState]);
              const destinationZoneResult = await mySqlQury(destinationZoneQuery, [destinationCity, destinationState]);

              const originZone = pickupZoneResult.length > 0 ? pickupZoneResult[0].Zone : null;
              const destinationZone = destinationZoneResult.length > 0 ? destinationZoneResult[0].Zone : null;
              console.log("shabbar in ltl case of forwarder details", originZone, destinationZone, forwarderId);

              const rateResult = await mySqlQury(
                `SELECT rate FROM tbl_vendor_rates WHERE zone_origin = ? AND zone_destination = ? AND vendor_id = ?`,
                [originZone, destinationZone, forwarderId]
              );
              console.log("rate result", rateResult)
              const tatResult = await mySqlQury(
                `SELECT days FROM tbl_tat_${forwarderId} WHERE zone_origin = ? AND zone_destination = ?`,
                [originZone, destinationZone]
              );
              const totalVolumetricWeight = await calculateVolumetricWeightLTL(boxDimensions, forwarder.volumetric_factor);
              console.log("total volumetric weight", totalVolumetricWeight)
              const minimumChargableWeight = Number(forwarder.minimum_chargable_weight);

              const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);

              const maxWeight = Math.max(weightInKg, totalVolumetricWeight, minimumChargableWeight);
              console.log("Maximum Weight Used for Base Value Calculation:", maxWeight);

              const base_value = rateResult.length > 0 ? Number(rateResult[0].rate) * Math.ceil(maxWeight) : 0;
              console.log("Base Value", base_value);

              console.log("Base Value in forwarder", base_value)
              console.log("rate and tat in the case of forwarder binded in vendor in case of ltl", tatResult)

              if (rateResult.length && tatResult.length) {
                const rate = Number(rateResult[0].rate);
                tat = tatResult[0].days;

                const additionalChargesResult = await calculateAdditionalChargesForwarder(
                  forwarderId,
                  weightInKg,
                  total_boxes,
                  paymentType,
                  rate,
                  base_value,
                  clientBaseValue,
                  cod
                );
                console.log("Additional charges in forwarder ltl:", additionalChargesResult);

                // Use totalCharge from the result object for rate calculation
                totalRate = Number(base_value) + Number(additionalChargesResult.totalCharge);

                if (totalRate < lowestRate) {
                  lowestRate = totalRate;
                  selectedForwarderId = forwarderId;
                  taggedApi = forwarderTaggedApi;
                }

                forwarderTotalRateAndDetails.push({
                  forwarderId: forwarderId,
                  baserate: Number(base_value),
                  Totalrate: Number(totalRate),
                  tat: tat,
                  taggedApi: forwarderTaggedApi,
                  additionalCharges: {
                    total: additionalChargesResult.totalCharge,
                    breakdown: additionalChargesResult.chargesBreakdown
                  }
                });
              }
              selectedForwarderDetails = forwarderTotalRateAndDetails.find(detail => detail.forwarderId === selectedForwarderId);
            }
            else if (serviceType === "standard") {
              console.log("in standard mode in forwarder", forwarderTaggedApi)
              if (['expressbees', 'delhivery'].includes(forwarderTaggedApi.toLowerCase())) {
                const isServiceable = await checkServiceability(
                  forwarderTaggedApi,
                  pickupPincode,
                  destinationPincode,
                  total_weight,
                  paymentType,
                  clientBaseValue,
                  weight_unit
                );

                if (!isServiceable) {
                  console.log(`Skipping ${forwarderTaggedApi} as route is not serviceable`);
                  continue;
                }
                else {
                  console.log(`Processing ${forwarderTaggedApi} as it is within-city serviceable`);
                }
              }
              forwarderId = forwarder.Forwarder_id
              forwarderTaggedApi = forwarder.tagged_api
              serviceType = forwarder.service_type;
              console.log("forwarder details in the --2 in the standard", pickupCity, destinationCity, partner.Aggrigator_id);

              const originZone = await determineForwarderOriginZone(
                forwarderId,
                pickupCity,
                destinationCity,
                pickupState,
                destinationState,
                pickupZone,
                destinationZone
              );

              console.log("Origin zone determined for forwarder:", originZone, forwarderId, forwarder.company_name);


              if (originZone) {
                // First calculate volumetric weight to compare with actual weight
                const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);
                console.log("converted weight in kg:", weightInKg);

                const totalVolumetricWeight = await calculateVolumetricWeight(boxDimensions, partner.volumetric_factor);
                console.log("total volumetric weight in std forwarder:", totalVolumetricWeight);

                // Determine the higher weight between actual and volumetric
                const higherWeight = Math.max(weightInKg, totalVolumetricWeight);
                console.log("higher weight between actual and volumetric:", higherWeight);

                // Convert to grams for API call
                const weightInGrams = higherWeight * 1000;
                console.log("weight in grams for rate calculation:", weightInGrams);

                // Get rate based on the higher weight
                const { rate, maxWeight } = await findRateForwarder(forwarderId, originZone, weightInGrams);
                console.log("forwarder rate:", rate);
                console.log("forwarder max weight:", maxWeight);

                const standardTATResult = await mySqlQury(
                  `SELECT days 
                   FROM tbl_standard_tat
                   WHERE zone = ? AND vendor_id = ?`,
                  [originZone, forwarderId]
                );

                if (standardTATResult.length) {
                  console.log("rate calculator in the api in rate.length", rate);
                  tat = standardTATResult[0].days;
                  console.log("TAT of forwarder:", tat);

                  // Calculate base value using the rate
                  const base_value = Number(rate);
                  console.log("Base Value in std forwarder:", base_value);

                  const additionalChargesResult = await calculateAdditionalChargesForwarder(
                    forwarderId,
                    weightInKg,
                    total_boxes,
                    paymentType,
                    rate,
                    base_value,
                    clientBaseValue,
                    cod
                  );
                  console.log("Additional charges in forwarder:", additionalChargesResult);

                  // Use totalCharge from the result object for rate calculation
                  totalRate = Number(rate) + Number(additionalChargesResult.totalCharge);

                  if (totalRate < lowestRate) {
                    lowestRate = totalRate;
                    selectedForwarderId = forwarderId;
                    taggedApi = forwarderTaggedApi;
                  }

                  forwarderTotalRateAndDetails.push({
                    forwarderId: forwarderId,
                    baserate: Number(rate),
                    Totalrate: totalRate,
                    tat: tat,
                    taggedApi: forwarderTaggedApi,
                    additionalCharges: {
                      total: additionalChargesResult.totalCharge,
                      breakdown: additionalChargesResult.chargesBreakdown
                    }
                  });
                  selectedForwarderDetails = forwarderTotalRateAndDetails.find(detail => detail.forwarderId === selectedForwarderId);
                }
              } else {
                console.log("No origin zone found for standard service");
              }
            }
          }
        }
      }

      try {
        let chargableWeight = 0;
        if (partner.service_type === 'LTL') {
          console.log("in the case of servise type ltl", partner.Aggrigator_id)
          const pickupZoneDetails = await mySqlQury(
            `SELECT zone FROM ?? WHERE city = ? OR state = ?`,
            [forwarderTable, pickupCity, pickupState]
          );

          const destinationZoneDetails = await mySqlQury(
            `SELECT zone FROM ?? WHERE city = ? OR state = ?`,
            [forwarderTable, destinationCity, destinationState]
          );
          console.log("pickup details and destination details", pickupCity, pickupState, destinationCity, destinationState)

          console.log("pickupZone", pickupZoneDetails, destinationZoneDetails, partner.Aggrigator_id);

          if (pickupZoneDetails.length && destinationZoneDetails.length) {
            const rateDetails = await mySqlQury(
              `SELECT rate FROM tbl_client_rates 
               WHERE Aggrigator_id = ? 
               AND zone_origin = ? 
               AND zone_destination = ?`,
              [
                partner.Aggrigator_id,
                pickupZoneDetails[0].zone,
                destinationZoneDetails[0].zone,
              ]
            );
            console.log("shabbar ansari", rateDetails, partner.Aggrigator_id, pickupZoneDetails[0].zone, destinationZoneDetails[0].zone)

            const tatDetails = await mySqlQury(
              `SELECT days FROM ?? 
               WHERE Aggrigator_id = ? 
               AND zone_origin = ? 
               AND zone_destination = ?`,
              [
                tatTable,
                partner.Aggrigator_id,
                pickupZoneDetails[0].zone,
                destinationZoneDetails[0].zone
              ]
            );
            console.log("tat details", tatDetails)
            const tat = tatDetails[0].days;
            console.log("partner minumum weight", partner.minimum_chargable_weight, partner.volumetric_factor)
            const totalVolumetricWeight = await calculateVolumetricWeightLTL(boxDimensions, partner.volumetric_factor);
            console.log("total volumetric weight", totalVolumetricWeight);
            volumetricWeight = totalVolumetricWeight;

            const minimumChargableWeight = Number(partner.minimum_chargable_weight);

            const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);

            const maxWeight = Math.max(weightInKg, totalVolumetricWeight, minimumChargableWeight);
            chargableWeight = maxWeight;
            console.log("Maximum Weight Used for Base Value Calculation:", maxWeight);

            if (rateDetails.length > 0) {
              const rate = Number(rateDetails[0].rate);
              const base_value = rate * Math.ceil(maxWeight);
              console.log("Base Value", base_value);

              if (tatDetails.length) {
                const additionalChargesResult = await calculateAdditionalCharges(
                  partner.Aggrigator_id,
                  weightInKg,
                  total_boxes,
                  paymentType,
                  rate,
                  base_value,
                  clientBaseValue,
                  cod
                );
                console.log("aggrigator additinal total breakdown", additionalChargesResult)

                console.log("here in the additional charges aggrigator ltl ", rate, additionalChargesResult.totalCharge);

                const totalRate = Number(base_value) + Number(additionalChargesResult.totalCharge);

                rates.push({
                  Aggrigator: partner.Aggrigator_company_name,
                  rate: totalRate,
                  baserate: Number(base_value),
                  forwarderTotalRateAndDetails: selectedForwarderDetails,
                  days: tat,
                  AggrigatorLogo: partner.tagged_logo,
                  additionalCharges: {
                    total: additionalChargesResult.totalCharge,
                    breakdown: additionalChargesResult.chargesBreakdown || []
                  },
                  category: partner.aggrigator_type,
                  service_type: partner.service_type,
                  TaggedApi: partner.tagged_api, // Use the aggregator's tagged_api instead of forwarder's
                  agg_defination: partner.agg_defination,
                  Aggrigator_id: partner.Aggrigator_id,
                  chargableWeight: chargableWeight,
                  volumetricWeight: volumetricWeight,
                  weight_unit: 'kg',
                  zones: {
                    origin: pickupZoneDetails[0].zone,
                    destination: destinationZoneDetails[0].zone
                  },
                  shipmentType: 'LTL'
                });
              } else {
                rates.push({
                  forwarder: partner.name,
                  rate: null,
                  Aggrigator_id: partner.Aggrigator_id,
                  message: 'No LTL rates found'
                });
              }
            } else {
              rates.push({
                forwarder: partner.name,
                rate: null,
                Aggrigator_id: partner.Aggrigator_id,
                message: 'No LTL rates found for this route'
              });
            }
          }
        }
        else {
          console.log("pickup zone in the else in standard", pickupZone, destinationZone);

          // Use the helper function to determine origin zone
          const originZone = await determineOriginZoneAggregator(
            partner.Aggrigator_id,
            pickupCity,
            destinationCity,
            pickupState,
            destinationState,
            pickupZone,
            destinationZone
          );

          // If no zone is found after all checks
          if (!originZone) {
            console.log("No origin zone found for standard service");
            rates.push({
              forwarder: partner.name,
              rate: null,
              Aggrigator_id: partner.Aggrigator_id,
              message: 'No valid zone found for shipment'
            });
            return;
          }

          // Continue with the rest of your code using the determined originZone
          console.log("Origin zone found: ", originZone);

          console.log("origin zone found: ", originZone);
          console.log("weight unit", weight_unit)
          // First calculate volumetric weight to compare with actual weight
          const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);
          console.log("converted weight in kg:", weightInKg);

          const totalVolumetricWeight = await calculateVolumetricWeight(boxDimensions, partner.volumetric_factor);
          console.log("total volumetric weight in std:", totalVolumetricWeight);


          // Determine the higher weight between actual and volumetric
          const higherWeight = Math.max(weightInKg, totalVolumetricWeight);
          console.log("higher weight between actual and volumetric:", higherWeight);
          volumetricWeight = totalVolumetricWeight;
          chargableWeight = higherWeight;
          console.log("chargable weight", chargableWeight)

          // Convert to grams for API call
          const weightInGrams = higherWeight * 1000;
          console.log("weight in grams for rate calculation:", weightInGrams);

          // Get rate based on the higher weight
          const { rate, maxWeight } = await findRateAggrigator(partner.Aggrigator_id, originZone, weightInGrams);
          console.log("aggrigator rate:", rate);
          console.log("aggrigator max weight:", maxWeight);

          const standardTATResult = await mySqlQury(
            `SELECT days 
             FROM tbl_std_agg_tat 
             WHERE zone = ? AND aggrigator_id = ?`,
            [originZone, partner.Aggrigator_id]
          );
          console.log("standardTAT result:", standardTATResult);

          if (rate) {
            const tat = standardTATResult[0]?.days;
            console.log("TAT of aggrigator:", tat);

            // Check if we need to use minimum chargeable weight
            // const minimumChargableWeight = Number(maxWeight);
            // const maxWeightChargable = Math.max(higherWeight, minimumChargableWeight);
            // chargableWeight = maxWeightChargable;
            // console.log("Maximum Weight Used for Base Value Calculation in std aggrigator:", maxWeightChargable);

            // Calculate base value using the rate from findRateAggrigator
            const base_value = Number(rate);
            console.log("Base Value in std aggrigator:", base_value);

            const additionalChargesResult = await calculateAdditionalCharges(
              partner.Aggrigator_id,
              weightInKg,
              total_boxes,
              paymentType,
              rate,
              base_value,
              clientBaseValue,
              cod
            );

            console.log("here in the additional charges ", rate, additionalChargesResult.totalCharge);

            const totalRate = Number(rate) + Number(additionalChargesResult.totalCharge);

            rates.push({
              Aggrigator: partner.Aggrigator_company_name,

              rate: totalRate,
              baserate: Number(rate),
              forwarderTotalRateAndDetails: selectedForwarderDetails,
              days: tat,
              AggrigatorLogo: partner.tagged_logo,
              additionalCharges: {
                total: additionalChargesResult.totalCharge,
                breakdown: additionalChargesResult.chargesBreakdown || []
              },
              category: partner.aggrigator_type,
              service_type: partner.service_type,
              TaggedApi: taggedApi,
              weight_unit: 'gm',
              agg_defination: partner.agg_defination,
              Aggrigator_id: partner.Aggrigator_id,
              volumetricWeight: volumetricWeight,
              chargableWeight: chargableWeight,
              zones: {
                origin: pickupZone,
                destination: destinationZone
              },
              shipmentType: 'Standard'
            });
          } else {
            rates.push({
              forwarder: partner.name,
              rate: null,
              Aggrigator_id: partner.Aggrigator_id,
              message: 'No standard rate found'
            });
          }
        }

      } catch (error) {
        console.error('Error fetching forwarding partners:', error);
      }

    }

    console.log("Total rates:", rates);

    res.status(200).json({ rates });

  } catch (error) {
    console.error('Error fetching forwarding partners:', error);
    if (!res.headersSent) {
      res.status(500).json({ error: 'Internal Server Error' });
    }
  }
}
const getAggrigatorClientId = async (req, res, next) => {
  try {
    const { clientId } = req.params;
    const { orders } = req.query;
    const ordersList = JSON.parse(orders);
    console.log("Orders received for calculation:", ordersList);

    // Get client details
    const clientDetails = await mySqlQury(
      'SELECT * FROM tbl_admin WHERE id = ?',
      [clientId]
    );
    console.log("client id", clientId)
    // Step 1: Check if any aggregator is recommended
    const recommendedAggs = await mySqlQury(
      `SELECT 1 FROM tbl_client_aggrigator 
            WHERE client_id = ? AND status = 1 AND recommended = 1 LIMIT 1`,
      [clientId]
    );
    console.log("recommended aggs", recommendedAggs)


    // Get client's aggregators
    const aggrigatorList = await mySqlQury(
      `SELECT c.id, c.Aggrigator_id, c.name, c.service_type, c.category, 
                  c.tagged_api, c.tagged_logo, 
                  a.dispatch_agg, a.binded_with_forwarder, a.aggrigator_type, 
                  a.Aggrigator_company_name, a.status,
                  cu.minimum_chargable_weight, cu.volumetric_factor
           FROM tbl_client_aggrigator c
           JOIN tbl_aggrigator a ON c.Aggrigator_id = a.id
           JOIN tbl_customers cu ON a.id = cu.Aggrigator_id
           WHERE c.client_id = ? AND c.status = 1 AND a.status = 1
         ${recommendedAggs.length > 0 ? 'AND c.recommended = 1' : ''}`,
      [clientId]
    );
    console.log("aggrigator list in aggregators", aggrigatorList)
    // console.log("djsdjsfhdjs",agdwydg)

    let results = [];

    for (const order of ordersList) {
      // Extract order details
      const {
        po_no,
        total_weight,
        total_boxes,
        weight_unit,
        destination_pincode,
        origin_pincode,
        payment_type,
        box_dimensions,
        client_base_value,
        Invoice_amount: cod_amount
      } = order;

      console.log("client_base_value here", client_base_value)
      // console.log("Amount here",Amount)

      // Get pincode details
      const pickupPincodeDetails = await mySqlQury(
        `SELECT city, state, Zone FROM tbl_master_pincode WHERE pincode = ?`,
        [origin_pincode]
      );

      const destinationPincodeDetails = await mySqlQury(
        `SELECT city, state, Zone FROM tbl_master_pincode WHERE pincode = ?`,
        [destination_pincode]
      );

      if (!pickupPincodeDetails.length || !destinationPincodeDetails.length) {
        results.push({
          po_no,
          error: 'One or both pincodes not found in master pincode database'
        });
        continue;
      }

      const pickupCity = pickupPincodeDetails[0].city;
      const pickupState = pickupPincodeDetails[0].state;
      let pickupZone = pickupPincodeDetails[0].Zone;
      const destinationCity = destinationPincodeDetails[0].city;
      const destinationState = destinationPincodeDetails[0].state;
      let destinationZone = destinationPincodeDetails[0].Zone;

      let rates = [];

      for (const partner of aggrigatorList) {
        const forwarderTable = `tbl_zone_mapping_Aggrigator_${partner.Aggrigator_id}`;
        const tatTable = `tbl_TAT_Aggrigator_${partner.Aggrigator_id}`;
        let taggedApi = null;
        let selectedForwarderId = null;
        let forwarder_service_id = null;
        let lowestRate = Infinity;
        let selectedForwarderDetails = null;
        let forwarderTotalRateAndDetails = [];

        console.log("partner", partner.binded_with_forwarder)

        // Determine service type based on weight and box count
        const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);

        // Process forwarders if aggregator is binded with forwarders
        if (partner.binded_with_forwarder === 2 || partner.binded_with_forwarder === 1) {
          const forwarderDetails = await mySqlQury(
            `SELECT 
                    af.Forwarder_id, 
                    af.tagged_api, 
                    af.service_type,
                    vd.service_type as forwarder_service_type,
                    vd.minimum_chargable_weight, 
                    vd.volumetric_factor
                 FROM tbl_aggrigator_forwarder af
                 LEFT JOIN tbl_vendor_details vd ON af.Forwarder_id = vd.id
                 WHERE af.Aggrigator_id = ?`,
            [partner.Aggrigator_id]
          );

          if (forwarderDetails.length) {
            for (const forwarder of forwarderDetails) {
              let forwarderId = forwarder.Forwarder_id;
              let forwarderServiceId = forwarder.forwarder_service_type;
              let forwarderTaggedApi = forwarder.tagged_api;
              let totalRate = null;
              let tat = null;
              let forwarderOda = 0;

              if (forwarder.service_type === "LTL") {
                // Process LTL forwarder rates
                const pickupZoneQuery = `SELECT Zone FROM tbl_zone_mapping_${forwarderId} WHERE City = ? OR State = ?`;
                const destinationZoneQuery = `SELECT Zone FROM tbl_zone_mapping_${forwarderId} WHERE City = ? OR State = ?`;

                const pickupZoneResult = await mySqlQury(pickupZoneQuery, [pickupCity, pickupState]);
                const destinationZoneResult = await mySqlQury(destinationZoneQuery, [destinationCity, destinationState]);

                const originZone = pickupZoneResult.length > 0 ? pickupZoneResult[0].Zone : null;
                const destinationZone = destinationZoneResult.length > 0 ? destinationZoneResult[0].Zone : null;

                if (originZone && destinationZone) {
                  const rateResult = await mySqlQury(
                    `SELECT rate FROM tbl_vendor_rates WHERE zone_origin = ? AND zone_destination = ? AND vendor_id = ?`,
                    [originZone, destinationZone, forwarderId]
                  );

                  const tatResult = await mySqlQury(
                    `SELECT days FROM tbl_tat_${forwarderId} WHERE zone_origin = ? AND zone_destination = ?`,
                    [originZone, destinationZone]
                  );
                  forwarderOda = await checkOdaStatus(forwarderTaggedApi, origin_pincode, destination_pincode);

                  const totalVolumetricWeight = await calculateVolumetricWeightLTL(box_dimensions, forwarder.volumetric_factor);
                  const minimumChargableWeight = Number(forwarder.minimum_chargable_weight);
                  const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);
                  const maxWeight = Math.max(weightInKg, totalVolumetricWeight, minimumChargableWeight);

                  if (rateResult.length && tatResult.length) {
                    const rate = Number(rateResult[0].rate);
                    tat = tatResult[0].days;
                    const base_value = rate * Math.ceil(maxWeight);

                    const additionalChargesResult = await calculateAdditionalChargesForwarder(
                      forwarderId,
                      weightInKg,
                      total_boxes,
                      payment_type,
                      rate,
                      base_value,
                      client_base_value,
                      cod_amount
                    );

                    totalRate = Number(base_value) + Number(additionalChargesResult.totalCharge);

                    if (totalRate < lowestRate) {
                      lowestRate = totalRate;
                      selectedForwarderId = forwarderId;
                      forwarder_service_id = forwarderServiceId;
                      taggedApi = forwarderTaggedApi;
                    }

                    forwarderTotalRateAndDetails.push({
                      forwarderId: forwarderId,
                      forwarderOda: forwarderOda,
                      chargableWeight: weight_unit === 'gm' ? maxWeight * 1000 : maxWeight,
                      baserate: Number(base_value),
                      Totalrate: Number(totalRate),
                      tat: tat,
                      taggedApi: forwarderTaggedApi,
                      additionalCharges: {
                        total: additionalChargesResult.totalCharge,
                        breakdown: additionalChargesResult.chargesBreakdown
                      }
                    });
                  }
                }
              } else if (forwarder.service_type === "standard") {
                // Process standard forwarder rates
                if (['expressbees', 'delhivery'].includes(forwarderTaggedApi.toLowerCase())) {
                  const isServiceable = await checkServiceability(
                    forwarderTaggedApi,
                    origin_pincode,
                    destination_pincode,
                    total_weight,
                    payment_type,
                    client_base_value,
                    weight_unit
                  );

                  if (!isServiceable) {
                    continue;
                  }
                }

                const originZone = await determineForwarderOriginZone(
                  forwarderId,
                  pickupCity,
                  destinationCity,
                  pickupState,
                  destinationState,
                  pickupZone,
                  destinationZone
                );

                if (originZone) {
                  const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);
                  const totalVolumetricWeight = await calculateVolumetricWeight(box_dimensions, partner.volumetric_factor);
                  const higherWeight = Math.max(weightInKg, totalVolumetricWeight);
                  const weightInGrams = higherWeight * 1000;

                  const { rate, maxWeight } = await findRateForwarder(forwarderId, originZone, weightInGrams);

                  const standardTATResult = await mySqlQury(
                    `SELECT days FROM tbl_standard_tat WHERE zone = ? AND vendor_id = ?`,
                    [originZone, forwarderId]
                  );

                  if (rate && standardTATResult.length) {
                    tat = standardTATResult[0].days;
                    const base_value = Number(rate);

                    const additionalChargesResult = await calculateAdditionalChargesForwarder(
                      forwarderId,
                      weightInKg,
                      total_boxes,
                      payment_type,
                      rate,
                      base_value,
                      client_base_value,
                      cod_amount
                    );

                    totalRate = Number(rate) + Number(additionalChargesResult.totalCharge);

                    if (totalRate < lowestRate) {
                      lowestRate = totalRate;
                      selectedForwarderId = forwarderId;
                      forwarder_service_id = forwarderServiceId;
                      taggedApi = forwarderTaggedApi;
                    }

                    forwarderTotalRateAndDetails.push({
                      chargableWeight: weight_unit === 'gm' ? higherWeight * 1000 : higherWeight,
                      forwarderOda: forwarderOda,
                      forwarderId: forwarderId,
                      baserate: Number(rate),
                      Totalrate: totalRate,
                      tat: tat,
                      taggedApi: forwarderTaggedApi,
                      additionalCharges: {
                        total: additionalChargesResult.totalCharge,
                        breakdown: additionalChargesResult.chargesBreakdown
                      }
                    });
                  }
                }
              }
            }
          }
        }
        console.log("forwarderTotalRateAndDetails", forwarderTotalRateAndDetails)

        selectedForwarderDetails = forwarderTotalRateAndDetails.find(detail => detail.forwarderId === selectedForwarderId);
        console.log("selected forwarder details in the get-aggregators", selectedForwarderDetails)

        // Process aggregator's own rates
        let chargableWeight = 0;

        try {
          if (partner.service_type === 'LTL') {
            // Process LTL aggregator rates
            const pickupZoneDetails = await mySqlQury(
              `SELECT zone FROM ?? WHERE city = ? OR state = ?`,
              [forwarderTable, pickupCity, pickupState]
            );

            const destinationZoneDetails = await mySqlQury(
              `SELECT zone FROM ?? WHERE city = ? OR state = ?`,
              [forwarderTable, destinationCity, destinationState]
            );

            if (pickupZoneDetails.length && destinationZoneDetails.length) {
              const rateDetails = await mySqlQury(
                `SELECT rate FROM tbl_client_rates 
                     WHERE Aggrigator_id = ? 
                     AND zone_origin = ? 
                     AND zone_destination = ?`,
                [
                  partner.Aggrigator_id,
                  pickupZoneDetails[0].zone,
                  destinationZoneDetails[0].zone,
                ]
              );

              const tatDetails = await mySqlQury(
                `SELECT days FROM ?? 
                     WHERE Aggrigator_id = ? 
                     AND zone_origin = ? 
                     AND zone_destination = ?`,
                [
                  tatTable,
                  partner.Aggrigator_id,
                  pickupZoneDetails[0].zone,
                  destinationZoneDetails[0].zone
                ]
              );

              if (rateDetails.length > 0 && tatDetails.length > 0) {
                const tat = tatDetails[0].days;
                const totalVolumetricWeight = await calculateVolumetricWeightLTL(box_dimensions, partner.volumetric_factor);
                const minimumChargableWeight = Number(partner.minimum_chargable_weight);
                const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);
                const maxWeight = Math.max(weightInKg, totalVolumetricWeight, minimumChargableWeight);
                chargableWeight = maxWeight;

                const rate = Number(rateDetails[0].rate);
                const base_value = rate * Math.ceil(maxWeight);

                const additionalChargesResult = await calculateAdditionalCharges(
                  partner.Aggrigator_id,
                  weightInKg,
                  total_boxes,
                  payment_type,
                  rate,
                  base_value,
                  client_base_value,
                  cod_amount
                );
                const aggrigatorOda = await checkOdaStatus(partner.tagged_api, origin_pincode, destination_pincode);
                const totalRate = Number(base_value) + Number(additionalChargesResult.totalCharge);

                rates.push({
                  po_no,
                  aggrigatorOdaFactor: aggrigatorOda,
                  Aggrigator: partner.Aggrigator_company_name,
                  rate: totalRate,
                  baserate: Number(base_value),
                  forwarderTotalRateAndDetails: selectedForwarderDetails || [], // Ensure array is sent even if empty
                  days: tat,
                  AggrigatorLogo: partner.tagged_logo,
                  additionalCharges: {
                    total: additionalChargesResult.totalCharge,
                    breakdown: additionalChargesResult.chargesBreakdown || []
                  },
                  category: partner.aggrigator_type,
                  service_type: partner.service_type,
                  TaggedApi: taggedApi ? taggedApi : partner.tagged_api,
                  agg_defination: partner.agg_defination,
                  forwarder_servise_id: forwarder_service_id,
                  Aggrigator_id: partner.Aggrigator_id,
                  chargableWeight: weight_unit === 'gm' ? maxWeight * 1000 : maxWeight,
                  weight_unit: weight_unit ? weight_unit : "gm",
                  zones: {
                    origin: pickupZoneDetails[0].zone,
                    destination: destinationZoneDetails[0].zone
                  },
                  shipmentType: 'LTL'
                });
              }
            }
          } else {
            // Process standard aggregator rates
            const originZone = await determineOriginZoneAggregator(
              partner.Aggrigator_id,
              pickupCity,
              destinationCity,
              pickupState,
              destinationState,
              pickupZone,
              destinationZone
            );

            if (originZone) {
              const totalVolumetricWeight = await calculateVolumetricWeight(box_dimensions, partner.volumetric_factor);
              const weightInKg = weight_unit === 'gm' ? Number(total_weight) / 1000 : Number(total_weight);
              const higherWeight = Math.max(weightInKg, totalVolumetricWeight);
              const weightInGrams = higherWeight * 1000;

              const { rate, maxWeight } = await findRateAggrigator(partner.Aggrigator_id, originZone, weightInGrams);

              const standardTATResult = await mySqlQury(
                `SELECT days FROM tbl_std_agg_tat WHERE zone = ? AND aggrigator_id = ?`,
                [originZone, partner.Aggrigator_id]
              );

              if (rate && standardTATResult.length) {
                const tat = standardTATResult[0].days;
                const base_value = Number(rate);

                const additionalChargesResult = await calculateAdditionalCharges(
                  partner.Aggrigator_id,
                  weightInKg,
                  total_boxes,
                  payment_type,
                  rate,
                  base_value,
                  client_base_value,
                  cod_amount
                );

                const totalRate = Number(rate) + Number(additionalChargesResult.totalCharge);
                let aggrigatorOda = 0;


                rates.push({
                  po_no,
                  Aggrigator: partner.Aggrigator_company_name,
                  rate: totalRate,

                  baserate: Number(rate),
                  forwarderTotalRateAndDetails: selectedForwarderDetails || [], // Ensure array is sent even if empty
                  days: tat,
                  AggrigatorLogo: partner.tagged_logo,
                  additionalCharges: {
                    total: additionalChargesResult.totalCharge,
                    breakdown: additionalChargesResult.chargesBreakdown || []
                  },
                  category: partner.aggrigator_type,
                  service_type: partner.service_type,
                  TaggedApi: taggedApi ? taggedApi : partner.tagged_api,
                  forwarder_servise_id: forwarder_service_id,
                  weight_unit: weight_unit ? weight_unit : "gm",
                  agg_defination: partner.agg_defination,
                  Aggrigator_id: partner.Aggrigator_id,
                  chargableWeight: weight_unit === 'gm' ? higherWeight * 1000 : higherWeight,
                  zones: {
                    origin: pickupZone,
                    destination: destinationZone
                  },
                  shipmentType: 'Standard'
                });
              }
            }
          }
        } catch (error) {
          console.error(`Error processing aggregator ${partner.Aggrigator_id} for PO ${po_no}:`, error);
        }
      }

      // Group rates by service type for this PO
      const groupedRates = rates.reduce((acc, rate) => {
        const serviceType = rate.service_type;
        if (!acc[serviceType]) {
          acc[serviceType] = [];
        }
        acc[serviceType].push(rate);
        return acc;
      }, {});

      results.push({
        po_no,
        rates: groupedRates
      });
    }

    // Log the fetched aggregator details
    console.log("Aggregator Details by Client:", aggrigatorList);
    console.log("Client Details:", clientDetails);

    // Send the response as JSON
    res.json({
      title: 'Aggregators for Client',
      clientId,
      results
    });
  } catch (error) {
    console.error('Error fetching aggregators by client:', error);
    next(error); // Pass error to middleware
  }
}
const chekWalletAmount = async (req, res) => {
  const clientId = req.query.clientId;
  console.log("clientId in the check wallet amount", clientId);

  try {
    if (!clientId) {
      return res.status(200).json({ total_amount: 0 });
    }

    // Assuming you have a database connection established
    const wallet = await mySqlQury("SELECT total_amount FROM tbl_wallet WHERE user_id = ?", [clientId]);
    console.log("wallet", wallet);

    // Return 0 if no wallet found or wallet has no records
    const totalAmount = wallet.length > 0 ? wallet[0].total_amount : 0;
    res.status(200).json({ total_amount: totalAmount });

  } catch (error) {
    console.error("Error fetching wallet amount:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
}
const updateWallet = async (req, res) => {
  const { clientId, totalRate, po_no, lr_no, originZone, destinationZone, description, Totalweight, unitweight } = req.body;
  console.log("Updating wallet for clientId:", clientId, "with totalRate:", totalRate);
  try {
    const result = await updateWalletAndTransaction(
      clientId,
      totalRate,
      po_no,
      lr_no,
      originZone,
      destinationZone,
      description,
      Totalweight,
      unitweight
    );

    res.status(200).json(result);

  } catch (error) {
    console.error("Error updating wallet:", error);

    if (error.message === "Wallet not found for the given clientId.") {
      res.status(404).json({ error: error.message });
    } else if (error.message === "Insufficient funds in wallet.") {
      res.status(400).json({ error: error.message });
    } else {
      res.status(500).json({ error: "Internal Server Error" });
    }
  }
}
const apiMasterPincode = async (req, res) => {
  try {
    let { pincode, city, state, zone } = req.body;
    console.log("pincode", pincode, city, state, zone)

    if (!pincode || !city || !state || !zone) {
      return res.status(400).json({ error: 'All fields are must' });
    }

    // Convert all inputs to uppercase and trim spaces
    pincode = pincode.toString().toUpperCase();
    city = city.toUpperCase();
    state = state.toUpperCase();
    zone = zone.toUpperCase();

    // Check if the pincode already exists
    const checkQuery = 'SELECT COUNT(*) AS count FROM tbl_master_pincode WHERE pincode = ?';
    const checkResult = await mySqlQury(checkQuery, [pincode]);

    if (checkResult[0].count > 0) {
      return res.status(400).json({ error: 'Pincode is already in master' });
    }

    // Insert the new pincode
    const insertQuery = 'INSERT INTO tbl_master_pincode (pincode, city, state, Zone) VALUES (?, ?, ?, ?)';
    const values = [pincode, city, state, zone];

    const result = await mySqlQury(insertQuery, values);

    res.status(201).json({ message: 'Pincode data added successfully', id: result.insertId });
  } catch (error) {
    console.error('Server Error:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
}
const getManualLr = async (req, res) => {
  try {
    // Extract query parameters from the request
    const { aggid, clientId, taggedApi, category } = req.query;
    console.log("Received parameters:", aggid, clientId, taggedApi);

    // Build the query based on the received parameters
    let query = `
          SELECT 
            m.*, 
            c.minimum_chargable_weight, 
            c.volumetric_factor, 
            c.fod, 
            c.billclient, 
            c.owner_risk, 
            c.carrier_risk, 
            c.courier_name
          FROM tbl_manuallrs m
          JOIN tbl_customers c ON m.aggrigator_id = c.aggrigator_id
          WHERE m.status = 1
        `;

    // Add conditions to the query if parameters are provided
    if (aggid) {
      query += ` AND m.aggrigator_id = ${aggid}`;
    }
    if (clientId) {
      query += ` AND m.Client_id = ${clientId}`;
    }
    if (taggedApi) {
      query += ` AND m.lr_forwarder = '${taggedApi}'`;
    }
    if (category) {
      query += ` AND m.product_type = '${category}'`;
    }

    // Execute the query
    const manualLrData = await mySqlQury(query);
    console.log("Manual LR Data:", manualLrData);

    // Return the result
    res.status(200).json(manualLrData);
  } catch (error) {
    console.error("Error fetching manual LR data:", error);
    res.status(500).json({ message: "Error fetching manual LR data." });
  }
}
const getTaggedApi = async (req, res) => {
  const { aggid } = req.query;

  if (!aggid) {
    return res.status(400).json({ message: 'Aggregator ID (aggid) is required' });
  }

  try {
    // Query to fetch the relevant data
    const query = `
          SELECT id, Aggrigator_id, servisibility_table, Tagged_api 
          FROM tbl_aggrigator_servisibility 
          WHERE Aggrigator_id = ?
        `;
    const result = await mySqlQury(query, [aggid]);

    if (result.length === 0) {
      return res.status(404).json({ message: 'No data found for the given aggid' });
    }

    res.json(result[0]); // Return the first matching result
  } catch (error) {
    console.error('Error fetching tagged API:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
}
const billclientdata = async (req, res) => {
  try {
    // Extract aggrigatorid from query parameters
    const { aggrigatorid } = req.query;
    console.log("Received aggrigatorid:", aggrigatorid);

    // Query to fetch data from tbl_customers
    const query = `
          SELECT 
            c.fod, 
            c.billclient, 
            c.owner_risk, 
            c.carrier_risk, 
            c.courier_name
          FROM tbl_customers c
          WHERE c.aggrigator_id = ?`; // Using ? to prevent SQL injection

    // Execute the query and pass the aggrigatorid
    const result = await mySqlQury(query, [aggrigatorid]);

    // If no data found, return a message
    if (result.length === 0) {
      return res.status(404).json({ message: "No data found for the given aggrigatorid." });
    }

    console.log("Bill client data:", result);

    // Return the result
    res.status(200).json(result[0]); // Return the first result object
  } catch (error) {
    console.error("Error fetching bill client data:", error);
    res.status(500).json({ message: "Error fetching bill client data." });
  }
}
const apiGetOdaCharges =async (req, res) => {
  try {
    const { aggrigatorId, odaFactor,total_weight,
      total_boxes, paymentType,rate,
      base_value,
      clientBaseValue:invoice_amount,
      cod_amount} = req.query;

    // Validate required parameters
    if (!aggrigatorId) {
      return res.status(400).json({ error: 'Aggregator ID is required' });
    }

    // Query to get ODA charge from tbl_additional_charges_client
    const query = `
      SELECT charge_name, min_value, max_value, calculation_based_on_min, calculation_based_on_max, condition_based 
      FROM tbl_additional_charges_client 
      WHERE Aggrigator_id = ? AND charge_name = 'oda_charge'
    `;

    const result = await mySqlQury(query, [aggrigatorId]);

    if (!result || result.length === 0) {
      return res.status(404).json({ error: 'ODA charge not found' });
    }

    const odaCharge = result[0];
    let finalCharge = 0;

    // Calculate ODA charge based on conditions
if (odaCharge.condition_based === 'and') {
  // For 'and' condition, calculate both min and max values based on their calculation types
  const minCharge = calculateChargeValue(
    odaCharge.calculation_based_on_min,
    odaCharge.min_value,
    total_weight,
    total_boxes,
    base_value,
    invoice_amount,
    cod_amount
  );

  const maxCharge = calculateChargeValue(
    odaCharge.calculation_based_on_max,
    odaCharge.max_value,
    total_weight,
    total_boxes,
    base_value,
    invoice_amount,
    cod_amount
  );

  finalCharge = minCharge + maxCharge;
} else {
  // For 'or' condition, calculate both values and compare based on chargable_value_type
  const minCharge = calculateChargeValue(
    odaCharge.calculation_based_on_min,
    odaCharge.min_value,
    total_weight,
    total_boxes,
    base_value,
    invoice_amount,
    cod_amount
  );

  const maxCharge = calculateChargeValue(
    odaCharge.calculation_based_on_max,
    odaCharge.max_value,
    total_weight,
    total_boxes,
    base_value,
    invoice_amount,
    cod_amount
  );

  finalCharge = odaCharge.chargable_value_type === 'higher' 
    ? Math.max(minCharge, maxCharge)
    : Math.min(minCharge, maxCharge);
}

    // Apply ODA factor if provided
    if (odaFactor && !isNaN(odaFactor)) {
      finalCharge *= Number(odaFactor);
    }
    
    res.json({
      oda_charge: finalCharge,
      
    });

  } catch (error) {
    console.error('Error fetching ODA charges:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
const getAllOrders = async (req, res, next) => {
  try {
    // Fetch data from the database
    const orderData = await mySqlQury(`SELECT * FROM tbl_all_orders`);
    console.log("data from all orders", orderData);


    // Define table columns based on the orderData
    const table = {
      columns: [
        "Sr. No.",
        "Order Number",
        "Added On",
        "Last Update by FZ",
        "Last Update by Shipper",
        "Status",
        "Shipper",
        "Airwaybill",
        "Seller",
        "Channel",
        "Pickup Details",
        "Customer Name",
        "Customer Phone",
        "Payment Type",
        "Gross Amount",
        "Actions",
        "Invoice",
        "Supporting Document",
        "Tracking Id"
      ],
      data: orderData.map((order, index) => [
        index + 1, // Sr. No.
        order.order_number,
        new Date(order.added_on).toLocaleDateString(),
        new Date(order.last_update_fz).toLocaleDateString(),
        new Date(order.last_update_shipper).toLocaleDateString(),
        order.status,
        order.shipper || 'N/A',
        order.airway_bill,
        order.seller,
        order.channel || 'N/A',
        order.pickup_details,
        order.customer_name || 'N/A',
        order.customer_phone,
        order.payment_type || 'N/A',
        order.gross_amount,
        order.actions || 'N/A',
        order.invoice || 'N/A',
        order.supporting_document || 'N/A',
        order.tracking_id
      ])
    };

    // Fetch additional data
    const accessdata = await access(req.user);
    const role_data = req.user;
    const lang_data = req.language_data;
    const language_name = req.lang;
    const notification_data = await mySqlQury(`SELECT * FROM tbl_notification WHERE received = '${role_data.id}' ORDER BY id DESC LIMIT 3`);

    // Render the EJS template
    if (role_data.role == 1) {
      res.render('all_orders', {
        role_data: role_data,
        accessdata: accessdata,
        lang_data: lang_data,
        language_name: language_name,
        notification_data: notification_data,
        table: table
      });
    } else {
      res.status(403).json({ success: false, message: 'Unauthorized access' });
    }
  } catch (error) {
    console.log(error);
    res.status(500).json({ success: false, message: 'Error processing the request' });
  }
}
const orderDetailsOrderNumber = async (req, res, next) => {
  try {
    const orderNumber = req.params.orderNumber;
    const orderDetails = await mySqlQury(`SELECT * FROM tbl_all_orders WHERE order_number = '${orderNumber}'`);
    console.log("order details of individual", orderDetails);

    if (!orderDetails.length) {
      return res.status(404).json({ success: false, message: 'Order not found' });
    }

    const accessdata = await access(req.user);
    const role_data = req.user;
    const lang_data = req.language_data;
    const language_name = req.lang;
    const notification_data = await mySqlQury(`SELECT * FROM tbl_notification WHERE received = '${role_data.id}' ORDER BY id DESC LIMIT 3`);

    console.log("orderNumber>>>", orderNumber);
    if (role_data.role == 1) {
      res.render('track_me', {
        role_data: role_data,
        accessdata: accessdata,
        lang_data: lang_data,
        language_name: language_name,
        notification_data: notification_data,
        orderDetails: orderDetails[0] // Pass the first element of the orderDetails array
      });
    } else {
      res.status(403).json({ success: false, message: 'Unauthorized access' });
    }
  } catch (error) {
    console.log(error);
    res.status(500).json({ success: false, message: 'Error processing the request' });
  }
}
const forwarderOnboarding = async (req, res, next) => {
  try {
    const accessdata = await access(req.user);
    const role_data = req.user;
    const lang_data = req.language_data;
    const language_name = req.lang;
    const notification_data = await mySqlQury(`SELECT * FROM tbl_notification WHERE received = '${role_data.id}' ORDER BY id DESC LIMIT 3`);
    const result = await mySqlQury(`SELECT * FROM tbl_vendor_details ORDER BY id DESC;`)

    if (role_data.role == 1) {
      res.render('onboarding', {
        role_data: role_data,
        accessdata: accessdata,
        lang_data: lang_data,
        language_name: language_name,
        notification_data: notification_data,
        result: result,
      });
    } else {
      res.status(403).json({ success: false, message: 'Unauthorized access' });
    }
  } catch (error) {
    console.log(error);
    res.status(500).json({ success: false, message: 'Error processing the request' });
  }
}
const aggrigatorOnboarding = async (req, res, next) => {
  try {
    const accessdata = await access(req.user);
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    const lang_data = req.language_data;
    const language_name = req.lang;
    let walletBalance = 0;
    let vasService = 0;
    console.log("req.user", req.user)

    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = ? ORDER BY id DESC LIMIT 3`,
      [role_data.id]
    );
    const clients = await mySqlQury(`SELECT client_id, company_name FROM tbl_customers`);
    const states = await mySqlQury(`SELECT DISTINCT state FROM tbl_master_pincode`);
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    let loginDetails = null;
    let clientId = 0;

    // Get login details based on selectedClientId
    if (selectedClientId === 1) {
      // For admin (selectedClientId = 1), get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    } else {
      // For specific client, get details from tbl_admin using selectedClientId
      const clientDetails = await mySqlQury(
        'SELECT id, first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [selectedClientId]
      );
      if (clientDetails && clientDetails.length > 0) {
        loginDetails = clientDetails[0];
        clientId = selectedClientId;
      }
      
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [selectedClientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`, 
      [req.user.id]
    );

// Backend Query Fix - Update your Node.js route
const forwarderList = await mySqlQury(`
  SELECT 
    c.id, 
    c.company_name, 
    c.courier_type, 
    c.service_type, 
    c.Tagged_api, 
    c.business_volume,
    c.packet_shipment,
    c.delhivery_api_variant,
    p.id as plan_id,
    p.name AS plan_name,
    p.min_volume,
    p.max_volume
  FROM tbl_courier_details c
  LEFT JOIN plans p ON c.business_volume = p.id
  WHERE c.courier_type != "LTL"
`);

// Create shipment buckets mapping for easier lookup
const shipmentBuckets = {
  1: { min: 0, max: 500, label: '0 - 500 Shipment' },
  2: { min: 500, max: 1000, label: '500 - 1000 Shipment' },
  3: { min: 1000, max: 1500, label: '1000 - 1500 Shipment' },
  4: { min: 1500, max: 2000, label: '1500 - 2000 Shipment' },
  5: { min: 2000, max: 2500, label: '2000 - 2500 Shipment' },
  6: { min: 2500, max: 3000, label: '2500 - 3000 Shipment' },
  7: { min: 3000, max: 3500, label: '3000 - 3500 Shipment' },
  8: { min: 3500, max: 4000, label: '3500 - 4000 Shipment' },
  9: { min: 4000, max: null, label: '4000 Above' }
};
    
    let activeTopicIds = [];
    if (activeTopics && Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    res.render('pages/aggrigator-onboarding', {
      role_data,
      accessdata,
      bodyClass: 'profile-page',
      activePage: 'profile',
      title: 'Aggrigator Onboarding',
      layout: 'partials/layout-vertical',
      lang_data,
      language_name,
      notification_data,
      forwarderList,
      shipmentBuckets, // pass to EJS,
      clients,
      states: states.map(row => row.state),
      activeTopicIds,
      loginDetails: loginDetails || {},
      profile,
      clientId,
      walletBalance,
      vasService,
      role
    });

  } catch (error) {
    console.error('Error in aggrigator onboarding:', error);
    res.status(500).send('Internal Server Error');
  }
}
const predispatchForwarderOnboarding = async (req, res) => {
  // const connection = await mySqlQury('START TRANSACTION'); // Start the transaction
  console.log("files", req.files)
  console.log("req file", req.file)
  console.log("dsdgsj", req.body)
  const excelFile = req.files.find(file => file.fieldname === 'form3[rateExcelFile]');
  // console.log("djshdjsd",djdhjsghdjsgd)

  await mySqlQury('START TRANSACTION');
  try {
    let logoPath = null;

    // Check if files are uploaded
    if (req.files && req.files.length > 0) {
      logoPath = req.files[0].path.replace(/\\/g, '/'); // Normalize the path to use forward slashes
      logoPath = logoPath.replace(/^.*[\\/]public[\\/]/, ''); // Make the path relative to the public directory
      console.log("Logo path:", logoPath);
    } else {
      console.log("No file uploaded.");
    }
    console.log("lofo path:", logoPath);

    console.log('Vendor data is uploading:');
    console.log("req.body", req.body);
    const form1ValidationErrors = validateForwarderForm1(req.body.form1, req.files, req.body.form3.volumetric_);
    if (form1ValidationErrors) {
      return res.status(400).json({
        status: 'error',
        message: 'Form 1 validation failed',
        errors: form1ValidationErrors
      });
    }
    const { form1, form2, form3, form4, form5, form6 } = req.body;
    console.log("req.body destructuring", form3.volumetric_, form3['Min.charges_weight']);
    let forwarderActualType = "LTL";

    console.log("form3", form5)
    // console.log("fjshdfjsgfshfghsfghj",hyyfyftftfty)

    console.log("forward", forwarderActualType, form1.forwarderType)

    //  console.log("gsjd", jsdjs)
    // console.log("dsdhs",dkshdshd)
    // Insert Vendor Details
    const insertVendorSql = `
          INSERT INTO tbl_vendor_details (
            forwarder_name, forwarder_type, service_type, company_name, company_address, 
            company_country, company_state, company_district, website, from_date, 
            from_to, choose_bank, ifsc_code, account_number, gst_no, credit_terms, 
            billing_cycle,volumetric_factor,minimum_chargable_weight,company_pan_code,company_vat,company_uin,company_bank_account,shipment_type,	Tagged_api,logo_path,productType,email_id,phone	
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?,?,?,?,?,?,?,?,?,?,?,?)
        `;
    const vendorValues = [
      form1.forwarderName, forwarderActualType, form1.forwarderType, form1.companyName,
      form1.companyAddress, form1.companyCountry, form1.companyState, form1.companyDistrict,
      form1.website, form1.fromDate, form1.fromTo, form1.chooseBank, form1.ifscCode,
      form1.accountNumber, form1.gstNo, form1.creditTerms, form1.billingCycle, form3.volumetric_, form3['Min.charges_weight'], form1.company_pan, form1.vat, form1.company_uin, form1.Bank_account_name,
      form1.shipmentType, form1.chooseAPi, logoPath, form1.ProductType, form1.forwarder_Email, form1.forwarder_mobile
    ];
    const result = await mySqlQury(insertVendorSql, vendorValues);
    const vendorId = result.insertId;
    const forwarderId = vendorId
    const forwarderName = form1.companyName.replace(/\s+/g, ''); // Removes all spaces
    const forwarderType = form1.forwarderType;
    // Assuming mySqlQury returns the result with insertId

    // Helper function to insert contacts
    // const contactTypes = ['sales', 'ops', 'accounts', 'rvp'];

    // for (const type of contactTypes) {
    //   const names = form2[`${type}_name[]`] || [];
    //   const designations = form2[`${type}_designation[]`] || [];
    //   const emails = form2[`${type}_email[]`] || [];
    //   const phones = form2[`${type}_phone[]`] || [];

    //   const insertContactSql = `
    //     INSERT INTO tbl_vendor_contacts (
    //       vendor_id, name, phone, email, designation, department
    //     ) VALUES (?, ?, ?, ?, ?, ?)
    //   `;

    //   const maxContacts = Math.max(names.length, designations.length, emails.length, phones.length);

    //   for (let i = 0; i < maxContacts; i++) {
    //     const contactValues = [
    //       vendorId,
    //       names[i] || null,
    //       phones[i] || null,
    //       emails[i] || null,
    //       designations[i] || null,
    //       type
    //     ];
    //     await mySqlQury(insertContactSql, contactValues);
    //   }
    // }
    // Insert Rates
    const insertRateSql = `
          INSERT INTO tbl_vendor_rates (
            vendor_id, zone_origin, zone_destination, forwarder_type, service_type, rate
          ) VALUES (?, ?, ?, ?, ?, ?)
        `;

    const rateEntries = [];

    if (excelFile) {
      const XLSX = require('xlsx');
      const workbook = XLSX.readFile(excelFile.path);

      // Find the LTL Rate sheet
      const ltlRateSheet = workbook.Sheets['LTL Rate'];
      if (ltlRateSheet) {
        const sheetData = XLSX.utils.sheet_to_json(ltlRateSheet);

        // Process each row in the sheet
        for (const row of sheetData) {
          const zoneOrigin = row.Zone; // This is the origin zone (like 'N1')

          // Skip rows that only have Zone property with no values
          const hasRates = Object.keys(row).length > 1;

          if (hasRates) {
            // Process each destination zone and its rate
            for (const [key, value] of Object.entries(row)) {
              // Skip the 'Zone' column as it's the origin
              if (key !== 'Zone' && value !== undefined) {
                const zoneDest = key; // This is the destination zone
                const rateValue = parseFloat(value);

                if (!isNaN(rateValue)) {
                  rateEntries.push([
                    vendorId,
                    zoneOrigin,
                    zoneDest,
                    form1.forwarderType,
                    form1.serviceType,
                    rateValue
                  ]);
                }
              }
            }
          }
        }
      }

      // Find and process the TAT sheet
      const tatSheet = workbook.Sheets['LTL TAT'];
      if (tatSheet) {
        const table2Name = `tbl_tat_${forwarderId}`;

        // Create TAT table
        const createTable2SQL = `
              CREATE TABLE IF NOT EXISTS ${table2Name} (
                  id BIGINT(20) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
                  forwarder_id BIGINT(20) UNSIGNED,
                  zone_origin VARCHAR(50),
                  zone_destination VARCHAR(50), 
                  days INT,
                  FOREIGN KEY (forwarder_id) REFERENCES tbl_vendor_details(id) ON DELETE CASCADE,
                  UNIQUE KEY (zone_origin, zone_destination, forwarder_id)
              )
            `;
        await mySqlQury(createTable2SQL);
        console.log(`Table ${table2Name} created or already exists.`);

        const tatData = XLSX.utils.sheet_to_json(tatSheet);

        // Process TAT data
        for (const row of tatData) {
          const zoneOrigin = row.Zone;

          for (const [zoneDest, daysValue] of Object.entries(row)) {
            if (zoneDest !== 'Zone') {
              const days = parseFloat(daysValue);

              if (!isNaN(days) && days > 0) {
                await mySqlQury(
                  `INSERT IGNORE INTO ${table2Name} (forwarder_id, zone_origin, zone_destination, days)
                       VALUES (?, ?, ?, ?)`,
                  [forwarderId, zoneOrigin, zoneDest, days]
                );
                console.log(`Inserted TAT: ${zoneOrigin} to ${zoneDest} with days: ${days}`);
              } else {
                console.error('Invalid days value:', daysValue);
              }
            }
          }
        }
      } else {
        console.error('LTL TAT sheet not found in Excel file');
      }
    }

    for (const entry of rateEntries) {
      await mySqlQury(insertRateSql, entry);
    }
    // Insert Additional Charges
    const additionalCharges = [
      {
        charge_name: 'lr',
        min_value: form4.lr_min_value,
        max_value: form4.lr_max_value,
        condition_based: form4.lr_condition,
        max_value_calculation: form4.lr_condition === 'and' ? null : form4.charge_type_lr_or,
        calculation_based_on_min: form4.lr_charge_based_calculation || null,
        calculation_based_on_max: form4.lr_criteria_charge || null
      },
      {
        charge_name: 'fs',
        min_value: form4.fs_min_value,
        max_value: form4.fs_max_value,
        condition_based: form4.fs_condition,
        max_value_calculation: form4.fs_condition === 'and' ? null : form4.charge_type_fs_or,
        calculation_based_on_min: form4.fs_charge_based_calculation || null,
        calculation_based_on_max: form4.fs_criteria_charge || null
      },
      {
        charge_name: 'fm',
        min_value: form4.fm_min_value,
        max_value: form4.fm_max_value,
        condition_based: form4.fm_condition,
        max_value_calculation: form4.fm_condition === 'and' ? null : form4.charge_type_fm_or,
        calculation_based_on_min: form4.fm_charge_based_calculation || null,
        calculation_based_on_max: form4.fm_criteria_charge || null
      },
      {
        charge_name: 'fov_owner',
        min_value: form4.fov_owner_min_value,
        max_value: form4.fov_owner_max_value,
        condition_based: form4.fov_owner_condition,
        max_value_calculation: form4.fov_owner_condition === 'and' ? null : form4.charge_type_fov_owner_or,
        calculation_based_on_min: form4.fov_owner_charge_based_calculation || null,
        calculation_based_on_max: form4.fov_owner_criteria_charge || null
      },
      {
        charge_name: 'to_pay',
        min_value: form4.to_pay_min_value,
        max_value: form4.to_pay_max_value,
        condition_based: form4.to_pay_condition,
        max_value_calculation: form4.to_pay_condition === 'and' ? null : form4.charge_type_to_pay_or,
        calculation_based_on_min: form4.to_pay_charge_based_calculation || null,
        calculation_based_on_max: form4.to_pay_criteria_charge || null
      },
      {
        charge_name: 'cod',
        min_value: form4.cod_min_value,
        max_value: form4.cod_max_value,
        condition_based: form4.cod_condition,
        max_value_calculation: form4.cod_condition === 'and' ? null : form4.charge_type_cod_or,
        calculation_based_on_min: form4.cod_charge_based_calculation || null,
        calculation_based_on_max: form4.cod_criteria_charge || null
      },
      {
        charge_name: 'check_handling_weight',
        min_value: form4.check_handling_weight_min_value,
        max_value: form4.check_handling_weight_max_value,
        condition_based: form4.check_handling_weight_condition,
        max_value_calculation: form4.check_handling_weight_condition === 'and' ? null : form4.charge_type_check_handling_weight_or,
        calculation_based_on_min: form4.check_handling_weight_charge_based_calculation || null,
        calculation_based_on_max: form4.check_handling_weight_criteria_charge || null
      },
      {
        charge_name: 'green_tax',
        min_value: form4.green_tax_min_value,
        max_value: form4.green_tax_max_value,
        condition_based: form4.green_tax_condition,
        max_value_calculation: form4.green_tax_condition === 'and' ? null : form4.charge_type_green_tax_or,
        calculation_based_on_min: form4.green_tax_charge_based_calculation || null,
        calculation_based_on_max: form4.green_tax_criteria_charge || null
      },
      {
        charge_name: 'oda',
        min_value: form4.oda_min_value,
        max_value: form4.oda_max_value,
        condition_based: form4.oda_condition,
        max_value_calculation: form4.oda_condition === 'and' ? null : form4.charge_type_oda_or,
        calculation_based_on_min: form4.oda_charge_based_calculation || null,
        calculation_based_on_max: form4.oda_criteria_charge || null
      }
    ];

    const insertChargeSql = `
          INSERT INTO tbl_additional_charges (
            vendor_id, charge_name, calculation_based_on_min, calculation_based_on_max, min_value, max_value, 
            condition_based, chargable_value_type
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `;

    for (const charge of additionalCharges) {
      if (!charge.calculation_based_on_min || charge.calculation_based_on_min === '0') {
        console.log(`Skipping charge ${charge.charge_name} due to missing or zero calculation_based_on_min value`);
        continue;
      }
      const chargeValues = [
        vendorId,
        charge.charge_name,
        charge.calculation_based_on_min || null,
        charge.calculation_based_on_max || null,
        charge.min_value || null,
        charge.max_value || null,
        charge.condition_based || null,
        charge.max_value_calculation || null
      ];
      await mySqlQury(insertChargeSql, chargeValues);
    }
    if (!forwarderId) {
      return res.status(404).json({ message: 'Forwarder not found' });
    }
    const tableName = `tbl_zone_mapping_${forwarderId}`;

    // Create the zone mapping table dynamically
    const createTableSQL = `
              CREATE TABLE IF NOT EXISTS ${tableName} (
                  id BIGINT(20) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
                  zone VARCHAR(50),
                  city VARCHAR(255),
                  state VARCHAR(255),
                  forwarder_id BIGINT(20) UNSIGNED,
                  FOREIGN KEY (forwarder_id) REFERENCES tbl_vendor_details(id) ON DELETE CASCADE,
                  UNIQUE KEY (zone, city, state, forwarder_id)
              )
          `;
    await mySqlQury(createTableSQL);

    // Process each zone in the form5 object
    for (const [zone, { citySelect = [], stateSelectSecondary = [] }] of Object.entries(form5)) {
      // Process each city and state entry
      for (let i = 0; i < Math.max(citySelect.length, stateSelectSecondary.length); i++) {
        const cityEntry = citySelect[i] || '';
        const stateEntry = stateSelectSecondary[i] || '';

        // Skip if both city and state are empty
        if (!cityEntry && !stateEntry) continue;

        // Split by commas and process each part
        const cities = cityEntry.split(',').map(c => c.trim()).filter(Boolean);
        const states = stateEntry.split(',').map(s => s.trim()).filter(Boolean);

        // If we have cities and states
        if (cities.length && states.length) {
          // Process each city with each state
          for (const city of cities) {
            for (const state of states) {
              await upsertZoneMapping(tableName, zone, city, state, forwarderId);
            }
          }
        }
        // If we only have cities
        else if (cities.length) {
          for (const city of cities) {
            await upsertZoneMapping(tableName, zone, city, '', forwarderId);
          }
        }
        // If we only have states
        else if (states.length) {
          for (const state of states) {
            await upsertZoneMapping(tableName, zone, '', state, forwarderId);
          }
        }
      }
    }

    // Helper function to update or insert zone mapping
    async function upsertZoneMapping(tableName, zone, city, state, forwarderId) {
      const existingRecord = await mySqlQury(
        `SELECT id, zone FROM ${tableName} WHERE city = ? AND state = ? AND forwarder_id = ?`,
        [city, state, forwarderId]
      );

      if (existingRecord.length > 0) {
        // Update only if zone changed
        if (existingRecord[0].zone !== zone) {
          await mySqlQury(
            `UPDATE ${tableName} SET zone = ? WHERE city = ? AND state = ? AND forwarder_id = ?`,
            [zone, city, state, forwarderId]
          );
        }
      } else {
        // Insert new record
        await mySqlQury(
          `INSERT INTO ${tableName} (zone, city, state, forwarder_id) VALUES (?, ?, ?, ?)`,
          [zone, city, state, forwarderId]
        );
      }
    }



    // Commit the transaction
    await mySqlQury('COMMIT');
    res.status(200).send('Data of vendor is successfully saved');
  } catch (error) {
    console.error('Error in generating vendor details:', error);

    // Rollback the transaction in case of error
    await mySqlQury('ROLLBACK');
    res.status(500).send('Internal Server Error');
  }
}
const apiForwarderOnboardLtl = async (req, res) => {
  let additionalCharges = [];
  let basicDetails = {};
  let logo = null;
  let volumetric = null;
  let minChargeable = null;

  try {
    // Parse additionalCharges
    if (Array.isArray(req.body.additionalCharges)) {
      additionalCharges = req.body.additionalCharges;
    } else if (
      typeof req.body.additionalCharges === 'string' &&
      req.body.additionalCharges.trim() === '[]'
    ) {
      additionalCharges = [];
    } else if (typeof req.body.additionalCharges === 'string') {
      additionalCharges = JSON.parse(req.body.additionalCharges);
    }

    // Parse basicDetails
    if (typeof req.body.basicDetails === 'string') {
      basicDetails = JSON.parse(req.body.basicDetails);
    } else if (typeof req.body.basicDetails === 'object') {
      basicDetails = req.body.basicDetails;
    }

    // Extract volumetric and min_chargeable_weight from req.body or result
    Object.entries(req.body).forEach(([key, value]) => {
      if (key.includes('volumetric_safety_factor')) {
        volumetric = value;
      } else if (key.includes('min_chargeable_weight')) {
        minChargeable = value;
      }
    });

    // Look for the logo file by fieldname 'logo'

  } catch (e) {
    console.error("Error parsing additionalCharges or basicDetails:", e);
    return res.status(400).json({
      status: 'error',
      message: 'Invalid data format'
    });
  }
  console.log("ltl req body details", additionalCharges, basicDetails, volumetric, minChargeable)
  const excelFile = req.files.find(file => file.fieldname === 'ltlformdata[ltl]');
  const zoneFile = req.files.find(file => file.fieldname === 'ltlformdata[zone]');
  console.log("excelFile", excelFile)
  console.log("zoneFile", zoneFile)


  if (!excelFile || !zoneFile) {
    return res.status(400).json({
      status: 'error',
      message: 'Required files are missing'
    });
  }
  console.log("basicDetails", basicDetails)
  // console.log("additionalCharges",dskdskd)

  let courierId = null;
  let vendorId = null;
  let courierInitialNameAndTaggedApi = basicDetails.courier ? basicDetails.courier.toUpperCase() : '';
  let companyName = `${courierInitialNameAndTaggedApi}_LTL`;
  let courierTypeAndservice_type = "LTL";
  let productType = 'LTL-surface';
  // Set logo path based on courier
  if (basicDetails.courier) {
    const courier = basicDetails.courier.toLowerCase();
    if (courier === 'dtdc') {
      logo = 'assets/images/logos/dtdc.png';
    } else if (courier === 'delhivery') {
      logo = 'assets/images/logos/delhivery.png';
    } else if (courier === 'xpressbees' || courier === 'expressbees') {
      logo = 'assets/images/logos/expressbees.png';
    }
    // Add more couriers as needed
  }


  await mySqlQury('START TRANSACTION');
  try {
    // 1. Insert into tbl_vendor_details (basic details + volumetric + min_chargeable_weight)
    const insertVendorSql = `
          INSERT INTO tbl_courier_details (
            company_name, company_address, company_country, company_state, company_district, 
            from_date, from_to, choose_bank, ifsc_code, account_number, gst_no, credit_terms, 
            billing_cycle, volumetric_factor, minimum_chargable_weight, company_pan_code, 
            company_vat, company_uin, company_bank_account, shipment_type, Tagged_api, logo_path, 
            productType, email_id, phone,courier_type,service_type,courier_name,business_volume
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?,?,?)
        `;

    // Compose values for tbl_vendor_details
    const vendorValues = [
      companyName || '',
      basicDetails.companyAddress || '',
      basicDetails.companyCountry || '',
      basicDetails.companyState || '',
      basicDetails.companyDistrict || '',
      basicDetails.fromDate || '',
      basicDetails.fromTo || '',
      basicDetails.chooseBank || '',
      basicDetails.ifscCode || '',
      basicDetails.accountNumber || '',
      basicDetails.gstNo || '',
      basicDetails.creditTerms || '',
      basicDetails.billingCycle || '',
      volumetric || '',
      minChargeable || '',
      basicDetails.company_pan || '',
      basicDetails.vat || '',
      basicDetails.company_uin || '',
      basicDetails.Bank_account_name || '',
      basicDetails.shipmentType || '',
      courierInitialNameAndTaggedApi || '',
      logo || '',
      productType || '',
      basicDetails.forwarder_Email || '',
      basicDetails.forwarder_mobile || '',
      courierTypeAndservice_type,       // courier_type (should be "LTL")
      courierTypeAndservice_type,       // service_type (should be "LTL")
      companyName,                        // courier_name (e.g., "DTDC_LTL")

      basicDetails.businessVolume || ''
    ];

    const vendorResult = await mySqlQury(insertVendorSql, vendorValues);
    vendorId = vendorResult.insertId;
    courierId = vendorId; // For LTL, forwarderId is vendorId

    // 2. Insert into tbl_additional_charges (if any)
    if (Array.isArray(additionalCharges) && additionalCharges.length > 0) {
      const insertChargeSql = `
            INSERT INTO tbl_courier_ltl_additional_charges (
              courier_id, charge_name, calculation_based_on_min, calculation_based_on_max, min_value, max_value, 
              condition_based, chargable_value_type
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
          `;
      for (const charge of additionalCharges) {
        await mySqlQury(insertChargeSql, [
          courierId,
          charge.chargeName || '',
          charge.minCharge || '',
          charge.maxCharge || '',
          charge.minValue || '',
          charge.maxValue || '',
          charge.condition || '',
          charge.conditionalCharges || ''
        ]);
      }
    }

    // 3. Insert LTL Rate sheet into tbl_vendor_rates
    const XLSX = require('xlsx');
    const workbook = XLSX.readFile(excelFile.path);
    const ltlRateSheet = workbook.Sheets['LTL Rate'];
    if (ltlRateSheet) {
      const sheetData = XLSX.utils.sheet_to_json(ltlRateSheet);
      const insertRateSql = `
            INSERT INTO tbl_courier_ltl_rates (
              courier_id, zone_origin, zone_destination, courier_type, service_type, rate
            ) VALUES (?, ?, ?, ?, ?, ?)
          `;
      for (const row of sheetData) {
        const zoneOrigin = row.Zone;
        if (!zoneOrigin) continue;
        for (const [key, value] of Object.entries(row)) {
          if (key !== 'Zone' && value !== undefined && value !== null && value !== '') {
            const zoneDest = key;
            const rateValue = parseFloat(value);
            if (!isNaN(rateValue)) {
              await mySqlQury(insertRateSql, [
                courierId,
                zoneOrigin,
                zoneDest,
                basicDetails.forwarderType || '',
                basicDetails.serviceType || '',
                rateValue
              ]);
            }
          }
        }
      }
    }

    // 4. Insert LTL TAT sheet into tbl_tat_ltl
    const tatSheet = workbook.Sheets['LTL TAT'];
    const table2Name = `tbl_courier_ltl_tat`;
    if (tatSheet) {
      // Create TAT table if not exists
      const createTable2SQL = `
            CREATE TABLE IF NOT EXISTS ${table2Name} (
                id BIGINT(20) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
                courier_id BIGINT(20) UNSIGNED,
                zone_origin VARCHAR(50),
                zone_destination VARCHAR(50), 
                days INT,
                FOREIGN KEY (courier_id) REFERENCES tbl_courier_details(id) ON DELETE CASCADE,
                UNIQUE KEY (zone_origin, zone_destination, courier_id)
            )
          `;
      await mySqlQury(createTable2SQL);

      const tatData = XLSX.utils.sheet_to_json(tatSheet);
      for (const row of tatData) {
        const zoneOrigin = row.Zone;
        if (!zoneOrigin) continue;
        for (const [zoneDest, daysValue] of Object.entries(row)) {
          if (zoneDest !== 'Zone') {
            const days = parseFloat(daysValue);
            if (!isNaN(days) && days > 0) {
              await mySqlQury(
                `INSERT IGNORE INTO ${table2Name} (courier_id, zone_origin, zone_destination, days)
                     VALUES (?, ?, ?, ?)`,
                [courierId, zoneOrigin, zoneDest, days]
              );
            }
          }
        }
      }
    }

    // 5. Process and save zone mapping from zoneFile (ltlformdata[zone]) into tbl_zone_mapping
    if (zoneFile) {
      const XLSX = require('xlsx');
      console.log("zoneFile", zoneFile)
      const zoneWorkbook = XLSX.readFile(zoneFile.path);
      // Assume the first sheet contains the mapping data
      const firstSheetName = zoneWorkbook.SheetNames[0];
      const zoneSheet = zoneWorkbook.Sheets[firstSheetName];
      if (zoneSheet) {
        // Create tbl_zone_mapping if not exists
        const createZoneMappingTableSQL = `
              CREATE TABLE IF NOT EXISTS tbl_courier_ltl_zone_mapping (
                id BIGINT(20) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
                zone VARCHAR(50),
                city VARCHAR(100),
                state VARCHAR(100),
                courier_id BIGINT(20) UNSIGNED
              )
            `;
        await mySqlQury(createZoneMappingTableSQL);

        const zoneData = XLSX.utils.sheet_to_json(zoneSheet);
        for (const row of zoneData) {
          // Acceptable column names: Zone, City, State (case-insensitive)
          const zone = row.Zone || row.zone || '';
          console.log("zone", zone)
          const city = row.City || row.city || '';
          console.log("city", city)
          const state = row.State || row.state || '';
          if (zone && (city || state)) {
            await mySqlQury(
              `INSERT INTO tbl_courier_ltl_zone_mapping (zone, city, state, courier_id) VALUES (?, ?, ?, ?)`,
              [zone, city, state, courierId]
            );
            console.log("zone mapping inserted", zone, city, state, courierId)
          }
        }
      }
    }

    await mySqlQury('COMMIT');
    res.status(200).json({
      status: 'success',
      message: 'LTL Forwarder data saved successfully'
    });
  } catch (error) {
    console.error('Error in LTL forwarder onboarding:', error);
    await mySqlQury('ROLLBACK');
    res.status(500).json({
      status: 'error',
      message: 'Internal Server Error'
    });
  }
}
const apiForwarderOnboardExpress = async (req, res) => {
  console.log('req.body in the express onboarding of the', req.body);
  // const delhiveryVariantApi = req.body.delhiveryVariantApi

  console.log("basicDetails", req.body.basicDetails)
  const basicDetails = JSON.parse(req.body.basicDetails);
  console.log("basicDetails", basicDetails)
  console.log("req.body", req.body.allServiceDetails)
 
  const allServiceDetails = JSON.parse(req.body.allServiceDetails);
  const { delhiveryVariantApi } = allServiceDetails;


  const delhiveryvariant = delhiveryVariantApi && parseInt(delhiveryVariantApi) > 0
    ? parseInt(delhiveryVariantApi)
    : 0;
 
  console.log("delhivery variant", delhiveryvariant);
  console.log("allServiceDetails", allServiceDetails);

 
  const zoneMappingFile = req.files.find(file => file.fieldname === 'zoneMappingFile');
  console.log("zoneMappingFile", zoneMappingFile)
    console.log("in the express")
  // console.log("shabbar ansari",ddjekjkrjekrj)

  await mySqlQury('START TRANSACTION');
  try {
    // Extract form data from the request body


    // Handle logo based on courier selection
    let logoPath = null;
    if (basicDetails.courier) {
      const courier = basicDetails.courier.toLowerCase();
      if (courier === 'dtdc') {
        logoPath = 'assets/images/logos/dtdc.png';
      } else if (courier === 'delhivery') {
        logoPath = 'assets/images/logos/delhivery.png';
      } else if (courier === 'xpressbees' || courier === 'expressbees') {
        logoPath = 'assets/images/logos/expressbees.png';
      }
    }
    let courierInitialNameAndTaggedApi = basicDetails.courier ? basicDetails.courier.toUpperCase() : '';
    // let companyName = `${courierInitialNameAndTaggedApi}_LTL`;
    // let courierTypeAndservice_type = "Standard";
    const zoneMap = {
      'WITHIN-NCR': 'A',
      'WITHIN-CITY': 'B',
      'WITHIN-STATE': 'C',
      'WITHIN-ZONE': 'D',
      'WITHIN-METRO': 'E',
      'WITHIN-SPECIAL-ZONE': 'F',
      'ROI': 'G'
    };


    // Loop through each service and create vendor records based on slabs
    for (const [serviceName, serviceData] of Object.entries(allServiceDetails)) {
      // Skip services that have no slabs
      console.log("serviceName", serviceName)
      console.log("serviceData", serviceData)
      console.log("VOLUMETRIC FACTOR",serviceData.volumetricSafetyFactor)
      // console.log("djsgdjsgdj",dgwueduwduw)
      if (!serviceData.slabs || serviceData.slabs.length === 0) {
        console.log(`Skipping ${serviceName} - no slabs found`);
        continue;
      }

      // Create one vendor record for each slab
      for (let slabIndex = 0; slabIndex < serviceData.slabs.length; slabIndex++) {
        console.log("servise name", serviceName)
        console.log("slab data", serviceData.slabs[slabIndex].rows)
        const slab = serviceData.slabs[slabIndex];
        const mode = serviceData.mode;
        const { label, rows } = slab;
       

        // Extract the label and get the highest number from the range
        const slabLabel = slab.label || '';
        const labelMatch = slabLabel.match(/(\d+)-(\d+)(\w+)/);
        let maxvalueRange;
        let labelUnit = '';
        let minvalueRange;

        if (labelMatch) {
          // If it's a range like "12-212gm", extract the highest number (212) and unit (gm)
          minvalueRange = labelMatch[1];
          console.log("minvalue", minvalueRange)
          maxvalueRange = labelMatch[2];
          labelUnit = labelMatch[3] || '';
        } else {
          // Fallback: try to get the last number from the label
          const lastNumberMatch = slabLabel.match(/(\d+)(\w*)$/);
          if (lastNumberMatch) {
            minvalueRange = lastNumberMatch[1];
            labelUnit = lastNumberMatch[2] || '';
          } else {
            maxvalueRange = (slabIndex + 1);
          }
        }

        const companyname = `${courierInitialNameAndTaggedApi} ${mode} ${serviceName} ${maxvalueRange}${labelUnit}`;
        const volumetric = serviceData.volumetricSafetyFactor;
        const productType = `Express-${mode}`
        const  courierType="Express"
       

        // Create courier initial name and tagged API with service and slab info
        // const courierInitialNameAndTaggedApi = `${companyName}_${serviceName}_Slab${slabIndex + 1}`;
        const courierTypeAndservice_type = serviceName;
       

        // Insert into tbl_courier_details table
        const insertVendorSql = `
          INSERT INTO tbl_courier_details (
            company_name, company_address, company_country, company_state, company_district,
            from_date, from_to, choose_bank, ifsc_code, account_number, gst_no, credit_terms,
            billing_cycle, volumetric_factor, minimum_chargable_weight, company_pan_code,
            company_vat, company_uin, company_bank_account, shipment_type, Tagged_api, logo_path,
            productType, email_id, phone, courier_type, service_type, courier_name, business_volume,delhivery_api_variant
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)
        `;

        // Compose values for tbl_courier_details
        const vendorValues = [
          companyname || '',
          basicDetails.companyAddress || '',
          basicDetails.companyCountry || '',
          basicDetails.companyState || '',
          basicDetails.companyDistrict || '',
          basicDetails.fromDate || '',
          basicDetails.fromTo || '',
          basicDetails.chooseBank || '',
          basicDetails.ifscCode || '',
          basicDetails.accountNumber || '',
          basicDetails.gstNo || '',
          basicDetails.creditTerms || '',
          basicDetails.billingCycle || '',
          volumetric || '',
          basicDetails.minChargeable || '',
          basicDetails.company_pan || '',
          basicDetails.vat || '',
          basicDetails.company_uin || '',
          basicDetails.Bank_account_name || '',
          basicDetails.shipmentType || '',
          courierInitialNameAndTaggedApi || '',
          logoPath || '',
          productType || '',
          basicDetails.forwarder_Email || '',
          basicDetails.forwarder_mobile || '',
          courierType,       // courier_type
          courierTypeAndservice_type,       // service_type
          basicDetails.courier || '',       // courier_name
          basicDetails.businessVolume || '',
          delhiveryvariant
        ];

        const vendorResult = await mySqlQury(insertVendorSql, vendorValues);
        // Insert additional charges for this service
        if (Array.isArray(serviceData.additionalCharges) && serviceData.additionalCharges.length > 0) {
          for (const charge of serviceData.additionalCharges) {
        
            const insertAdditionalChargeSql = `
              INSERT INTO tbl_courier_exp_additional_charges
                (courier_id, charge_name, calculation_based_on_min, calculation_based_on_max, 
                 min_value, max_value, condition_based, chargable_value_type)
              VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            `;
        
            await mySqlQury(insertAdditionalChargeSql, [
              vendorResult.insertId,
              charge.chargeName || null,
              charge.minCharge || null,
              charge.maxCharge || null,
              charge.minValue !== '' && charge.minValue != null ? charge.minValue : null,
              charge.maxValue !== '' && charge.maxValue != null ? charge.maxValue : null,
              charge.condition || null,
              charge.conditionalCharges || null
            ]);
          }
        }
        // 1. Insert into tbl_exp_weightslabs
                const insertWeightSlabSql = `
          INSERT INTO tbl_exp_weightslabs (courier_id, min_weight, max_weight, unit)
          VALUES (?, ?, ?, ?)
        `;
        const weightSlabResult = await mySqlQury(insertWeightSlabSql, [
          vendorResult.insertId, minvalueRange, maxvalueRange, labelUnit
        ]);
        const weight_slab_id = weightSlabResult.insertId;

        // 2. Insert into tbl_exp_zones_rates for "main" row
        const mainRow = rows.find(r => r.type === 'main');
        if (mainRow) {
          for (const [zoneKey, zoneValue] of Object.entries(mainRow.values)) {
            const zoneName = zoneMap[zoneKey];
            if (!zoneName) continue;
            await mySqlQury(
              `INSERT INTO tbl_exp_zones_rates (courier_id, zone_name, zone_value, weight_slab_id)
       VALUES (?, ?, ?, ?)`,
              [vendorResult.insertId, zoneName, zoneValue, weight_slab_id]
            );
          }
        }

        // 3. Insert into tbl_exp_slab_additional_charges for "additional" row
        const additionalRow = rows.find(r => r.type === 'additional');
        if (additionalRow) {
          const { upto, unit, ...zoneAmounts } = additionalRow.values;
          const insertAdditionalChargeSql = `
    INSERT INTO tbl_exp_slab_additional_charges (courier_id, description, weight, unit, weight_slab_id)
    VALUES (?, ?, ?, ?, ?)
  `;
          const additionalChargeResult = await mySqlQury(insertAdditionalChargeSql, [
            vendorResult.insertId, 'upto', upto, unit, weight_slab_id
          ]);
          const charge_id = additionalChargeResult.insertId;

          // 4. Insert into tbl_exp_slab_additionalamounts for each zone
          for (const [zoneKey, amount] of Object.entries(zoneAmounts)) {
            const zoneName = zoneMap[zoneKey];
            if (!zoneName) continue;
            await mySqlQury(
              `INSERT INTO tbl_exp_slab_additionalamounts (additional_charge_id , zone_name, amount,courier_id)
       VALUES (?, ?, ?,?)`,
              [charge_id, zoneName, amount,vendorResult.insertId]
            );
          }
        }
        const tatRow = rows.find(r => r.type === 'tat');
        if (tatRow) {
          for (const [zoneKey, days] of Object.entries(tatRow.values)) {
            const zoneName = zoneMap[zoneKey];
            if (!zoneName) continue;
            await mySqlQury(
              `INSERT INTO tbl_exp_tat (courier_id, zone, days)
              VALUES (?, ?, ?)`,
              [vendorResult.insertId, zoneName, days]
            );
          }
        }
        if (zoneMappingFile) {
          const XLSX = require('xlsx');
          const zoneWorkbook = XLSX.readFile(zoneMappingFile.path);
          const firstSheetName = zoneWorkbook.SheetNames[0];
          const zoneSheet = zoneWorkbook.Sheets[firstSheetName];
          if (zoneSheet) {
            // Create the table if it doesn't exist, now with a 'rule' column
            const createZoneMappingTableSQL = `
              CREATE TABLE IF NOT EXISTS tbl_exp_zone_mapping (
                id BIGINT(20) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
                zone VARCHAR(50),
                rule VARCHAR(100),
                city VARCHAR(255),
                state VARCHAR(255),
                courier_id BIGINT(20) UNSIGNED
              )
            `;
            await mySqlQury(createZoneMappingTableSQL);
       
            // Parse the sheet
            const zoneData = XLSX.utils.sheet_to_json(zoneSheet);
       
            // Insert each row
            for (const row of zoneData) {
              console.log("row",row)
              // Adjust these keys if your Excel columns are named differently
              const { 'Zone': zone, Rule: rule, City: city, State: state } = row;
              await mySqlQury(
                `INSERT INTO tbl_exp_zone_mapping (zone, rule, city, state, courier_id) VALUES (?, ?, ?, ?, ?)`,
                [zone, rule, city, state, vendorResult.insertId]
              );
            }
          }
        }

        console.log(`Created vendor record for ${serviceName} - Slab ${slabIndex + 1} with ID: ${vendorResult.insertId}`);
      }
    }

    await mySqlQury('COMMIT');
    res.status(200).json({
      status: 'success',
      message: 'Express Forwarder data saved successfully'
    });
  } catch (error) {
    console.error('Error in Express forwarder onboarding:', error);
    await mySqlQury('ROLLBACK');
    res.status(500).json({
      status: 'error',
      message: 'Internal Server Error'
    });
  }
}
const apiForwarderOnboardEcom= async (req, res) => {
  console.log('req.body in the express onboarding of the', req.body);
  console.log("basicDetails", req.body.basicDetails)
  const basicDetails = JSON.parse(req.body.basicDetails);
  console.log("basicDetails", basicDetails)
  console.log("req.body", req.body.allServiceDetails)
 

   
  const allServiceDetails = JSON.parse(req.body.allServiceDetails);
  const { delhiveryVariantApi } = allServiceDetails;


  const delhiveryvariant = delhiveryVariantApi && parseInt(delhiveryVariantApi) > 0
    ? parseInt(delhiveryVariantApi)
    : 0;
 
  console.log("delhivery variant", delhiveryvariant);
  console.log("allServiceDetails", allServiceDetails);
 
  const zoneMappingFile = req.files.find(file => file.fieldname === 'zoneMappingFile');
  console.log("zoneMappingFile", zoneMappingFile)
  console.log("in the ecom")
  // console.log("shabbar ansari",ddjekjkrjekrj)

  await mySqlQury('START TRANSACTION');
  try {
    // Extract form data from the request body


    // Handle logo based on courier selection
    let logoPath = null;
    if (basicDetails.courier) {
      const courier = basicDetails.courier.toLowerCase();
      if (courier === 'dtdc') {
        logoPath = 'assets/images/logos/dtdc.png';
      } else if (courier === 'delhivery') {
        logoPath = 'assets/images/logos/delhivery.png';
      } else if (courier === 'xpressbees' || courier === 'expressbees') {
        logoPath = 'assets/images/logos/expressbees.png';
      }
    }
    let courierInitialNameAndTaggedApi = basicDetails.courier ? basicDetails.courier.toUpperCase() : '';
    // let companyName = `${courierInitialNameAndTaggedApi}_LTL`;
    // let courierTypeAndservice_type = "Standard";
    const zoneMap = {
      'WITHIN-NCR': 'A',
      'WITHIN-CITY': 'B',
      'WITHIN-STATE': 'C',
      'WITHIN-ZONE': 'D',
      'WITHIN-METRO': 'E',
      'WITHIN-SPECIAL-ZONE': 'F',
      'ROI': 'G'
    };


    // Loop through each service and create vendor records based on slabs
    for (const [serviceName, serviceData] of Object.entries(allServiceDetails)) {
      // Skip services that have no slabs
      console.log("serviceName", serviceName)
      console.log("serviceData", serviceData)
      console.log("VOLUMETRIC FACTOR",serviceData.volumetricSafetyFactor)
      // console.log("djsgdjsgdj",dgwueduwduw)
      if (!serviceData.slabs || serviceData.slabs.length === 0) {
        console.log(`Skipping ${serviceName} - no slabs found`);
        continue;
      }

      // Create one vendor record for each slab
      for (let slabIndex = 0; slabIndex < serviceData.slabs.length; slabIndex++) {
        console.log("servise name", serviceName)
        console.log("slab data", serviceData.slabs[slabIndex].rows)
        const slab = serviceData.slabs[slabIndex];
        const mode = serviceData.mode;
        const { label, rows } = slab;
       

        // Extract the label and get the highest number from the range
        const slabLabel = slab.label || '';
        const labelMatch = slabLabel.match(/(\d+)-(\d+)(\w+)/);
        let maxvalueRange;
        let labelUnit = '';
        let minvalueRange;

        if (labelMatch) {
          // If it's a range like "12-212gm", extract the highest number (212) and unit (gm)
          minvalueRange = labelMatch[1];
          console.log("minvalue", minvalueRange)
          maxvalueRange = labelMatch[2];
          labelUnit = labelMatch[3] || '';
        } else {
          // Fallback: try to get the last number from the label
          const lastNumberMatch = slabLabel.match(/(\d+)(\w*)$/);
          if (lastNumberMatch) {
            minvalueRange = lastNumberMatch[1];
            labelUnit = lastNumberMatch[2] || '';
          } else {
            maxvalueRange = (slabIndex + 1);
          }
        }

        const companyname = `${courierInitialNameAndTaggedApi} ${mode} Ecom ${maxvalueRange}${labelUnit}`;
        const volumetric = serviceData.volumetricSafetyFactor;
        const productType = `Ecom-${mode}`
       

        // Create courier initial name and tagged API with service and slab info
        // const courierInitialNameAndTaggedApi = `${companyName}_${serviceName}_Slab${slabIndex + 1}`;
        let courierTypeAndservice_type = serviceName;
        const  courierType="Ecom"

if (courierInitialNameAndTaggedApi === 'DELHIVERY') {
  courierTypeAndservice_type = 'Delhivery';
} else if (courierInitialNameAndTaggedApi === 'XPRESSBEES') {
  courierTypeAndservice_type = 'Xpressbees';
} else if (courierInitialNameAndTaggedApi === 'DTDC') {
  courierTypeAndservice_type = 'DTDC';
}
       

        // Insert into tbl_courier_details table
        const insertVendorSql = `
          INSERT INTO tbl_courier_details (
            company_name, company_address, company_country, company_state, company_district,
            from_date, from_to, choose_bank, ifsc_code, account_number, gst_no, credit_terms,
            billing_cycle, volumetric_factor, minimum_chargable_weight, company_pan_code,
            company_vat, company_uin, company_bank_account, shipment_type, Tagged_api, logo_path,
            productType, email_id, phone, courier_type, service_type, courier_name, packet_shipment,delhivery_api_variant
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)
        `;

        // Compose values for tbl_courier_details
        const vendorValues = [
          companyname || '',
          basicDetails.companyAddress || '',
          basicDetails.companyCountry || '',
          basicDetails.companyState || '',
          basicDetails.companyDistrict || '',
          basicDetails.fromDate || '',
          basicDetails.fromTo || '',
          basicDetails.chooseBank || '',
          basicDetails.ifscCode || '',
          basicDetails.accountNumber || '',
          basicDetails.gstNo || '',
          basicDetails.creditTerms || '',
          basicDetails.billingCycle || '',
          volumetric || '',
          basicDetails.minChargeable || '',
          basicDetails.company_pan || '',
          basicDetails.vat || '',
          basicDetails.company_uin || '',
          basicDetails.Bank_account_name || '',
          basicDetails.shipmentType || '',
          courierInitialNameAndTaggedApi || '',
          logoPath || '',
          productType || '',
          basicDetails.forwarder_Email || '',
          basicDetails.forwarder_mobile || '',
          courierType,       // courier_type
          courierTypeAndservice_type,       // service_type
          basicDetails.courier || '',       // courier_name
          basicDetails.noOfShipment || '',
          delhiveryvariant
        ];

        const vendorResult = await mySqlQury(insertVendorSql, vendorValues);
        // Insert additional charges for this service
              if (Array.isArray(serviceData.additionalCharges) && serviceData.additionalCharges.length > 0) {
          for (const charge of serviceData.additionalCharges) {
        
            const insertAdditionalChargeSql = `
              INSERT INTO tbl_courier_ecom_additional_charges
                (courier_id, charge_name, calculation_based_on_min, calculation_based_on_max, 
                 min_value, max_value, condition_based, chargable_value_type)
              VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            `;
        
            await mySqlQury(insertAdditionalChargeSql, [
              vendorResult.insertId,
              charge.chargeName || null,
              charge.minCharge || null,
              charge.maxCharge || null,
              charge.minValue !== '' && charge.minValue != null ? charge.minValue : null,
              charge.maxValue !== '' && charge.maxValue != null ? charge.maxValue : null,
              charge.condition || null,
              charge.conditionalCharges || null
            ]);
          }
        }
        // 1. Insert into tbl_exp_weightslabs
                const insertWeightSlabSql = `
          INSERT INTO tbl_ecom_weightslabs (courier_id, min_weight, max_weight, unit)
          VALUES (?, ?, ?, ?)
        `;
        const weightSlabResult = await mySqlQury(insertWeightSlabSql, [
          vendorResult.insertId, minvalueRange, maxvalueRange, labelUnit
        ]);
        const weight_slab_id = weightSlabResult.insertId;

        // 2. Insert into tbl_exp_zones_rates for "main" row
        const mainRow = rows.find(r => r.type === 'main');
        if (mainRow) {
          for (const [zoneKey, zoneValue] of Object.entries(mainRow.values)) {
            const zoneName = zoneMap[zoneKey];
            if (!zoneName) continue;
            await mySqlQury(
              `INSERT INTO tbl_ecom_zones_rates (courier_id, zone_name, zone_value, weight_slab_id)
       VALUES (?, ?, ?, ?)`,
              [vendorResult.insertId, zoneName, zoneValue, weight_slab_id]
            );
          }
        }

        // 3. Insert into tbl_exp_slab_additional_charges for "additional" row
        const additionalRow = rows.find(r => r.type === 'additional');
        if (additionalRow) {
          const { upto, unit, ...zoneAmounts } = additionalRow.values;
          const insertAdditionalChargeSql = `
    INSERT INTO tbl_ecom_slab_additional_charges (courier_id, description, weight, unit, weight_slab_id)
    VALUES (?, ?, ?, ?, ?)
  `;
          const additionalChargeResult = await mySqlQury(insertAdditionalChargeSql, [
            vendorResult.insertId, 'upto', upto, unit, weight_slab_id
          ]);
          const charge_id = additionalChargeResult.insertId;

          // 4. Insert into tbl_exp_slab_additionalamounts for each zone
          for (const [zoneKey, amount] of Object.entries(zoneAmounts)) {
            const zoneName = zoneMap[zoneKey];
            if (!zoneName) continue;
            await mySqlQury(
              `INSERT INTO tbl_ecom_slab_additionalamounts (additional_charge_id  , zone_name, amount,courier_id)
       VALUES (?, ?, ?,?)`,
              [charge_id, zoneName, amount,vendorResult.insertId]
            );
          }
        }
        const tatRow = rows.find(r => r.type === 'tat');
        if (tatRow) {
          for (const [zoneKey, days] of Object.entries(tatRow.values)) {
            const zoneName = zoneMap[zoneKey];
            if (!zoneName) continue;
            await mySqlQury(
              `INSERT INTO tbl_ecom_tat (courier_id, zone, days)
              VALUES (?, ?, ?)`,
              [vendorResult.insertId, zoneName, days]
            );
          }
        }
        if (zoneMappingFile) {
          const XLSX = require('xlsx');
          const zoneWorkbook = XLSX.readFile(zoneMappingFile.path);
          const firstSheetName = zoneWorkbook.SheetNames[0];
          const zoneSheet = zoneWorkbook.Sheets[firstSheetName];
          if (zoneSheet) {
            // Create the table if it doesn't exist, now with a 'rule' column
            const createZoneMappingTableSQL = `
              CREATE TABLE IF NOT EXISTS tbl_ecom_zone_mapping (
                id BIGINT(20) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
                zone VARCHAR(50),
                rule VARCHAR(100),
                city VARCHAR(255),
                state VARCHAR(255),
                courier_id BIGINT(20) UNSIGNED
              )
            `;
            await mySqlQury(createZoneMappingTableSQL);
       
            // Parse the sheet
            const zoneData = XLSX.utils.sheet_to_json(zoneSheet);
       
            // Insert each row
            for (const row of zoneData) {
              console.log("row",row)
              // Adjust these keys if your Excel columns are named differently
              const { 'Zone': zone, Rule: rule, City: city, State: state } = row;
              await mySqlQury(
                `INSERT INTO tbl_ecom_zone_mapping (zone, rule, city, state, courier_id) VALUES (?, ?, ?, ?, ?)`,
                [zone, rule, city, state, vendorResult.insertId]
              );
            }
          }
        }

        console.log(`Created vendor record for ${serviceName} - Slab ${slabIndex + 1} with ID: ${vendorResult.insertId}`);
      }
    }

    await mySqlQury('COMMIT');
    res.status(200).json({
      status: 'success',
      message: 'Express Forwarder data saved successfully'
    });
  } catch (error) {
    console.error('Error in Express forwarder onboarding:', error);
    await mySqlQury('ROLLBACK');
    res.status(500).json({
      status: 'error',
      message: 'Internal Server Error'
    });
  }
}
const predispatchforOnboardingStand = async (req, res) => {
  console.log('req.body in the standard onboarding of the', req.body);
  // console.log("check for the data i have",shabbarraza)
  await mySqlQury('START TRANSACTION');
  try {
    // Extract form data from the request body
    const form1ValidationErrors = validateForwarderForm1(req.body.form1, req.files, req.body.form3.volumetric_);
    if (form1ValidationErrors) {
      return res.status(400).json({
        status: 'error',
        message: 'Form 1 validation failed',
        errors: form1ValidationErrors
      });
    }
    console.log("form1ValidationErrors", form1ValidationErrors);


    const { form1, form2, form3, form9, ZoneData, form10, form4 } = req.body;

    console.log("dsform9", form9)
    console.log("standard data from the req.body", req.body);
    const parsed10 = JSON.parse(JSON.stringify(form10))

    let logoPath = null;

    const parsedForm1 = JSON.parse(JSON.stringify(form1));
    // const parsedForm2 = JSON.parse(JSON.stringify(form2));
    const parsedForm4 = JSON.parse(JSON.stringify(form4));
    const ZoneDat = JSON.parse(JSON.stringify(ZoneData));
    console.log("zone datastandard onboarding", ZoneDat)
    // console.log("parsed form9",dsds)
    if (req.files && req.files.length > 0) {
      logoPath = req.files[0].path.replace(/\\/g, '/'); // Normalize the path to use forward slashes
      logoPath = logoPath.replace(/^.*[\\/]public[\\/]/, ''); // Make the path relative to the public directory
      console.log("Logo path:", logoPath);
    } else {
      console.log("No file uploaded.");
    }
    console.log("lofo path:", logoPath);
    // console.log("dsdhsdw",dsjdhjsdsjd)
    console.log("parsed form3", JSON.parse(JSON.stringify(form3)))
    console.log("parsed form1", parsedForm1)
    // console.log("parsed form2",parsedForm2)
    // console.log("dsdhsdw",dsjdhjsdsjd)
    // console.log("parse ",sleb)
    // console.log("sasada",dadada)
    let forwarderActualType = "Standard";

    const insertVendorSql = `
          INSERT INTO tbl_vendor_details (
            forwarder_name, forwarder_type, service_type, company_name, company_address, 
            company_country, company_state, company_district, website, from_date, 
            from_to, choose_bank, ifsc_code, account_number, gst_no, credit_terms, 
            billing_cycle,volumetric_factor,company_pan_code,company_vat,company_uin,company_bank_account,shipment_type,	Tagged_api,logo_path,productType,email_id,phone	
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?,?,?,?,?,?,?,?,?,?,?)
        `;
    const vendorValues = [
      parsedForm1.forwarderName, forwarderActualType, parsedForm1.forwarderType, parsedForm1.companyName,
      parsedForm1.companyAddress, parsedForm1.companyCountry, parsedForm1.companyState, parsedForm1.companyDistrict,
      parsedForm1.website, parsedForm1.fromDate, parsedForm1.fromTo, parsedForm1.chooseBank, parsedForm1.ifscCode,
      parsedForm1.accountNumber, parsedForm1.gstNo, parsedForm1.creditTerms, parsedForm1.billingCycle, form3.volumetric_, parsedForm1.company_pan, parsedForm1.vat, parsedForm1.company_uin, parsedForm1.Bank_account_name,
      parsedForm1.shipmentType, parsedForm1.chooseAPi, logoPath, parsedForm1.ProductType, parsedForm1.forwarder_Email, parsedForm1.forwarder_mobile
    ];
    const result = await mySqlQury(insertVendorSql, vendorValues);
    const vendorId = result.insertId;
    const forwarderId = vendorId

    const forwarderType = form1.forwarderType;
    const additionalCharges = [
      {
        charge_name: 'lr',
        min_value: parsedForm4.lr_min_value,
        max_value: parsedForm4.lr_max_value,
        condition_based: parsedForm4.lr_condition,
        max_value_calculation: parsedForm4.lr_condition === 'and' ? null : parsedForm4.charge_type_lr_or,
        calculation_based_on_min: parsedForm4.lr_charge_based_calculation || null,
        calculation_based_on_max: parsedForm4.lr_criteria_charge || null
      },
      {
        charge_name: 'fs',
        min_value: parsedForm4.fs_min_value,
        max_value: parsedForm4.fs_max_value,
        condition_based: parsedForm4.fs_condition,
        max_value_calculation: parsedForm4.fs_condition === 'and' ? null : parsedForm4.charge_type_fs_or,
        calculation_based_on_min: parsedForm4.fs_charge_based_calculation || null,
        calculation_based_on_max: parsedForm4.fs_criteria_charge || null
      },
      {
        charge_name: 'fm',
        min_value: parsedForm4.fm_min_value,
        max_value: parsedForm4.fm_max_value,
        condition_based: parsedForm4.fm_condition,
        max_value_calculation: parsedForm4.fm_condition === 'and' ? null : parsedForm4.charge_type_fm_or,
        calculation_based_on_min: parsedForm4.fm_charge_based_calculation || null,
        calculation_based_on_max: parsedForm4.fm_criteria_charge || null
      },
      {
        charge_name: 'fov_owner',
        min_value: parsedForm4.fov_owner_min_value,
        max_value: parsedForm4.fov_owner_max_value,
        condition_based: parsedForm4.fov_owner_condition,
        max_value_calculation: parsedForm4.fov_owner_condition === 'and' ? null : parsedForm4.charge_type_fov_owner_or,
        calculation_based_on_min: parsedForm4.fov_owner_charge_based_calculation || null,
        calculation_based_on_max: parsedForm4.fov_owner_criteria_charge || null
      },
      {
        charge_name: 'to_pay',
        min_value: parsedForm4.to_pay_min_value,
        max_value: parsedForm4.to_pay_max_value,
        condition_based: parsedForm4.to_pay_condition,
        max_value_calculation: parsedForm4.to_pay_condition === 'and' ? null : parsedForm4.charge_type_to_pay_or,
        calculation_based_on_min: parsedForm4.to_pay_charge_based_calculation || null,
        calculation_based_on_max: parsedForm4.to_pay_criteria_charge || null
      },
      {
        charge_name: 'cod',
        min_value: parsedForm4.cod_min_value,
        max_value: parsedForm4.cod_max_value,
        condition_based: parsedForm4.cod_condition,
        max_value_calculation: parsedForm4.cod_condition === 'and' ? null : parsedForm4.charge_type_cod_or,
        calculation_based_on_min: parsedForm4.cod_charge_based_calculation || null,
        calculation_based_on_max: parsedForm4.cod_criteria_charge || null
      },
      {
        charge_name: 'check_handling_weight',
        min_value: parsedForm4.check_handling_weight_min_value,
        max_value: parsedForm4.check_handling_weight_max_value,
        condition_based: parsedForm4.check_handling_weight_condition,
        max_value_calculation: parsedForm4.check_handling_weight_condition === 'and' ? null : parsedForm4.charge_type_check_handling_weight_or,
        calculation_based_on_min: parsedForm4.check_handling_weight_charge_based_calculation || null,
        calculation_based_on_max: parsedForm4.check_handling_weight_criteria_charge || null
      },
      {
        charge_name: 'green_tax',
        min_value: parsedForm4.green_tax_min_value,
        max_value: parsedForm4.green_tax_max_value,
        condition_based: parsedForm4.green_tax_condition,
        max_value_calculation: parsedForm4.green_tax_condition === 'and' ? null : parsedForm4.charge_type_green_tax_or,
        calculation_based_on_min: parsedForm4.green_tax_charge_based_calculation || null,
        calculation_based_on_max: parsedForm4.green_tax_criteria_charge || null
      },
      {
        charge_name: 'oda',
        min_value: parsedForm4.oda_min_value,
        max_value: parsedForm4.oda_max_value,
        condition_based: parsedForm4.oda_condition,
        max_value_calculation: parsedForm4.oda_condition === 'and' ? null : parsedForm4.charge_type_oda_or,
        calculation_based_on_min: parsedForm4.oda_charge_based_calculation || null,
        calculation_based_on_max: parsedForm4.oda_criteria_charge || null
      }
    ];

    const insertChargeSql = `
          INSERT INTO tbl_additional_charges (
            vendor_id, charge_name, calculation_based_on_min, calculation_based_on_max, min_value, max_value, 
            condition_based, chargable_value_type
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `;

    for (const charge of additionalCharges) {
      if (!charge.calculation_based_on_min || charge.calculation_based_on_min === '0') {
        console.log(`Skipping charge ${charge.charge_name} due to missing or zero calculation_based_on_min value`);
        continue;
      }
      const chargeValues = [
        vendorId,
        charge.charge_name,
        charge.calculation_based_on_min || null,
        charge.calculation_based_on_max || null,
        charge.min_value || null,
        charge.max_value || null,
        charge.condition_based || null,
        charge.max_value_calculation || null
      ];
      await mySqlQury(insertChargeSql, chargeValues);
    }

    // Parse form10 into a JSON-compatible object
    // const parsed10 = JSON.parse(JSON.stringify(form10));

    for (const [index, slab] of Object.entries(parsed10)) {
      const { weightSlab, zones, additionalChargesDetails, additionalAmountDetails } = slab;
      console.log("Processing slab:", weightSlab, zones, additionalChargesDetails);

      // Save weightSlab to tbl_std_weightSlabs
      const weightSlabQuery = `
        INSERT INTO tbl_std_weightslabs (vendor_id, min_weight, max_weight, unit) 
        VALUES (?, ?, ?, ?)
      `;
      const weightSlabResult = await mySqlQury(weightSlabQuery, [
        vendorId,
        weightSlab.min,
        weightSlab.max,
        weightSlab.unit,
      ]);
      const weightSlabId = weightSlabResult.insertId;

      console.log(`Inserted weight slab ID: ${weightSlabId}`);

      // Save zones to tbl_std_Zones
      for (const [zoneName, zoneValue] of Object.entries(zones)) {
        const zoneQuery = `
          INSERT INTO tbl_std_zones (vendor_id, zone_name,zone_value,  weight_slab_id) 
          VALUES (?, ?, ?, ?)
        `;
        await mySqlQury(zoneQuery, [vendorId, zoneName, zoneValue, weightSlabId]);

        console.log(`Inserted zone for weight slab ID ${weightSlabId}: ${zoneName} = ${zoneValue}`);
      }

      // Save additionalChargesDetails to tbl_std_additional_charges
      for (const [index, charge] of additionalChargesDetails.entries()) {
        console.log("Processing additional charge:", charge);

        const { desc, weight, unit } = charge;

        // Skip invalid or empty values for `desc`, `weight`, or `unit`
        if (!desc || weight === null || weight === '' || isNaN(weight) || !unit) {
          console.log(
            `Skipping invalid additional charge at index ${index}: description=${desc}, weight=${weight}, unit=${unit}`
          );
          continue; // Skip this iteration if any required field is invalid
        }

        const additionalChargeQuery = `
          INSERT INTO tbl_std_additional_charges (vendor_id, weight_slab_id, description, weight, unit) 
          VALUES (?, ?, ?, ?, ?)
        `;
        const additionalChargeResult = await mySqlQury(additionalChargeQuery, [
          vendorId,
          weightSlabId,
          desc,
          weight,
          unit,
        ]);
        const additionalChargeId = additionalChargeResult.insertId;

        console.log(`Inserted additional charge ID: ${additionalChargeId}`);

        // Save additionalAmountDetails to tbl_std_additionalAmounts
        if (Array.isArray(additionalAmountDetails)) {
          console.log("Processing additional amounts for charge:", additionalAmountDetails);

          for (const amountObject of additionalAmountDetails) {
            // Each `amountObject` is an object like { ZoneA: '46', ZoneB: '46', ... }
            for (const [zone, amount] of Object.entries(amountObject)) {
              // Skip invalid or empty amount values
              if (amount === null || amount === '' || isNaN(amount)) {
                console.log(`Skipping invalid amount for zone: ${zone}`);
                continue; // Skip this iteration if the amount is invalid
              }

              console.log(`Processing zone: ${zone}, amount: ${amount}`);

              const additionalAmountQuery = `
                INSERT INTO tbl_std_additionalamounts (vendor_id, additional_charge_id, zone_name, amount) 
                VALUES (?, ?, ?, ?)
              `;
              await mySqlQury(additionalAmountQuery, [
                vendorId,
                additionalChargeId,
                zone,
                amount,
              ]);

              console.log(
                `Inserted additional amount for charge ID ${additionalChargeId}: Zone = ${zone}, Amount = ${amount}`
              );
            }
          }

        } else {
          console.log(`Invalid or empty additionalAmountDetails for charge at index ${index}`);
        }
      }
    }




    // Helper function to insert contacts
    const contactTypes = ['sales', 'ops', 'accounts', 'rvp'];

    for (const type of contactTypes) {
      console.log("Inserting vendor contacts for type:", type);

      const names = form2[`${type}_name`] || [];
      const designations = form2[`${type}_designation`] || [];
      const emails = form2[`${type}_email`] || [];
      const phones = form2[`${type}_phone`] || [];

      const insertContactSql = `
            INSERT INTO tbl_vendor_contacts (
              vendor_id, name, phone, email, designation, department
            ) VALUES (?, ?, ?, ?, ?, ?)
          `;

      const maxContacts = Math.max(names.length, designations.length, emails.length, phones.length);

      for (let i = 0; i < maxContacts; i++) {
        const contactValues = [
          vendorId,
          names[i] || null,
          phones[i] || null,
          emails[i] || null,
          designations[i] || null,
          type
        ];

        // Ensure that at least one of name, phone, email, or designation is provided
        if (contactValues.slice(1, 5).some(value => value !== null && value !== '')) {
          try {
            console.log(`Inserting contact at index ${i}:`, contactValues);
            await mySqlQury(insertContactSql, contactValues);
          } catch (err) {
            console.error(`Error inserting contact at index ${i}:`, err);
          }
        } else {
          console.log(`Skipping contact at index ${i} due to missing data`);
        }
      }
    }



    const insertTatSql = `
          INSERT INTO tbl_standard_tat (vendor_id, zone, days) VALUES (?, ?, ?)
        `;

    for (const key in req.body) {
      // Check if the key starts with 'form9[zones[' and ends with ']'
      if (key.startsWith('form9[zones[') && key.endsWith(']')) {
        // Extract the zone name (e.g., 'A' from 'form9[zones[A]]') and remove square brackets
        const zone = key.slice(11, -1).replace(/[\[\]]/g, ''); // Removes '[' and ']' from the extracted string

        // Get the corresponding value for the zone (the number of days)
        const days = req.body[key];

        // Log the key, zone, and days value for debugging
        console.log(`Processing key: ${key}`);
        console.log(`Extracted zone: ${zone}`);
        console.log(`Days for zone ${zone}: ${days}`);

        // If there's a valid value for days, insert it into the table
        if (days && days !== '') {
          try {
            // Log the query and values before inserting
            console.log(`Inserting TAT for vendor ${vendorId}, zone ${zone}, days ${days}`);
            await mySqlQury(insertTatSql, [vendorId, zone, days]);
          } catch (err) {
            console.error(`Error inserting TAT for zone ${zone}:`, err);
          }
        } else {
          console.log(`Skipping TAT for zone ${zone} due to missing value`);
        }
      }
    }




    //   // Insert into tbl_standard_zone_map using ZoneData
    const insertZoneMapSql = `
      INSERT INTO tbl_standard_zone_map (vendor_id, zone, rule, city, state) VALUES (?, ?, ?, ?, ?)
    `;

    for (const zone of ZoneDat) {
      const { zoneName, selectedRule, selectedCities = [], selectedStates = [] } = zone;

      // Ensure the arrays are of equal length
      const maxLength = Math.max(selectedCities.length, selectedStates.length);

      for (let i = 0; i < maxLength; i++) {
        const city = selectedCities[i] || null; // Use `null` if no city exists at index `i`
        const state = selectedStates[i] || null; // Use `null` if no state exists at index `i`

        try {
          await mySqlQury(insertZoneMapSql, [vendorId, zoneName, selectedRule, city, state]);
        } catch (error) {
          console.error(`Failed to insert for zone: ${zoneName}, Error: ${error.message}`);
        }
      }

      // If no cities or states exist, ensure at least one row is inserted with null values
      if (selectedCities.length === 0 && selectedStates.length === 0) {
        try {
          await mySqlQury(insertZoneMapSql, [vendorId, zoneName, selectedRule, null, null]);
        } catch (error) {
          console.error(`Failed to insert nulls for zone: ${zoneName}, Error: ${error.message}`);
        }
      }
    }


    await mySqlQury('COMMIT');
    return res.status(200).json({
      message: 'Forwarder onboarding data received and processed successfully.',
    });
  } catch (error) {
    console.error('Error processing data:', error);
    await mySqlQury('ROLLBACK');
    return res.status(500).json({
      message: 'An error occurred while processing the data.',
      error: error.message || 'Unknown error',
    });
  }
}
const predispatchAggrigatorOnboarding = async (req, res) => {

  console.log("shabbar ansari", req.body)
  // console.log("hdjshdjsdhj",jshdsjdj)
  console.log("logo name,", req.files)// Log oth

  // Find and log the Excel file details
  const excelFile = req.files.find(file => file.fieldname === 'form3[rateExcelFile]');


  // const connection = await mySqlQury('START TRANSACTION'); // Start the transaction
  await mySqlQury('START TRANSACTION');
  try {
    const form1ValidationErrors = validateAggregatorForm1(req.body.form1, req.files);
    if (form1ValidationErrors) {
      return res.status(400).json({
        status: 'error',
        message: 'Form 1 validation failed',
        errors: form1ValidationErrors
      });
    }

    // Validate form3 data
    const form3ValidationErrors = validateAggregatorForm3(req.body.form3);
    if (form3ValidationErrors) {
      return res.status(400).json({
        status: 'error',
        message: 'Form 3 validation failed',
        errors: form3ValidationErrors
      });
    }

    let logoPath = null;
    let aggrigator_bind = 0;
    let binded_forwarder = 0;
    let taggedApi = null;
    let Apiintegration = 0;
    let manualLR = 0;



    // Check if any file was uploaded
    if (req.files && req.files.length > 0) {
      // Get the path of the uploaded file
      logoPath = req.files[0].path.replace(/\\/g, '/'); // Replace backslashes with forward slashes

      // Remove the "public/" part to make it relative to the public directory
      logoPath = logoPath.replace(/^.*[\\/]public[\\/]/, '');
    } else {
      console.log("No file uploaded.");
    }
    console.log("form1 all details data", req.body)
    console.log("form1 data", req.body.form1)


    // console.log("Form data:", req.body); // 
    const { form1, form2, form3, form4, form5, form6, Aggrigator_password, Forwarders, ManualForwarders } = req.body;
    // if (!form1 || !form2 || !form3 || !form4 || !form5 || !form6) {
    //   return res.status(400).send("Required form data is missing.");
    // }
    console.log("form 2 data ", form3)
    console.log("form 6 data ", form6)
    // console.log("dsdsd",dsdsd)
    if (form1) {
      const { Aggrigator_defination, Aggrigator_bind, chooseAPIIntegration } = form1;

      // Check if Aggrigator_defination is '0'
      if (Aggrigator_defination === '0') {
        // If Aggrigator_bind is 'yes' or chooseAPIIntegration is provided, set Apiintegration to 1
        if (Aggrigator_bind === 'yes' && chooseAPIIntegration) {
          Apiintegration = 1;
        }

        // If Aggrigator_bind is 'no', set manualLR to 1
        if (Aggrigator_bind === 'no') {
          manualLR = 1;
        }
      }
    }




    // console.log("ddgasd",Forwarders.length)


    // console.log("sdass",Forwarders)
    // console.log("dsdsd",dsdsd)
    //  console.log("psadsd",sdass)
    if (Forwarders && Forwarders.length > 1) {

      binded_forwarder = 2;
      console.log("in the 2")
    }
    if (Forwarders && Forwarders.length === 1) {

      binded_forwarder = 1;
      console.log("dshgdhsin 1")

    }

    let servise = "LTL";



    if (form1.Aggrigator_bind === 'yes') {
      const forwarderDetails = form1.ForwarderList.split('/');
      aggrigator_bind = 1;


      taggedApi = forwarderDetails[1];
      sType = forwarderDetails[2];

      if (taggedApi === 'DTDC') {

      }
      else if (taggedApi === 'Delhivery') {

      }

    }

    console.log("forwader and binding details", aggrigator_bind, binded_forwarder, taggedApi);
    // console.log("dsdsd",dsdsd)


    let insertAdminSql = `
         INSERT INTO tbl_aggrigator(first_name, last_name, email, country_code, phone_no, Aggrigator_company_name, logo_path,binded_with_forwarder,Tagged_api,service_type,aggrigator_type,dispatch_agg,manualLr,api_integration)
         VALUES (?, ?, ?, ?, ?, ?, ?,?,?,?,?,?,?,?)
      `;

    // Prepare the values to be inserted, including the logo path
    let adminValues = [
      form1.contact_person,
      form1.Aggrigator_last_name,
      form1.Aggrigator_Email,
      form1.companyCountry,
      form1.Aggrigator_mobile,
      // Assuming '2' ,is the role ID for the admin
      form1.companyName,
      logoPath,
      binded_forwarder,
      taggedApi,
      servise,
      form1.ProductType,

      form1.Aggrigator_defination,
      manualLR,
      Apiintegration



      // Include the logo path here
    ];
    // const lrtype = 'cheapest'
    // Execute the insert query for tbl_admin
    const resultAdmin = await mySqlQury(insertAdminSql, adminValues);
    const adminId = resultAdmin.insertId;

    const insertForwarderSql = `
        INSERT INTO tbl_aggrigator_forwarder 
        (Aggrigator_id, Forwarder_id, Tagged_api, productType, service_type)
        VALUES ${Forwarders && Forwarders.length > 0 ? Forwarders.map(() => '(?, ?, ?, ?, ?)').join(', ') : ''};
    `;

    const insertServisibilitySql = `
      INSERT INTO tbl_aggrigator_servisibility (Aggrigator_id, Tagged_api, tagged_api_status) 
      VALUES ?;
    `;

    const forwarderValues = [];
    const servisibilityValues = [];

    // Case when Forwarders are provided
    if (Forwarders && Forwarders.length > 0) {
      // Iterate over each forwarder string, split by `/`, and push values for insertion
      for (let i = 0; i < Forwarders.length; i++) {
        const [forwarderId, Tapi, productType, serviceType] = Forwarders[i].split('/');

        let finalServiceType = serviceType; // Use a mutable variable for conditional assignment
        if (productType === 'Standard-Air' || productType === "Standard-Surface") {
          finalServiceType = "standard";
        }

        // Push values for forwarder insertion
        forwarderValues.push(adminId, forwarderId, Tapi, productType, finalServiceType);

        const taggedApiStatus = 1;
        // Push values for servisibility insertion
        servisibilityValues.push([adminId, Tapi, taggedApiStatus]);
      }

      // Insert the data into tbl_aggrigator_servisibility if there are values
      if (servisibilityValues.length > 0) {
        await mySqlQury(insertServisibilitySql, [servisibilityValues]);
        console.log('Servisibility data inserted successfully.');
      } else {
        console.log('No servisibility data to insert for Forwarders.');
      }

      // Insert the data into tbl_aggrigator_forwarder if forwarderValues is not empty
      if (forwarderValues.length > 0) {
        const resultForwarder = await mySqlQury(insertForwarderSql, forwarderValues);
        console.log('Forwarder data inserted successfully', resultForwarder);
      } else {
        console.log('No forwarder data to insert for Forwarders.');
      }
    }

    // Case when ManualForwarders are provided (if no Forwarders provided)
    if (!Forwarders || Forwarders.length === 0) {
      console.log('No Forwarders');

      if (form1.chooseManual && manualLR === 1) {
        console.log("Manual Forwarders", form1.chooseManual);

        // Prepare data for manual servisibility insertion using chooseManual
        const manualServisibilityData = [[adminId, form1.chooseManual, 0]];
        const resultManualServisibility = await mySqlQury(insertServisibilitySql, [manualServisibilityData]);
        console.log('Manual Servisibility data inserted successfully', resultManualServisibility);
      } else if (Apiintegration === 1 && form1.chooseAPIIntegration) {
        console.log("API Integration Forwarders", form1.chooseAPIIntegration);

        // Prepare data for API integration servisibility insertion using chooseAPIIntegration
        const apiIntegrationServisibilityData = [[adminId, form1.chooseAPIIntegration, 1]];
        const resultApiIntegrationServisibility = await mySqlQury(insertServisibilitySql, [apiIntegrationServisibilityData]);
        console.log('API Integration Servisibility data inserted successfully', resultApiIntegrationServisibility);
      } else {
        console.log('No chooseManual or chooseAPIIntegration data to insert into Servisibility.');
      }
    }



    if (!adminId) {
      return res.status(404).json({ message: 'set password please not found' });
    }
    let fod = 0;
    let billAggrigator = 0;
    let owner_risk = 0;
    let carrier_risk = 0;

    // Check the value of freight collection radio buttons
    if (form1.freightCollection === 'billToAggrigator') {
      billAggrigator = 1; // Set to 1 if "Bill to Client" is selected
    } else if (form1.freightCollection === 'FOD') {
      fod = 1; // Set to 1 if "Freight On Delivery" is selected
    }

    // Check the value of insurance type radio buttons
    if (form1.insuranceType === 'owner Risk') {
      owner_risk = 1; // Set to 1 if "Owner Risk" is selected
    } else if (form1.insuranceType === 'carrier Risk') {
      carrier_risk = 1; // Set to 1 if "Carrier Risk" is selected
    }


    // Insert Customer Details
    const insertCustomerSql = `
        INSERT INTO tbl_customers (
          first_name, last_name, email, country_code, mobile, 
          company_country, company_state, company_city, 
        Aggrigator_id,courier_name,company_address,company_name,website,client_type,service_type,
          from_date,from_to,fod,billclient,owner_risk,carrier_risk,account_number,
          billing_cycle,choose_bank,minimum_chargable_weight,	volumetric_factor,credit_terms
      
        ) 
        VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);
    `;

    const customerValues = [
      form1.contact_person || null,            // first_name
      form1.contact_person_last_name || null,      // last_name
      form1.Aggrigator_Email || null,          // email
      form1.companyCountry || null,            // country_code
      form1.Aggrigator_mobile || null,         // mobile
      form1.companyCountry || null,            // customers_country
      form1.companyState || null,              // customers_state
      form1.companyDistrict || null,           // customers_city
      adminId,
      form1.courierName,
      form1.companyAddress,
      form1.companyName,
      form1.website || null,
      form1.ProductType,
      form1.serviceType,
      form1.fromDate || null,                  // from_date
      form1.fromTo,
      fod,                                   // FOD
      billAggrigator,                        // Bilform1
      owner_risk,                            // Owner Risk
      carrier_risk,
      form1.accountNumber,
      form1.billingCycle,
      form1.chooseBank,
      form3['Min.charges_weight'] || null,
      form3.volumetric_ || null,
      form1.creditTerms || null


    ];


    // Execute the insert query for tbl_customers
    const resultCustomer = await mySqlQury(insertCustomerSql, customerValues);
    console.log("Customer data inserted:", resultCustomer);
    // const vendorId = resultCustomer.insertId;



    const contactTypes = ['sales', 'ops', 'accounts', 'rvp'];

    for (const type of contactTypes) {
      const names = form2[`${type}_name`] || [];
      const designations = form2[`${type}_designation`] || [];
      const emails = form2[`${type}_email`] || [];
      const phones = form2[`${type}_phone`] || [];
      console.log("client contact", names, emails, phones, phones)

      const insertContactSql = `
            INSERT INTO tbl_client_contacts (
              Aggrigator_id, name, phone, email, designation, department
            ) VALUES (?, ?, ?, ?, ?, ?)
          `;

      const maxContacts = Math.max(names.length, designations.length, emails.length, phones.length);

      for (let i = 0; i < maxContacts; i++) {
        // Skip if all values at this index are null/empty
        if (!names[i]) {
          continue;
        }

        const contactValues = [
          adminId,
          names[i] || null,
          phones[i] || null,
          emails[i] || null,
          designations[i] || null,
          type
        ];
        await mySqlQury(insertContactSql, contactValues);
      }
    }
    // Insert Rates
    const rateEntries = [];

    // Check if Excel file was uploaded and process it
    if (excelFile) {
      const XLSX = require('xlsx');
      const workbook = XLSX.readFile(excelFile.path);

      // Find the LTL Rate sheet
      const ltlRateSheet = workbook.Sheets['LTL Rate'];
      if (ltlRateSheet) {
        const sheetData = XLSX.utils.sheet_to_json(ltlRateSheet);

        // Process each row in the sheet
        for (const row of sheetData) {
          const zoneOrigin = row.Zone; // This is the origin zone (like 'N1')

          // Skip rows that only have Zone property with no values (like { Zone: 'E3' })
          const hasRates = Object.keys(row).length > 1;

          if (hasRates) {
            // Process each destination zone and its rate
            for (const [key, value] of Object.entries(row)) {
              // Skip the 'Zone' column as it's the origin
              if (key !== 'Zone' && value !== undefined) {
                const zoneDest = key; // This is the destination zone (like 'N1', 'N2', etc.)
                const rateValue = parseFloat(value);

                if (!isNaN(rateValue)) {
                  rateEntries.push([
                    adminId,
                    zoneOrigin,
                    zoneDest,
                    form1.AggrigatorType,
                    form1.serviceType,
                    rateValue
                  ]);
                }
              }
            }
          }
        }
      }

      // Process LTL TAT sheet
      const tatSheet = workbook.Sheets['LTL TAT'];
      if (tatSheet) {
        const tatData = XLSX.utils.sheet_to_json(tatSheet);

        // Create TAT table
        const table2Name = `tbl_TAT_Aggrigator_${adminId}`;
        const createTable2SQL = `
          CREATE TABLE IF NOT EXISTS ${table2Name} (
              id BIGINT(20) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
              Aggrigator_id INT(20),
              zone_origin VARCHAR(50),
              zone_destination VARCHAR(50),
              days INT,
              FOREIGN KEY (Aggrigator_id) REFERENCES tbl_aggrigator(id) ON DELETE CASCADE,
              UNIQUE KEY (zone_origin, zone_destination, Aggrigator_id)
          )
        `;
        await mySqlQury(createTable2SQL);

        // Process each row in the TAT sheet
        for (const row of tatData) {
          const zoneOrigin = row.Zone;

          // Skip rows that only have Zone property with no values
          const hasTatData = Object.keys(row).length > 1;

          if (hasTatData) {
            // Process each destination zone and its TAT days
            for (const [key, value] of Object.entries(row)) {
              // Skip the 'Zone' column as it's the origin
              if (key !== 'Zone' && value !== undefined) {
                const zoneDestination = key;
                const days = parseInt(value, 10);

                // Log parsed values for debugging
                console.log(`Zone Origin: ${zoneOrigin}, Zone Destination: ${zoneDestination}, Days: ${days}`);

                if (isNaN(days) || days === 0) {
                  console.error('Invalid days value:', value);
                  continue; // Skip invalid entries
                }

                // Check if the record already exists
                const existingTatRecord = await mySqlQury(
                  `
                    SELECT id, days 
                    FROM ${table2Name} 
                    WHERE zone_origin = ? AND zone_destination = ? AND Aggrigator_id = ?
                  `,
                  [zoneOrigin, zoneDestination, adminId]
                );

                if (existingTatRecord.length > 0) {
                  // Update days if the existing value is different
                  if (existingTatRecord[0].days !== days) {
                    await mySqlQury(
                      `
                        UPDATE ${table2Name} 
                        SET days = ?
                        WHERE zone_origin = ? AND zone_destination = ? AND Aggrigator_id = ?
                      `,
                      [days, zoneOrigin, zoneDestination, adminId]
                    );
                  }
                } else {
                  // Insert new TAT entry if it does not exist
                  await mySqlQury(
                    `
                      INSERT INTO ${table2Name} (Aggrigator_id, zone_origin, zone_destination, days) 
                      VALUES (?, ?, ?, ?)
                    `,
                    [adminId, zoneOrigin, zoneDestination, days]
                  );
                }
              }
            }
          }
        }
      }
    }

    const insertRateSql = `
      INSERT INTO tbl_client_rates (
        Aggrigator_id, zone_origin, zone_destination, client_type, service_type, rate
      ) VALUES (?, ?, ?, ?, ?, ?)
    `;

    for (const entry of rateEntries) {
      await mySqlQury(insertRateSql, entry);
    }
    // Insert Additional Charges
    const additionalCharges = [
      {
        charge_name: 'lr',
        min_value: form4.lr_min_value,
        max_value: form4.lr_max_value,
        condition_based: form4.lr_condition,
        max_value_calculation: form4.lr_condition === 'and' ? null : form4.charge_type_lr_or,
        calculation_based_on_min: form4.lr_charge_based_calculation || null,
        calculation_based_on_max: form4.lr_criteria_charge || null
      },
      {
        charge_name: 'fs',
        min_value: form4.fs_min_value,
        max_value: form4.fs_max_value,
        condition_based: form4.fs_condition,
        max_value_calculation: form4.fs_condition === 'and' ? null : form4.charge_type_fs_or,
        calculation_based_on_min: form4.fs_charge_based_calculation || null,
        calculation_based_on_max: form4.fs_criteria_charge || null
      },
      {
        charge_name: 'fm',
        min_value: form4.fm_min_value,
        max_value: form4.fm_max_value,
        condition_based: form4.fm_condition,
        max_value_calculation: form4.fm_condition === 'and' ? null : form4.charge_type_fm_or,
        calculation_based_on_min: form4.fm_charge_based_calculation || null,
        calculation_based_on_max: form4.fm_criteria_charge || null
      },
      {
        charge_name: 'fov_owner',
        min_value: form4.fov_owner_min_value,
        max_value: form4.fov_owner_max_value,
        condition_based: form4.fov_owner_condition,
        max_value_calculation: form4.fov_owner_condition === 'and' ? null : form4.charge_type_fov_owner_or,
        calculation_based_on_min: form4.fov_owner_charge_based_calculation || null,
        calculation_based_on_max: form4.fov_owner_criteria_charge || null
      },
      {
        charge_name: 'to_pay',
        min_value: form4.to_pay_min_value,
        max_value: form4.to_pay_max_value,
        condition_based: form4.to_pay_condition,
        max_value_calculation: form4.to_pay_condition === 'and' ? null : form4.charge_type_to_pay_or,
        calculation_based_on_min: form4.to_pay_charge_based_calculation || null,
        calculation_based_on_max: form4.to_pay_criteria_charge || null
      },
      {
        charge_name: 'cod',
        min_value: form4.cod_min_value,
        max_value: form4.cod_max_value,
        condition_based: form4.cod_condition,
        max_value_calculation: form4.cod_condition === 'and' ? null : form4.charge_type_cod_or,
        calculation_based_on_min: form4.cod_charge_based_calculation || null,
        calculation_based_on_max: form4.cod_criteria_charge || null
      },
      {
        charge_name: 'check_handling_weight',
        min_value: form4.check_handling_weight_min_value,
        max_value: form4.check_handling_weight_max_value,
        condition_based: form4.check_handling_weight_condition,
        max_value_calculation: form4.check_handling_weight_condition === 'and' ? null : form4.charge_type_check_handling_weight_or,
        calculation_based_on_min: form4.check_handling_weight_charge_based_calculation || null,
        calculation_based_on_max: form4.check_handling_weight_criteria_charge || null
      },
      {
        charge_name: 'green_tax',
        min_value: form4.green_tax_min_value,
        max_value: form4.green_tax_max_value,
        condition_based: form4.green_tax_condition,
        max_value_calculation: form4.green_tax_condition === 'and' ? null : form4.charge_type_green_tax_or,
        calculation_based_on_min: form4.green_tax_charge_based_calculation || null,
        calculation_based_on_max: form4.green_tax_criteria_charge || null
      },
      {
        charge_name: 'oda',
        min_value: form4.oda_min_value,
        max_value: form4.oda_max_value,
        condition_based: form4.oda_condition,
        max_value_calculation: form4.oda_condition === 'and' ? null : form4.charge_type_oda_or,
        calculation_based_on_min: form4.oda_charge_based_calculation || null,
        calculation_based_on_max: form4.oda_criteria_charge || null
      }
    ];

    const insertChargeSql = `
          INSERT INTO tbl_additional_charges_client (
            Aggrigator_id, charge_name, calculation_based_on_min, calculation_based_on_max, min_value, max_value, 
            condition_based, chargable_value_type
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `;

    for (const charge of additionalCharges) {
      if (!charge.calculation_based_on_min || charge.calculation_based_on_min === '0') {
        console.log(`Skipping charge ${charge.charge_name} due to missing or zero calculation_based_on_min value`);
        continue;
      }
      const chargeValues = [
        adminId,
        charge.charge_name,
        charge.calculation_based_on_min || null,
        charge.calculation_based_on_max || null,
        charge.min_value || null,
        charge.max_value || null,
        charge.condition_based || null,
        charge.max_value_calculation || null
      ];
      await mySqlQury(insertChargeSql, chargeValues);
    }
    if (!adminId) {
      return res.status(404).json({ message: 'adminId not found' });
    }
    // const tableName = `tbl_zone_mapping_${forwarderName}_${forwarderId}_${forwarderType}`;
    const tableName = `tbl_zone_mapping_Aggrigator_${adminId}`;

    // Create the zone mapping table dynamically
    const uniqueForeignKeyName = `fk_aggrigator_id_${adminId}`;
    const createTableSQL = `
      CREATE TABLE IF NOT EXISTS ${tableName} (
          id BIGINT(20) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
          zone VARCHAR(50),
          city VARCHAR(255),
          state VARCHAR(255),
          Aggrigator_id INT(20),
          CONSTRAINT ${uniqueForeignKeyName} FOREIGN KEY (Aggrigator_id) REFERENCES tbl_aggrigator(id) ON DELETE CASCADE,
          UNIQUE KEY unique_zone_mapping (zone, city, state, Aggrigator_id)
      )
    `;
    await mySqlQury(createTableSQL);

    // Process each zone in the form5 object
    for (const [zone, { citySelect = [], stateSelectSecondary = [] }] of Object.entries(form5)) {
      const maxLength = Math.max(citySelect.length, stateSelectSecondary.length);

      for (let i = 0; i < maxLength; i++) {
        const city = citySelect[i] || ''; // Use empty string if citySelect is shorter
        const state = stateSelectSecondary[i] || ''; // Use empty string if stateSelectSecondary is shorter

        if (city || state) { // Proceed only if there is valid data to process
          // Check if the record already exists for the combination
          const existingRecord = await mySqlQury(`
            SELECT id, zone FROM ${tableName} 
            WHERE city = ? AND state = ? AND Aggrigator_id = ?
          `, [city, state, adminId]);

          if (existingRecord.length > 0) {
            // Update the zone for the existing record if it has changed
            if (existingRecord[0].zone !== zone) {
              await mySqlQury(`
                UPDATE ${tableName} 
                SET zone = ?
                WHERE city = ? AND state = ? AND Aggrigator_id = ?
              `, [zone, city, state, adminId]);
            }
          } else {
            // Insert new record if it does not exist
            await mySqlQury(`
              INSERT INTO ${tableName} (zone, city, state, Aggrigator_id) VALUES (?, ?, ?, ?)
            `, [zone, city, state, adminId]);
          }
        }
      }
    }





    // Commit the transaction if everything is successfu

    // Commit the transaction if everything is successful
    await mySqlQury('COMMIT');
    res.status(200).send('Data of vendor is succesfully saved');
  } catch (error) {
    console.error('Error in generating vendor details:', error);
    // Rollback the transaction if any operation fails
    await mySqlQury('ROLLBACK');
    res.status(500).send('Internal Server Error');
  }
}
const predispatchAggOnStd = async (req, res) => {

  console.log("here the req.body in the ", req.body)
  console.log("logo name,", req.files)// Log oth
  console.log("logo", req.body)
  // console.log("shabbar ",shabbar)
  // const connection = await mySqlQury('START TRANSACTION'); // Start the transaction
  await mySqlQury('START TRANSACTION');
  try {
    const form1ValidationErrors = validateAggregatorForm1(req.body.form1, req.files);
    if (form1ValidationErrors) {
      return res.status(400).json({
        status: 'error',
        message: 'Form 1 validation failed',
        errors: form1ValidationErrors
      });
    }
    const form3ValidationErrors = validateAggregatorForm3Standard(req.body.form3);
    if (form3ValidationErrors) {
      return res.status(400).json({
        status: 'error',
        message: 'Form 3 validation failed',
        errors: form3ValidationErrors
      });
    }
    let logoPath = null;
    let aggrigator_bind = 0;
    let binded_forwarder = 0;
    let taggedApi = null;
    let Apiintegration = 0;
    let manualLR = 0;
    // let pincode_servisibility = 0;
    // let servicibilityTable = null;


    // Check if any file was uploaded
    if (req.files && req.files.length > 0) {
      // Get the path of the uploaded file
      logoPath = req.files[0].path.replace(/\\/g, '/'); // Replace backslashes with forward slashes

      // Remove the "public/" part to make it relative to the public directory
      logoPath = logoPath.replace(/^.*[\\/]public[\\/]/, '');
    } else {
      console.log("No file uploaded.");
    }
    console.log("form1 all details data", req.body)
    console.log("form1 data", req.body.form1)



    const { form1, form2, form3, form4, form9, ZoneData, form10, Forwarders } = req.body
    const parsed10 = JSON.parse(JSON.stringify(form10))
    console.log("form 10 parsed:", JSON.parse(JSON.stringify(form10)));
    const ZoneDat = JSON.parse(JSON.stringify(ZoneData));
    //
    // console.log("parse form 10 data",JSON.parse(form10));
    console.log("additionalChargesDetails format data", parsed10["0"].additionalChargesDetails);
    console.log("additionalAmountDetails format data", parsed10["0"].additionalAmountDetails);






    // If you need to log the entire parsed form10 data for debugging
    console.log("form 10 parsed:", JSON.parse(JSON.stringify(form10)));

    // console.log("form 2 data ",form2)

    // console.log("dsdsd",dsdsd)



    // console.log("ddgasd",Forwarders.length)
    // console.log("sdass",Forwarders)
    //  console.log("psadsd",sdass)
    // if(Forwarders.length > 1) {

    if (Forwarders && Forwarders.length > 1) {

      binded_forwarder = 2;
      console.log("in the 2")
    }
    if (Forwarders && Forwarders.length === 1) {

      binded_forwarder = 1;
      console.log("dshgdhsin 1")

    }
    // console.log("in the 1",dsdd)



    // Now you can use parsedForm1, parsedForm2, etc., along with logoPath
    let servise = "Standard";

    //     // console.log("Parsed Form 2:", parsedForm2);
    //     // console.log("console.log form2", form2)
    //     // console.log("Parsed Form  5 and 6:", parsedForm6,parsedForm5);
    if (form1.Aggrigator_bind === 'yes') {
      const forwarderDetails = form1.ForwarderList.split('/');
      aggrigator_bind = 1;


      taggedApi = forwarderDetails[1];
      sType = forwarderDetails[2];

      if (taggedApi === 'DTDC') {

      }
      else if (taggedApi === 'Delhivery') {

      }

    }
    if (form1) {
      const { Aggrigator_defination, Aggrigator_bind, chooseAPIIntegration } = form1;

      // Check if Aggrigator_defination is '0'
      if (Aggrigator_defination === '0') {
        // If Aggrigator_bind is 'yes' or chooseAPIIntegration is provided, set Apiintegration to 1
        if (Aggrigator_bind === 'yes' && chooseAPIIntegration) {
          Apiintegration = 1;
        }

        // If Aggrigator_bind is 'no', set manualLR to 1
        if (Aggrigator_bind === 'no') {
          manualLR = 1;
        }
      }
    }
    //     // console.log("dsjds", dsd)
    //     console.log("forwader and binding details", aggrigator_bind, binded_forwarder,taggedApi);
    //     //  console.log("dhjdhsjd",dsdksd)

    let insertAdminSql = `
           INSERT INTO tbl_aggrigator(first_name, last_name, email, country_code, phone_no, Aggrigator_company_name, logo_path,binded_with_forwarder,Tagged_api,service_type,aggrigator_type,dispatch_agg,manualLr,api_integration)
           VALUES (?, ?, ?, ?, ?, ?, ?,?,?,?,?,?,?,?)
        `;

    //     // Prepare the values to be inserted, including the logo path
    let adminValues = [
      form1.contact_person,
      form1.Aggrigator_last_name,
      form1.Aggrigator_Email,
      form1.companyCountry,
      form1.Aggrigator_mobile,
      // Assuming '2' ,is the role ID for the admin
      form1.companyName,
      logoPath,
      binded_forwarder,
      taggedApi,
      servise,
      form1.ProductType,
      form1.Aggrigator_defination,
      manualLR,
      Apiintegration

      // Include the logo path here
    ];
    // const lrtype = 'cheapest'
    // Execute the insert query for tbl_admin
    const resultAdmin = await mySqlQury(insertAdminSql, adminValues);
    const adminId = resultAdmin.insertId;

    const insertForwarderSql = `
          INSERT INTO tbl_aggrigator_forwarder 
          (Aggrigator_id, Forwarder_id, Tagged_api, productType, service_type)
          VALUES ${Forwarders && Forwarders.length > 0 ? Forwarders.map(() => '(?, ?, ?, ?, ?)').join(', ') : ''};
      `;

    const insertServisibilitySql = `
        INSERT INTO tbl_aggrigator_servisibility (Aggrigator_id, Tagged_api, tagged_api_status) 
        VALUES ?;
      `;

    const forwarderValues = [];
    const servisibilityValues = [];

    // Case when Forwarders are provided
    if (Forwarders && Forwarders.length > 0) {
      // Iterate over each forwarder string, split by `/`, and push values for insertion
      for (let i = 0; i < Forwarders.length; i++) {
        const [forwarderId, Tapi, productType, serviceType] = Forwarders[i].split('/');

        let finalServiceType = serviceType; // Use a mutable variable for conditional assignment
        if (productType === 'Standard-Air' || productType === "Standard-Surface") {
          finalServiceType = "standard";
        }

        // Push values for forwarder insertion
        forwarderValues.push(adminId, forwarderId, Tapi, productType, finalServiceType);
        const taggedApiStatus = 1;
        // Push values for servisibility insertion
        servisibilityValues.push([adminId, Tapi, taggedApiStatus]);
      }

      // Insert the data into tbl_aggrigator_servisibility if there are values
      if (servisibilityValues.length > 0) {
        await mySqlQury(insertServisibilitySql, [servisibilityValues]);
        console.log('Servisibility data inserted successfully.');
      } else {
        console.log('No servisibility data to insert for Forwarders.');
      }

      // Insert the data into tbl_aggrigator_forwarder if forwarderValues is not empty
      if (forwarderValues.length > 0) {
        const resultForwarder = await mySqlQury(insertForwarderSql, forwarderValues);
        console.log('Forwarder data inserted successfully', resultForwarder);
      } else {
        console.log('No forwarder data to insert for Forwarders.');
      }
    }

    // Case when ManualForwarders are provided (if no Forwarders provided)
    if (!Forwarders || Forwarders.length === 0) {
      console.log('No Forwarders');

      if (form1.chooseManual && manualLR === 1) {
        console.log("Manual Forwarders", form1.chooseManual);

        // Prepare data for manual servisibility insertion using chooseManual
        const manualServisibilityData = [[adminId, form1.chooseManual, 0]];
        const resultManualServisibility = await mySqlQury(insertServisibilitySql, [manualServisibilityData]);
        console.log('Manual Servisibility data inserted successfully', resultManualServisibility);
      } else if (Apiintegration === 1 && form1.chooseAPIIntegration) {
        console.log("API Integration Forwarders", form1.chooseAPIIntegration);

        // Prepare data for API integration servisibility insertion using chooseAPIIntegration
        const apiIntegrationServisibilityData = [[adminId, form1.chooseAPIIntegration, 1]];
        const resultApiIntegrationServisibility = await mySqlQury(insertServisibilitySql, [apiIntegrationServisibilityData]);
        console.log('API Integration Servisibility data inserted successfully', resultApiIntegrationServisibility);
      } else {
        console.log('No chooseManual or chooseAPIIntegration data to insert into Servisibility.');
      }
    }

    if (!adminId) {
      return res.status(404).json({ message: 'set password please not found' });
    }
    let fod = 0;
    let billAggrigator = 0;
    let owner_risk = 0;
    let carrier_risk = 0;

    // Check the value of freight collection radio buttons
    if (form1.freightCollection === 'billToAggrigator') {
      billAggrigator = 1; // Set to 1 if "Bill to Client" is selected
    } else if (form1.freightCollection === 'FOD') {
      fod = 1; // Set to 1 if "Freight On Delivery" is selected
    }

    // Check the value of insurance type radio buttons
    if (form1.insuranceType === 'owner Risk') {
      owner_risk = 1; // Set to 1 if "Owner Risk" is selected
    } else if (form1.insuranceType === 'carrier Risk') {
      carrier_risk = 1; // Set to 1 if "Carrier Risk" is selected
    }


    //     // Insert Customer Details
    const insertCustomerSql = `
          INSERT INTO tbl_customers (
            first_name, last_name, email, country_code, mobile, 
            company_country, company_state, company_city, 
          Aggrigator_id,courier_name,company_address,company_name,website,client_type,service_type,
            from_date,from_to,fod,billclient,owner_risk,carrier_risk,account_number,
            billing_cycle,choose_bank,minimum_chargable_weight,	volumetric_factor,credit_terms
        
          ) 
          VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);
      `;

    const customerValues = [
      form1.contact_person || null,            // first_name
      form1.contact_person_last_name || null,      // last_name
      form1.Aggrigator_Email || null,          // email
      form1.companyCountry || null,            // country_code
      form1.Aggrigator_mobile || null,         // mobile
      form1.companyCountry || null,            // customers_country
      form1.companyState || null,              // customers_state
      form1.companyDistrict || null,           // customers_city
      adminId,
      form1.courierName,
      form1.companyAddress,
      form1.companyName,
      form1.website || null,
      form1.ProductType,
      form1.serviceType,
      form1.fromDate || null,                  // from_date
      form1.fromTo,
      fod,                                   // FOD
      billAggrigator,                        // Bilform1
      owner_risk,                            // Owner Risk
      carrier_risk,
      form1.accountNumber,
      form1.billingCycle,
      form1.chooseBank,
      form3['Min.charges_weight'] || null,
      form3.volumetric_ || null,
      form1.creditTerms || null


    ];


    //     // Execute the insert query for tbl_customers
    const resultCustomer = await mySqlQury(insertCustomerSql, customerValues);
    console.log("Customer data inserted:", resultCustomer);
    // const vendorId = resultCustomer.insertId;

    // Assuming mySqlQury returns the result with insertId

    // Helper function to insert contacts
    const contactTypes = ['sales', 'ops', 'accounts', 'rvp'];

    for (const type of contactTypes) {
      const names = form2[`${type}_name`] || [];
      const designations = form2[`${type}_designation`] || [];
      const emails = form2[`${type}_email`] || [];
      const phones = form2[`${type}_phone`] || [];

      const insertContactSql = `
              INSERT INTO tbl_client_contacts (
                Aggrigator_id, name, phone, email, designation, department
              ) VALUES (?, ?, ?, ?, ?, ?)
            `;

      const maxContacts = Math.max(names.length, designations.length, emails.length, phones.length);

      for (let i = 0; i < maxContacts; i++) {
        const contactValues = [
          adminId,
          names[i] || null,
          phones[i] || null,
          emails[i] || null,
          designations[i] || null,
          type
        ];
        await mySqlQury(insertContactSql, contactValues);
      }
    }
    // Insert Additional Charges
    const additionalCharges = [
      {
        charge_name: 'lr',
        min_value: form4.lr_min_value,
        max_value: form4.lr_max_value,
        condition_based: form4.lr_condition,
        max_value_calculation: form4.lr_condition === 'and' ? null : form4.charge_type_lr_or,
        calculation_based_on_min: form4.lr_charge_based_calculation || null,
        calculation_based_on_max: form4.lr_criteria_charge || null
      },
      {
        charge_name: 'fs',
        min_value: form4.fs_min_value,
        max_value: form4.fs_max_value,
        condition_based: form4.fs_condition,
        max_value_calculation: form4.fs_condition === 'and' ? null : form4.charge_type_fs_or,
        calculation_based_on_min: form4.fs_charge_based_calculation || null,
        calculation_based_on_max: form4.fs_criteria_charge || null
      },
      {
        charge_name: 'fm',
        min_value: form4.fm_min_value,
        max_value: form4.fm_max_value,
        condition_based: form4.fm_condition,
        max_value_calculation: form4.fm_condition === 'and' ? null : form4.charge_type_fm_or,
        calculation_based_on_min: form4.fm_charge_based_calculation || null,
        calculation_based_on_max: form4.fm_criteria_charge || null
      },
      {
        charge_name: 'fov_owner',
        min_value: form4.fov_owner_min_value,
        max_value: form4.fov_owner_max_value,
        condition_based: form4.fov_owner_condition,
        max_value_calculation: form4.fov_owner_condition === 'and' ? null : form4.charge_type_fov_owner_or,
        calculation_based_on_min: form4.fov_owner_charge_based_calculation || null,
        calculation_based_on_max: form4.fov_owner_criteria_charge || null
      },
      {
        charge_name: 'to_pay',
        min_value: form4.to_pay_min_value,
        max_value: form4.to_pay_max_value,
        condition_based: form4.to_pay_condition,
        max_value_calculation: form4.to_pay_condition === 'and' ? null : form4.charge_type_to_pay_or,
        calculation_based_on_min: form4.to_pay_charge_based_calculation || null,
        calculation_based_on_max: form4.to_pay_criteria_charge || null
      },
      {
        charge_name: 'cod',
        min_value: form4.cod_min_value,
        max_value: form4.cod_max_value,
        condition_based: form4.cod_condition,
        max_value_calculation: form4.cod_condition === 'and' ? null : form4.charge_type_cod_or,
        calculation_based_on_min: form4.cod_charge_based_calculation || null,
        calculation_based_on_max: form4.cod_criteria_charge || null
      },
      {
        charge_name: 'check_handling_weight',
        min_value: form4.check_handling_weight_min_value,
        max_value: form4.check_handling_weight_max_value,
        condition_based: form4.check_handling_weight_condition,
        max_value_calculation: form4.check_handling_weight_condition === 'and' ? null : form4.charge_type_check_handling_weight_or,
        calculation_based_on_min: form4.check_handling_weight_charge_based_calculation || null,
        calculation_based_on_max: form4.check_handling_weight_criteria_charge || null
      },
      {
        charge_name: 'green_tax',
        min_value: form4.green_tax_min_value,
        max_value: form4.green_tax_max_value,
        condition_based: form4.green_tax_condition,
        max_value_calculation: form4.green_tax_condition === 'and' ? null : form4.charge_type_green_tax_or,
        calculation_based_on_min: form4.green_tax_charge_based_calculation || null,
        calculation_based_on_max: form4.green_tax_criteria_charge || null
      },
      {
        charge_name: 'oda',
        min_value: form4.oda_min_value,
        max_value: form4.oda_max_value,
        condition_based: form4.oda_condition,
        max_value_calculation: form4.oda_condition === 'and' ? null : form4.charge_type_oda_or,
        calculation_based_on_min: form4.oda_charge_based_calculation || null,
        calculation_based_on_max: form4.oda_criteria_charge || null
      }
    ];

    const insertChargeSql = `
                INSERT INTO tbl_additional_charges_client (
                  Aggrigator_id, charge_name, calculation_based_on_min, calculation_based_on_max, min_value, max_value, 
                  condition_based, chargable_value_type
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
              `;

    for (const charge of additionalCharges) {
      if (!charge.calculation_based_on_min || charge.calculation_based_on_min === '0') {
        console.log(`Skipping charge ${charge.charge_name} due to missing or zero calculation_based_on_min value`);
        continue;
      }
      const chargeValues = [
        adminId,
        charge.charge_name,
        charge.calculation_based_on_min || null,
        charge.calculation_based_on_max || null,
        charge.min_value || null,
        charge.max_value || null,
        charge.condition_based || null,
        charge.max_value_calculation || null
      ];
      await mySqlQury(insertChargeSql, chargeValues);
    }
    const insertTatSql = `
            INSERT INTO tbl_std_agg_tat (aggrigator_id, zone, days) VALUES (?, ?, ?)
          `;

    for (const key in req.body) {
      // Check if the key starts with 'form9[zones[' and ends with ']'
      if (key.startsWith('form9[zones[') && key.endsWith(']')) {
        // Extract the zone name (e.g., 'A' from 'form9[zones[A]]') and remove square brackets
        const zone = key.slice(11, -1).replace(/[\[\]]/g, ''); // Removes '[' and ']' from the extracted string

        // Get the corresponding value for the zone (the number of days)
        const days = req.body[key];

        // Log the key, zone, and days value for debugging
        console.log(`Processing key: ${key}`);
        console.log(`Extracted zone: ${zone}`);
        console.log(`Days for zone ${zone}: ${days}`);

        // If there's a valid value for days, insert it into the table
        if (days && days !== '') {
          try {
            // Log the query and values before inserting
            console.log(`Inserting TAT for vendor ${adminId}, zone ${zone}, days ${days}`);
            await mySqlQury(insertTatSql, [adminId, zone, days]);
          } catch (err) {
            console.error(`Error inserting TAT for zone ${zone}:`, err);
          }
        } else {
          console.log(`Skipping TAT for zone ${zone} due to missing value`);
        }
      }
    }
    const insertZoneMapSql = `
          INSERT INTO tbl_std_agg_zone_map (aggrigator_id, zone, rule, city, state) VALUES (?, ?, ?, ?, ?)
        `;

    for (const zone of ZoneDat) {
      const { zoneName, selectedRule, selectedCities = [], selectedStates = [] } = zone;

      // Ensure the arrays are of equal length
      const maxLength = Math.max(selectedCities.length, selectedStates.length);

      // Loop through the maximum possible length of cities or states
      for (let i = 0; i < maxLength; i++) {
        const city = selectedCities[i] || null; // Use `null` if no city exists at index `i`
        const state = selectedStates[i] || null; // Use `null` if no state exists at index `i`

        // Insert the data, including nulls if both city and state are missing
        try {
          await mySqlQury(insertZoneMapSql, [adminId, zoneName, selectedRule, city, state]);
        } catch (error) {
          console.error(`Failed to insert for zone: ${zoneName}, Error: ${error.message}`);
        }
      }

      // If no cities or states exist, ensure at least one row is inserted with null values
      if (selectedCities.length === 0 && selectedStates.length === 0) {
        try {
          await mySqlQury(insertZoneMapSql, [adminId, zoneName, selectedRule, null, null]);
        } catch (error) {
          console.error(`Failed to insert nulls for zone: ${zoneName}, Error: ${error.message}`);
        }
      }
    }
    // Assuming form10 is parsed correctly and the data structure is:


    // Loop through each slab in parsed10
    for (const [index, slab] of Object.entries(parsed10)) {
      const { weightSlab, zones, additionalChargesDetails, additionalAmountDetails } = slab;

      console.log("Processing slab:", weightSlab, zones, additionalChargesDetails, additionalAmountDetails);

      // Save weightSlab to tbl_std_weightSlabs
      const weightSlabQuery = `
          INSERT INTO tbl_std_agg_weightslabs (aggrigator_id, min_weight, max_weight, unit) 
          VALUES (?, ?, ?, ?)
        `;
      const weightSlabResult = await mySqlQury(weightSlabQuery, [
        adminId,
        weightSlab.min,
        weightSlab.max,
        weightSlab.unit,
      ]);
      const weightSlabId = weightSlabResult.insertId;

      console.log(`Inserted weight slab ID: ${weightSlabId}`);

      // Save zones to tbl_std_Zones
      for (const [zoneName, zoneValue] of Object.entries(zones)) {
        const zoneQuery = `
            INSERT INTO tbl_std_agg_zones (aggrigator_id, zone_name, zone_value, weight_slab_id) 
            VALUES (?, ?, ?, ?)
          `;
        await mySqlQury(zoneQuery, [adminId, zoneName, zoneValue, weightSlabId]);

        console.log(`Inserted zone for weight slab ID ${weightSlabId}: ${zoneName} = ${zoneValue}`);
      }

      // Save additionalCharges to tbl_std_additional_charges
      // additionalChargesDetails is an object, not an array, so we need to handle it differently
      for (const [chargeIndex, charge] of Object.entries(additionalChargesDetails)) {
        console.log("Processing additional charge:", charge);

        const { desc, weight, unit } = charge;
        if (!desc || weight === null || weight === '' || isNaN(weight) || !unit) {
          console.log(
            `Skipping invalid additional charge at index ${index}: description=${desc}, weight=${weight}, unit=${unit}`
          );
          continue; // Skip this iteration if any required field is invalid
        }

        const additionalChargeQuery = `
            INSERT INTO tbl_std_agg_additional_charges (aggrigator_id, weight_slab_id, description, weight, unit) 
            VALUES (?, ?, ?, ?, ?)
          `;
        const additionalChargeResult = await mySqlQury(additionalChargeQuery, [
          adminId,
          weightSlabId,
          desc,
          weight,
          unit,
        ]);
        const additionalChargeId = additionalChargeResult.insertId;

        console.log(`Inserted additional charge ID: ${additionalChargeId}`);

        // Save additionalAmount to tbl_std_additionalAmounts
        // additionalAmountDetails is an object, not an array, so we need to handle it similarly
        for (const [amountIndex, amountObject] of Object.entries(additionalAmountDetails)) {
          if (!amountObject || typeof amountObject !== "object") {
            console.warn(`Skipping invalid additionalAmount at index ${amountIndex}: ${amountObject}`);
            continue; // Skip invalid entries
          }

          // Process valid `amountObject`
          for (const [zone, amount] of Object.entries(amountObject)) {
            console.log(`Processing zone: ${zone}, amount: ${amount}`);
            if (amount === null || amount === '' || isNaN(amount)) {
              console.log(`Skipping invalid amount for zone: ${zone}`);
              continue; // Skip this iteration if the amount is invalid
            }

            const additionalAmountQuery = `
                INSERT INTO tbl_std_agg_additionalamounts (aggrigator_id, additional_charge_id, zone_name, amount) 
                VALUES (?, ?, ?, ?)
              `;

            try {
              await mySqlQury(additionalAmountQuery, [
                adminId,
                additionalChargeId,
                zone,
                amount,
              ]);
              console.log(
                `Inserted additional amount for charge ID ${additionalChargeId}: Zone = ${zone}, Amount = ${amount}`
              );
            } catch (error) {
              console.error(
                `Error inserting additional amount for charge ID ${additionalChargeId}, Zone = ${zone}: ${error.message}`
              );
            }
          }
        }
      }
    }




    // Commit the transaction if everything is successful
    await mySqlQury('COMMIT');
    res.status(200).send('Data of vendor is succesfully saved');
  } catch (error) {
    console.error('Error in generating vendor details:', error);
    // Rollback the transaction if any operation fails
    await mySqlQury('ROLLBACK');
    res.status(500).send('Internal Server Error');
  }
}
const apiLogisticPartnerExpress = async (req, res) => {
  const { global_additional_charges, slab_inputs, volumetric_factor, courier_id, business_volume } = req.body;
  console.log("global_additional_charges jhajd", global_additional_charges);
  const nestedSlabs = unflattenSlabInputs(slab_inputs);
  // console.log("dskhdksd",djgdsdg)
  console.log(JSON.stringify(nestedSlabs, null, 2));
  const zoneRateAndslabAdd = nestedSlabs; // Use as object, not string
  console.log("volumetric_factorsas", volumetric_factor);
  console.log("courier_idsas", courier_id);
  console.log("business_volume", business_volume);

  // Start MySQL transaction
  await mySqlQury('START TRANSACTION');
  try {
    // 1. Get the courier name and tagged_api from tbl_courier_details
    const courierRows = await mySqlQury(
      'SELECT company_name, Tagged_api FROM tbl_courier_details WHERE id = ?',
      [courier_id]
    );
    if (!courierRows || courierRows.length === 0) {
      await mySqlQury('ROLLBACK');
      return res.status(400).json({ success: false, message: 'Invalid courier_id' });
    }
    const lp_name = courierRows[0].company_name;
    const tagged_api = courierRows[0].Tagged_api;

    // 2. Insert into tbl_logistics_partner
    const result = await mySqlQury(
      `INSERT INTO tbl_logistics_partner 
            (tagged_api, courier_id, volumetric_factor, business_volume, name, created_at, updated_at)
           VALUES (?, ?, ?, ?, ?, NOW(), NOW())`,
      [tagged_api, courier_id, volumetric_factor, business_volume, lp_name]
    );
    const lp_id = result.insertId;

    // 3. Insert global_additional_charges into tbl_exp_lp_additional_charges
    if (Array.isArray(global_additional_charges)) {
      for (const charge of global_additional_charges) {
        const {
          charge_name,
          calculation_based_on_min,
          min_value,
          calculation_based_on_max,
          max_value,
          condition_based,
          chargable_value_type
        } = charge;

        await mySqlQury(
          `INSERT INTO tbl_exp_lp_additional_charges 
                (lp_id, charge_name, calculation_based_on_min, calculation_based_on_max, min_value, max_value, condition_based, chargable_value_type, created_at, updated_at)
               VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())`,
          [
            lp_id,
            charge_name || null,
            calculation_based_on_min || null,
            calculation_based_on_max || null,
            min_value || null,
            max_value || null,
            condition_based || null,
            chargable_value_type || null
          ]
        );
      }
    }

    // 4. Insert zones_input into tbl_exp_lp_zones_rates
    if (zoneRateAndslabAdd && Array.isArray(zoneRateAndslabAdd.slabs)) {
      for (const slab of zoneRateAndslabAdd.slabs) {
        if (slab && slab.zones_input) {
          for (const [zone_name, zone_value] of Object.entries(slab.zones_input)) {
            await mySqlQury(
              `INSERT INTO tbl_exp_lp_zones_rates (lp_id, zone_name, zone_value, created_at, updated_at)
                   VALUES (?, ?, ?, NOW(), NOW())`,
              [lp_id, zone_name, zone_value]
            );
          }
        }
      }
    }

    // 5. Insert slab_additional into tbl_exp_lp_slab_add_charges
    if (zoneRateAndslabAdd && Array.isArray(zoneRateAndslabAdd.slabs)) {
      for (const slab of zoneRateAndslabAdd.slabs) {
        if (slab && Array.isArray(slab.slab_additional)) {
          for (const addObj of slab.slab_additional) {
            if (addObj && addObj.input) {
              for (const [zone_name, amount] of Object.entries(addObj.input)) {
                await mySqlQury(
                  `INSERT INTO tbl_exp_lp_slab_add_charges (lp_id, zone_name, amount, created_at, updated_at)
                       VALUES (?, ?, ?, NOW(), NOW())`,
                  [lp_id, zone_name, amount]
                );
              }
            }
          }
        }
      }
    }

    // Commit transaction if all is well
    await mySqlQury('COMMIT');
    res.json({ success: true, message: "Express onboarding saved!", id: lp_id });
  } catch (err) {
    console.error(err);

    // Rollback transaction on error
    await mySqlQury('ROLLBACK');

    // Send error message to UI if available, else generic
    let errorMessage = "Server error";
    if (err && err.message) {
      errorMessage = err.message;
    }
    res.status(500).json({ success: false, message: errorMessage });
  }
}
const apiOnboardingEcom = async (req, res) => {
  // Access data from req.body
  // Save to DB or process as needed
  res.json({ success: true, message: "Ecom onboarding saved!" });
}
const expressCreateOrder = async (req, res) => {
  try {
    const { data: payload, rate, cgst, sgst, igst, idPk, client_id, clientpaymentMode } = req.body;

    // Extract order number if present in payload
    const orderNumber = payload?.shipments?.[0]?.order || null;
    console.log("Order Number:", orderNumber);

    // Calculate total amount (rate + gst)
    const total_gst = Number(cgst || 0) + Number(sgst || 0) + Number(igst || 0);
    const total_rate = Number(rate.rate || 0);
    const total_amount_required = total_rate + total_gst;

    console.log("Total amount required:", total_amount_required);
    console.log("clientpaymentMode", clientpaymentMode);
    console.log("client_id", client_id);

    // Check wallet balance if payment mode is prepaid
    if (clientpaymentMode == 'prepaid') {
      try {
        const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [client_id]);
        console.log("wallet", wallet);
        
        if (wallet.length === 0) {
          return res.status(400).json({ 
            error: 'Wallet not found for the client. Please contact administrator.',
            errorType: 'wallet_error'
          });
        }

        const walletBalance = Number(wallet[0].total_amount);
        console.log("Wallet balance:", walletBalance, "Required amount:", total_amount_required);

        if (walletBalance < total_amount_required) {
          return res.status(400).json({ 
            error: `Insufficient wallet balance. Required: â‚¹${total_amount_required.toFixed(2)}, Available: â‚¹${walletBalance.toFixed(2)}`,
            errorType: 'insufficient_balance'
          });
        }

        console.log("âœ… Wallet balance check passed");
      } catch (walletError) {
        console.error("âŒ Error checking wallet balance:", walletError.message);
        return res.status(500).json({ 
          error: 'Failed to verify wallet balance', 
          details: walletError.message,
          errorType: 'wallet_error'
        });
      }
    }

    // Get ExpressBees token
    const token = await fetchExpressBeesToken();
    if (!token) {
      console.error("âŒ Failed to fetch ExpressBees token");
      return res.status(500).json({
        error: "Failed to authenticate with ExpressBees API",
        errorType: 'authentication_error',
        suggestion: "Please check ExpressBees API credentials or try again later"
      });
    }
    console.log("âœ… ExpressBees token obtained successfully");

    // Make API request to ExpressBees with automatic retry on 401
    try {
      const response = await axios.post('https://shipment.xpressbees.com/api/shipments2', payload, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        }
      });
      // const response = {
      //   data: {
      //     status: true,
      //     message: "Shipment created successfully",
      //     data: {
      //       awb_number: "AWB123456789",   // mock AWB number
      //       order_id: "ORDER123",
      //       courier: "XpressBees",
      //       service_type: "Standard"
      //     }
      //   }
      // };
      
      console.log("response in expressCreateOrder", response.data);
      
      const awb_number = response.data?.data?.awb_number || null;

      if (!awb_number) {
        return res.status(400).json({ 
          error: "AWB not generated by ExpressBees API",
          errorType: 'delivery_error',
          data: response.data 
        });
      }

      try {
        // Save LR details
        await storeLrDetailsNumbers(
          awb_number,
          cgst,
          sgst,
          igst,
          idPk,
          client_id,
          clientpaymentMode,
          idPk,
          { ...rate },
          'expressbees'
        );

        return res.status(200).json({
          success: true,
          message: `ExpressBees order created & LR saved with AWB: ${awb_number}`,
          awb_number,
          raw: response.data
        });

      } catch (err) {
        console.error("âŒ Error saving LR:", err.message);
        return res.status(500).json({
          error: "ExpressBees order created but failed to save LR details",
          details: err.message,
          errorType: 'system_error'
        });
      }
      
    } catch (apiError) {
      // If first attempt fails with 401 (token invalid), try with fresh token
      if (apiError.response?.status === 401) {
        console.log("ðŸ” First attempt failed with 401, getting fresh token and retrying...");
        
        // Get fresh token and update cache
        const freshToken = await fetchExpressBeesToken();
        
        if (freshToken) {
          try {
            // Second attempt with fresh token
            const retryResponse = await axios.post('https://shipment.xpressbees.com/api/shipments2', payload, {
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${freshToken}`
              }
            });
            
            console.log("retry response in expressCreateOrder", retryResponse.data);
            
            const awb_number = retryResponse.data?.data?.awb_number || null;

            if (!awb_number) {
              return res.status(400).json({ 
                error: "AWB not generated by ExpressBees API on retry",
                errorType: 'delivery_error',
                data: retryResponse.data 
              });
            }

            try {
              // Save LR details
              await storeLrDetailsNumbers(
                awb_number,
                cgst,
                sgst,
                igst,
                idPk,
                client_id,
                clientpaymentMode,
                idPk,
                { ...rate },
                'expressbees'
              );

              return res.status(200).json({
                success: true,
                message: `ExpressBees order created & LR saved with AWB: ${awb_number} (after token refresh)`,
                awb_number,
                raw: retryResponse.data
              });

            } catch (err) {
              console.error("âŒ Error saving LR:", err.message);
              return res.status(500).json({
                error: "ExpressBees order created but failed to save LR details",
                details: err.message,
                errorType: 'system_error'
              });
            }
            
          } catch (retryError) {
            console.error("âŒ Retry attempt also failed:", retryError.message);
            // Fall through to main error handler
            throw retryError;
          }
        } else {
          console.log("âŒ Failed to get fresh token for retry");
          // Fall through to main error handler
          throw new Error("Failed to get fresh token for retry");
        }
      } else {
        // For other errors, re-throw to be handled by main error handler
        throw apiError;
      }
    }

  } catch (error) {
    console.error("âŒ Error creating ExpressBees order:", error?.response?.data || error.message);
    console.log("error in expressCreateOrder", error);
    
    // Check if it's a business logic error from ExpressBees
    if (error?.response?.data?.status === false) {
      const businessError = error.response.data;
      
      // Handle specific business logic errors
      if (businessError.message === 'Order number already in use.') {
        return res.status(409).json({
          error: 'Order number already exists in ExpressBees system. Please use a different order number.',
          errorType: 'business_error',
          suggestion: 'Try generating a new unique order number or check if this order was already created.'
        });
      }
      
      // Handle other business logic errors
      return res.status(400).json({
        error: `ExpressBees business error: ${businessError.message}`,
        errorType: 'business_error',
        details: businessError
      });
    }
    
    // Categorized error handling for API errors
    if (error.response) {
      const responseData = error.response.data;
      let expressbeesErrorMessage = '';

      // Handle different ExpressBees error responses
      if (responseData?.message) {
        // ExpressBees specific error format
        expressbeesErrorMessage = responseData.message;
      } else if (responseData?.error) {
        expressbeesErrorMessage = responseData.error;
      } else if (responseData?.detail) {
        expressbeesErrorMessage = responseData.detail;
      } else {
        expressbeesErrorMessage = 'Unknown ExpressBees API error';
      }

      // Handle specific error codes
      if (error.response.status === 401) {
        expressbeesErrorMessage = 'ExpressBees authentication failed. Please check credentials.';
      } else if (error.response.status === 400) {
        expressbeesErrorMessage = `ExpressBees validation error: ${expressbeesErrorMessage}`;
      } else if (error.response.status === 403) {
        expressbeesErrorMessage = 'ExpressBees access denied. Please check permissions.';
      } else if (error.response.status === 404) {
        expressbeesErrorMessage = 'ExpressBees API endpoint not found.';
      } else if (error.response.status === 429) {
        expressbeesErrorMessage = 'ExpressBees API rate limit exceeded. Please try again later.';
      } else if (error.response.status >= 500) {
        expressbeesErrorMessage = 'ExpressBees server error. Please try again later.';
      }
      
      return res.status(error.response.status).json({ 
        error: `ExpressBees Error: ${expressbeesErrorMessage}`,
        errorType: 'delivery_error'
      });
    } else if (error.request) {
      return res.status(500).json({ 
        error: 'Unable to connect to ExpressBees API. Please check connection.',
        errorType: 'delivery_error'
      });
    } else {
      return res.status(500).json({ 
        error: `System error: ${error.message}`,
        errorType: 'system_error'
      });
    }
  }
}
const dtdcCreateOrder = async (req, res) => {
  try {
    const { data: payload, rate, cgst, sgst, igst, idPk, client_id, clientpaymentMode } = req.body;

    // Extract order number if present in payload
    const orderNumber = payload?.shipments?.[0]?.order || null;
    console.log("Order Number:", orderNumber);
   

    // Calculate total amount (rate + gst)
    const total_gst = Number(cgst || 0) + Number(sgst || 0) + Number(igst || 0);
    const total_rate = Number(rate.rate || 0);
    const total_amount_required = total_rate + total_gst;

    console.log("Total amount required:", total_amount_required);
    console.log("clientpaymentMode", clientpaymentMode);
    console.log("client_id", client_id);

    // Check wallet balance if payment mode is prepaid
    if (clientpaymentMode == 'prepaid') {
      try {
        const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [client_id]);
        console.log("wallet", wallet);
        
        if (wallet.length === 0) {
          return res.status(400).json({ 
            error: 'Wallet not found for the client. Please contact administrator.',
            errorType: 'wallet_error'
          });
        }

        const walletBalance = Number(wallet[0].total_amount);
        console.log("Wallet balance:", walletBalance, "Required amount:", total_amount_required);

        if (walletBalance < total_amount_required) {
          return res.status(400).json({ 
            error: `Insufficient wallet balance. Required: â‚¹${total_amount_required.toFixed(2)}, Available: â‚¹${walletBalance.toFixed(2)}`,
            errorType: 'insufficient_balance'
          });
        }

        console.log("âœ… Wallet balance check passed");
      } catch (walletError) {
        console.error("âŒ Error checking wallet balance:", walletError.message);
        return res.status(500).json({ 
          error: 'Failed to verify wallet balance', 
          details: walletError.message,
          errorType: 'wallet_error'
        });
      }
    }

    // Get DTDC API token from rate object
    const dtdcToken =process.env.API_KEYSTD;
    
    if (!dtdcToken) {
      return res.status(400).json({ 
        error: 'DTDC API token not configured',
        errorType: 'system_error'
      });
    }

    console.log("DTDC API Token:", dtdcToken ? "Present" : "Missing");
    console.log("payload in dtdcCreateOrder", payload);

    // Make API request to DTDC
    const response = await axios.post('https://dtdcapi.shipsy.io/api/customer/integration/consignment/softdata', payload, {
      headers: {
        'Content-Type': 'application/json',
        'api-key': dtdcToken,
      }
    });
    // console.log("")
//     const response = {
//   data: {
//     data: [
//       {
//         success: true,
//         message: "Order created successfully",
//         reason: null,
//         reference_number: Math.floor(1000000000 + Math.random() * 9000000000).toString()
//       }
//     ]
//   }
// };
    console.log("response in dtdcCreateOrder", response.data);
    console.log("rate in dtdcCreateOrder", rate);
    // console.log("sdjhdsjdghsjdf",dsjgdsjdgjs)

    // Check if the request was successful first
    if (!response.data?.data?.[0]?.success) {
      const errorMessage = response.data?.data?.[0]?.message || 'DTDC API request failed';
      const reason = response.data?.data?.[0]?.reason || 'UNKNOWN_ERROR';
      
      console.log("DTDC API Error:", { errorMessage, reason, fullResponse: response.data });
      
      return res.status(400).json({ 
        error: `DTDC API Error: ${errorMessage}`,
        errorType: 'delivery_error',
        reason: reason,
        data: response.data 
      });
    }

    // Extract reference number from DTDC API response structure
    const referenceNumber = response.data?.data?.[0]?.reference_number || null;



    try {
      // Save LR details
      await storeLrDetailsNumbers(
        referenceNumber,
        cgst,
        sgst,
        igst,
        idPk,
        client_id,
        clientpaymentMode,
        idPk,
        { ...rate },
        'dtdc'
      );

      return res.status(200).json({
        success: true,
        message: `DTDC order created & LR saved with Reference Number: ${referenceNumber}`,
        awb_number: referenceNumber, // Keep awb_number for frontend compatibility
        raw: response.data
      });

    } catch (err) {
      console.error("âŒ Error saving LR:", err.message);
      return res.status(500).json({
        error: "DTDC order created but failed to save LR details",
        details: err.message,
        errorType: 'system_error'
      });
    }

  } catch (error) {
    console.error("âŒ Error creating DTDC order:", error?.response?.data || error.message);
    
    // Simplified error handling for DTDC
    if (error.response) {
      const responseData = error.response.data;
      let errorMessage = 'DTDC API error occurred';
      
      // Extract error message from response
      if (responseData?.message) {
        errorMessage = responseData.message;
      } else if (responseData?.error) {
        errorMessage = responseData.error;
      }
      
      return res.status(error.response.status).json({ 
        error: `DTDC Error: ${errorMessage}`,
        errorType: 'delivery_error'
      });
    } else if (error.request) {
      return res.status(500).json({ 
        error: 'Unable to connect to DTDC API. Please check connection.',
        errorType: 'delivery_error'
      });
    } else {
      return res.status(500).json({ 
        error: `System error: ${error.message}`,
        errorType: 'system_error'
      });
    }
  }
}
const apiDelhiveryCreateOrder = async (req, res) => {
  try {
    const apiUrl = 'https://track.delhivery.com/api/cmu/create.json';
    const { data, rate, cgst, sgst, igst, idPk, client_id,clientpaymentMode,delhiveryApiVariant } = req.body;
   
    const{shipments} = data
    console.log("igst isuyusyur", shipments);
    const orderNumber = shipments[0]?.order;
    console.log("Order Number:", orderNumber);
    console.log("deliveryApivariant",delhiveryApiVariant)

    // Calculate total amount (rate + gst)
    const total_gst = Number(cgst || 0) + Number(sgst || 0) + Number(igst || 0);
    const total_rate = Number(rate.rate || 0);

    const total_amount_required = total_rate + total_gst;

    console.log("Total amount required:", total_amount_required);
    console.log("clientpaymentMode",clientpaymentMode)
    console.log("client_id",client_id)

    // Validate payment mode before making API call
    if (!clientpaymentMode || clientpaymentMode.trim() === '') {
      return res.status(400).json({
        error: 'Payment mode is required. Please specify payment mode (prepaid/COD).',
        errorType: 'validation_error',
        field: 'payment_mode'
      });
    }

    // Check wallet balance if payment mode is prepaid
    if (clientpaymentMode == 'prepaid') {
      try {
        const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [client_id]);
        console.log("wallet",wallet)
        
        if (wallet.length === 0) {
          return res.status(400).json({ 
            error: 'Wallet not found for the client. Please contact administrator.',
            errorType: 'wallet_error'
          });
        }
        

        const walletBalance = Number(wallet[0].total_amount);
        console.log("Wallet balance:", walletBalance, "Required amount:", total_amount_required);

        if (walletBalance < total_amount_required) {
          return res.status(400).json({ 
            error: `Insufficient wallet balance. Required: â‚¹${total_amount_required.toFixed(2)}, Available: â‚¹${walletBalance.toFixed(2)}`,
            errorType: 'insufficient_balance'
          });
        }

        console.log("âœ… Wallet balance check passed");
      } catch (walletError) {
        console.error("âŒ Error checking wallet balance:", walletError.message);
        return res.status(500).json({ 
          error: 'Failed to verify wallet balance', 
          details: walletError.message,
          errorType: 'wallet_error'
        });
      }
    }

let token = null;
if (delhiveryApiVariant == 2) {
  console.log("delhiveryApiVariant is 2")
  token = process.env.QUICKFLY;
} else {
  token = process.env.DELHIVERY_STD;
  console.log("in the else")
}
console.log("delivry variant", delhiveryApiVariant)
// console.log("dsjhfjfhd",dsgdhsdgsh)
    // const token = process.env.DELHIVERY_STD; // Uncomment this when you want to use the actual token

    // Log incoming request data
    console.log("data", data);
    console.log("request body data, rate, cgst, sgst, igst, idPk", rate, cgst, sgst, igst, idPk);

    // // Static response for testing
    // const staticResponse = {
    //   packages: [
    //     { waybill: 'WB123456789' },
    //     { waybill: 'WB987654321' }
    //   ]
    // };

    // Uncomment the following lines to make the actual API request
 
    const payload = {
        format: "json",
        data: JSON.stringify(data),
    };
  console.log("payload in the apiDelhiveryCreateOrder", payload);
    const response = await axios.post(apiUrl, payload, {
        headers: {
            Authorization: `Token ${token}`,
            'Content-Type': 'application/x-www-form-urlencoded',
        },
    });
    // const response = {
    //   data: {
    //     packages: [   // plural, and array
    //       {
    //         waybill: "WB123456789",   // example value
    //         status: "In Transit",     // extra fields if needed
    //         origin: "Delhi",
    //         destination: "Mumbai"
    //       }
    //     ]
    //   }
    // };
    console.log("response data", response.data.packages);
    
    // Check if the response contains errors
    if (response.data.packages && response.data.packages.length > 0) {
      const firstPackage = response.data.packages[0];
      
      // Check for API errors in the response
      if (firstPackage.status === 'Fail' || !firstPackage.waybill) {
        const errorMessage = firstPackage.remarks ? firstPackage.remarks.join(', ') : 'Unknown Delhivery API error';
        console.log("âŒ Delhivery API Error:", errorMessage);
        
        return res.status(400).json({
          error: `Delhivery API Error: ${errorMessage}`,
          errorType: 'delivery_api_error',
          details: firstPackage
        });
      }
    }

    // Use static response for testing
    const waybillNumbers = response.data.packages.map((pkg) => pkg.waybill);
    const realLrnumber = waybillNumbers[0];
    console.log("real waybill value", realLrnumber);
    console.log("Delhivery API Response:", waybillNumbers);

    // Check conditions for inserting into the database
    if (waybillNumbers.length > 0 && realLrnumber) {
      try {
        await storeLrDetailsNumbers(
          realLrnumber,            // lr number
          cgst,
          sgst,
          igst,
          idPk,
          client_id,clientpaymentMode,idPk,
          { ...rate },
          'delhivery'
        );

        // Respond with success message
        return res.json({
          message: `LR is saved with the generated LR: ${realLrnumber}`,
          data: response.data
        });

      } catch (err) {
        console.error("âŒ Error inside storeLrDetailsNumbers:", err.message);
        return res.status(500).json({
          error: 'Failed to save LR details',
          details: err.message
        });
      }

    } else {
      return res.status(400).json({ error: 'Invalid waybill numbers or real LR number is empty' });
    }

  } catch (error) {
    console.log("error", error);
    console.error("Error creating Delhivery order:", error.response?.data || error.message);
    
    // Enhanced error handling with better categorization
    if (error.response) {
      const responseData = error.response.data;
      
      // Check if it's a validation error (like empty payment mode)
      if (responseData?.packages && responseData.packages.length > 0) {
        const firstPackage = responseData.packages[0];
        if (firstPackage.status === 'Fail') {
          const errorMessage = firstPackage.remarks ? firstPackage.remarks.join(', ') : 'Validation failed';
          return res.status(400).json({
            error: `Delhivery Validation Error: ${errorMessage}`,
            errorType: 'delivery_validation_error',
            details: firstPackage
          });
        }
      }
      
      // Handle other API errors
      const deliveryErrorMessage = responseData?.detail || responseData?.error || responseData?.message || 'Unknown delivery API error';
      return res.status(error.response.status).json({ 
        error: `Delhivery API Error: ${deliveryErrorMessage}`,
        errorType: 'delivery_api_error',
        details: responseData
      });
    } else if (error.request) {
      return res.status(500).json({ 
        error: 'Unable to connect to Delhivery API. Please check connection.',
        errorType: 'delivery_connection_error'
      });
    } else {
      return res.status(500).json({ 
        error: `System error: ${error.message}`,
        errorType: 'system_error'
      });
    }
  }
}
const expressBeesCreateOrderEcom = async (req, res) => {
  try {
    const { data: payload, rate, cgst, sgst, igst, idPk, client_id, clientpaymentMode } = req.body;

    // Validate payment mode before making API call
    if (!clientpaymentMode || clientpaymentMode.trim() === '') {
      return res.status(400).json({
        error: 'Payment mode is required. Please specify payment mode (prepaid/COD).',
        errorType: 'validation_error',
        field: 'payment_mode'
      });
    }

    // Calculate total amount (rate + gst)
    const total_gst = Number(cgst || 0) + Number(sgst || 0) + Number(igst || 0);
    const total_rate = Number(rate?.rate || 0);
    const total_amount_required = total_rate + total_gst;

    // Check wallet balance if payment mode is prepaid
    if (clientpaymentMode === 'prepaid') {
      try {
        const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [client_id]);
        if (wallet.length === 0) {
          return res.status(400).json({
            error: 'Wallet not found for the client. Please contact administrator.',
            errorType: 'wallet_error'
          });
        }
        const walletBalance = Number(wallet[0].total_amount);
        if (walletBalance < total_amount_required) {
          return res.status(400).json({
            error: `Insufficient wallet balance. Required: â‚¹${total_amount_required.toFixed(2)}, Available: â‚¹${walletBalance.toFixed(2)}`,
            errorType: 'insufficient_balance'
          });
        }
      } catch (walletError) {
        console.error("âŒ Error checking wallet balance:", walletError.message);
        return res.status(500).json({
          error: 'Failed to verify wallet balance',
          details: walletError.message,
          errorType: 'wallet_error'
        });
      }
    }

    const token = await fetchExpressBeesToken();
    if (!token) {
      console.error("âŒ Failed to fetch ExpressBees token");
      return res.status(500).json({
        error: "Failed to authenticate with ExpressBees API",
        errorType: 'authentication_error',
        suggestion: "Please check ExpressBees API credentials or try again later"
      });
    }
    console.log("âœ… ExpressBees token obtained successfully");
    // console.log()
    // Make API request to ExpressBees with automatic retry on 401
    try {
      const response = await axios.post('https://shipment.xpressbees.com/api/shipments2', payload, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        }
      });
      //  const response = {
      //   data: {
      //     status: true,
      //     message: "Shipment created successfully",
      //     data: {
      //       awb_number: "AWB123456789",   // mock AWB number
      //       order_id: "ORDER123",
      //       courier: "XpressBees",
      //       service_type: "Standard"
      //     }
      //   }
      // };
      console.log("response", response);

      // Check if ExpressBees returned an error response
      if (response.data?.status === false) {
        const errorMessage = response.data?.message || 'ExpressBees validation failed';
        console.log("âŒ ExpressBees Validation Error:", errorMessage);
        
        return res.status(400).json({
          error: `ExpressBees Validation Error: ${errorMessage}`,
          errorType: 'delivery_validation_error',
          details: response.data
        });
      }

      const awb_number = response.data?.data?.awb_number || null;

      if (!awb_number) {
        return res.status(400).json({
          error: "AWB not generated by ExpressBees API",
          errorType: 'delivery_error',
          data: response.data
        });
      }

      // Extract order number if present in payload
      const orderNumber = payload?.shipments?.[0]?.order || null;

      try {
        // Save LR details
        await storeLrDetailsNumbersEcom(
          awb_number,
          cgst,
          sgst,
          igst,
          idPk,
          client_id,
          clientpaymentMode,
          idPk,  // Use idPk instead of orderNumber for order_id
          { ...rate }
        );

        return res.status(200).json({
          success: true,
          message: `ExpressBees order created & LR saved with AWB: ${awb_number}`,
          awb_number,
          raw: response.data
        });

      } catch (err) {
        console.error("âŒ Error saving LR:", err.message);
        return res.status(500).json({
          error: "ExpressBees order created but failed to save LR details",
          details: err.message,
          errorType: 'system_error'
        });
      }
      
    } catch (apiError) {
      // If first attempt fails with 401 (token invalid), try with fresh token
      if (apiError.response?.status === 401) {
        console.log("ðŸ” First attempt failed with 401, getting fresh token and retrying...");
        
        // Get fresh token and update cache
        const freshToken = await fetchExpressBeesToken();
        
        if (freshToken) {
          try {
            // Second attempt with fresh token
            const retryResponse = await axios.post('https://shipment.xpressbees.com/api/shipments2', payload, {
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${freshToken}`
              }
            });
            
            console.log("retry response", retryResponse.data);
            
            // Check if ExpressBees returned an error response on retry
            if (retryResponse.data?.status === false) {
              const errorMessage = retryResponse.data?.message || 'ExpressBees validation failed';
              console.log("âŒ ExpressBees Retry Validation Error:", errorMessage);
              
              return res.status(400).json({
                error: `ExpressBees Validation Error: ${errorMessage}`,
                errorType: 'delivery_validation_error',
                details: retryResponse.data
              });
            }

            const awb_number = retryResponse.data?.data?.awb_number || null;

            if (!awb_number) {
              return res.status(400).json({
                error: "AWB not generated by ExpressBees API on retry",
                errorType: 'delivery_error',
                data: retryResponse.data
              });
            }

            try {
              // Save LR details
              await storeLrDetailsNumbersEcom(
                awb_number,
                cgst,
                sgst,
                igst,
                idPk,
                client_id,
                clientpaymentMode,
                idPk,  // Use idPk instead of orderNumber for order_id
                { ...rate }
              );

              return res.status(200).json({
                success: true,
                message: `ExpressBees order created & LR saved with AWB: ${awb_number} (after token refresh)`,
                awb_number,
                raw: retryResponse.data
              });

            } catch (err) {
              console.error("âŒ Error saving LR:", err.message);
              return res.status(500).json({
                error: "ExpressBees order created but failed to save LR details",
                details: err.message,
                errorType: 'system_error'
              });
            }
            
          } catch (retryError) {
            console.error("âŒ Retry attempt also failed:", retryError.message);
            // Fall through to main error handler
            throw retryError;
          }
        } else {
          console.log("âŒ Failed to get fresh token for retry");
          // Fall through to main error handler
          throw new Error("Failed to get fresh token for retry");
        }
      } else {
        // For other errors, re-throw to be handled by main error handler
        throw apiError;
      }
    }

  } catch (error) {
    console.error("âŒ Error creating ExpressBees order:", error?.response?.data || error.message);

    if (error.response) {
      const responseData = error.response.data;
      let expressbeesErrorMessage = '';

      // Handle ExpressBees specific error formats
      if (responseData?.status === false && responseData?.message) {
        // This is the specific case we're seeing - status: false with validation messages
        expressbeesErrorMessage = responseData.message;
        return res.status(400).json({
          error: `ExpressBees Validation Error: ${expressbeesErrorMessage}`,
          errorType: 'delivery_validation_error',
          details: responseData
        });
      } else if (responseData?.message) {
        expressbeesErrorMessage = responseData.message;
      } else if (responseData?.error) {
        expressbeesErrorMessage = responseData.error;
      } else if (responseData?.detail) {
        expressbeesErrorMessage = responseData.detail;
      } else {
        expressbeesErrorMessage = 'Unknown ExpressBees API error';
      }

      if (error.response.status === 401) {
        expressbeesErrorMessage = 'ExpressBees authentication failed. Please check credentials.';
      } else if (error.response.status === 400) {
        expressbeesErrorMessage = `ExpressBees validation error: ${expressbeesErrorMessage}`;
      } else if (error.response.status === 403) {
        expressbeesErrorMessage = 'ExpressBees access denied. Please check permissions.';
      } else if (error.response.status === 404) {
        expressbeesErrorMessage = 'ExpressBees API endpoint not found.';
      } else if (error.response.status === 429) {
        expressbeesErrorMessage = 'ExpressBees API rate limit exceeded. Please try again later.';
      } else if (error.response.status >= 500) {
        expressbeesErrorMessage = 'ExpressBees server error. Please try again later.';
      }

      return res.status(error.response.status).json({
        error: `ExpressBees Error: ${expressbeesErrorMessage}`,
        errorType: 'delivery_error',
        details: responseData
      });
    } else if (error.request) {
      return res.status(500).json({
        error: 'Unable to connect to ExpressBees API. Please check connection.',
        errorType: 'delivery_error'
      });
    } else {
      return res.status(500).json({
        error: `System error: ${error.message}`,
        errorType: 'system_error'
      });
    }
  }
}
const delhiveryCreateOrderEcom = async (req, res) => {
  try {
    const apiUrl = 'https://track.delhivery.com/api/cmu/create.json';
    const { data, rate, cgst, sgst, igst, idPk, client_id, clientpaymentMode, delhiveryApiVariant } = req.body;

    const { shipments } = data;
    console.log("igst isuyusyur", shipments);
    const orderNumber = shipments[0]?.order;
    console.log("Order Number:", orderNumber);
    console.log("deliveryApivariant", delhiveryApiVariant);

    // Validate payment mode before making API call
    if (!clientpaymentMode || clientpaymentMode.trim() === '') {
      return res.status(400).json({
        error: 'Payment mode is required. Please specify payment mode (prepaid/COD).',
        errorType: 'validation_error',
        field: 'payment_mode'
      });
    }

    // Calculate total amount (rate + gst)
    const total_gst = Number(cgst || 0) + Number(sgst || 0) + Number(igst || 0);
    const total_rate = Number(rate?.rate || 0);
    const total_amount_required = total_rate + total_gst;

    // Check wallet balance if payment mode is prepaid
    if (clientpaymentMode === 'prepaid') {
      try {
        const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [client_id]);
        if (wallet.length === 0) {
          return res.status(400).json({
            error: 'Wallet not found for the client. Please contact administrator.',
            errorType: 'wallet_error'
          });
        }
        const walletBalance = Number(wallet[0].total_amount);
        if (walletBalance < total_amount_required) {
          return res.status(400).json({
            error: `Insufficient wallet balance. Required: â‚¹${total_amount_required.toFixed(2)}, Available: â‚¹${walletBalance.toFixed(2)}`,
            errorType: 'insufficient_balance'
          });
        }
      } catch (walletError) {
        console.error("âŒ Error checking wallet balance:", walletError.message);
        return res.status(500).json({
          error: 'Failed to verify wallet balance',
          details: walletError.message,
          errorType: 'wallet_error'
        });
      }
    }

    let token = null;
    if (delhiveryApiVariant == 2) {
      console.log("delhiveryApiVariant is 2")
      token = process.env.QUICKFLY;
    } else {
      token = process.env.DELHIVERY_STD;
      console.log("in the else")
    }
    console.log("delivry variant", delhiveryApiVariant)
    // const token = process.env.DELHIVERY_STD;

    // Uncomment below for real API call
    const payload = {
      format: "json",
      data: JSON.stringify(data),
    };
    const response = await axios.post(apiUrl, payload, {
      headers: {
        Authorization: `Token ${token}`,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
    });
    // const response = {
    //   data: {
    //     packages: [   // plural, and array
    //       {
    //         waybill: "WB123456789",   // example value
    //         status: "In Transit",     // extra fields if needed
    //         origin: "Delhi",
    //         destination: "Mumbai"
    //       }
    //     ]
    //   }
    // };
    const responseData = response.data;

    // Check if the response contains errors
    if (responseData.packages && responseData.packages.length > 0) {
      const firstPackage = responseData.packages[0];
      
      // Check for API errors in the response
      if (firstPackage.status === 'Fail' || !firstPackage.waybill) {
        const errorMessage = firstPackage.remarks ? firstPackage.remarks.join(', ') : 'Unknown Delhivery API error';
        console.log("âŒ Delhivery API Error:", errorMessage);
        
        return res.status(400).json({
          error: `Delhivery API Error: ${errorMessage}`,
          errorType: 'delivery_api_error',
          details: firstPackage
        });
      }
    }

    // For now, use static response for testing
    // const responseData = {
    //   packages: [
    //     { waybill: 'WB123456789' },
    //     { waybill: 'WB987654321' }
    //   ]
    // };

    const waybillNumbers = responseData.packages.map(pkg => pkg.waybill);
    const realLrnumber = waybillNumbers[0];
    console.log("real waybill value", realLrnumber);
    console.log("Delhivery API Response:", waybillNumbers);
    

    if (waybillNumbers.length > 0 && realLrnumber) {
      try {
        await storeLrDetailsNumbersEcom(
          realLrnumber,
          cgst,
          sgst,
          igst,
          idPk,
          client_id,
          clientpaymentMode,
          idPk,  // Use idPk instead of orderNumber for order_id
          { ...rate }
        );

        // Respond with success message and the same response as the original function
        return res.json({
          message: `LR is saved with the generated LR: ${realLrnumber}`,
          data: responseData
        });

      } catch (err) {
        console.error("âŒ Error inside storeLrDetailsNumbers:", err.message);
        return res.status(500).json({
          error: 'Failed to save LR details',
          details: err.message
        });
      }
    } else {
      return res.status(400).json({ error: 'Invalid waybill numbers or real LR number is empty' });
    }

  } catch (error) {
    console.error("Error creating Delhivery order:", error.response?.data || error.message);

    // Enhanced error handling with better categorization
    if (error.response) {
      const responseData = error.response.data;
      
      // Check if it's a validation error (like empty payment mode)
      if (responseData?.packages && responseData.packages.length > 0) {
        const firstPackage = responseData.packages[0];
        if (firstPackage.status === 'Fail') {
          const errorMessage = firstPackage.remarks ? firstPackage.remarks.join(', ') : 'Validation failed';
          return res.status(400).json({
            error: `Delhivery Validation Error: ${errorMessage}`,
            errorType: 'delivery_validation_error',
            details: firstPackage
          });
        }
      }
      
      // Handle other API errors
      const deliveryErrorMessage = responseData?.detail || responseData?.error || responseData?.message || 'Unknown delivery API error';
      return res.status(error.response.status).json({
        error: `Delhivery API Error: ${deliveryErrorMessage}`,
        errorType: 'delivery_api_error',
        details: responseData
      });
    } else if (error.request) {
      return res.status(500).json({
        error: 'Unable to connect to Delhivery API. Please check connection.',
        errorType: 'delivery_connection_error'
      });
    } else {
      return res.status(500).json({
        error: `System error: ${error.message}`,
        errorType: 'system_error'
      });
    }
  }
}
const eshopIntegration =  async (req, res, next) => {
  try {
    const accessdata = await access(req.user);
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId;
    const lang_data = req.language_data;
    const language_name = req.lang;
    let walletBalance = 0;
    let vasService = 0;
    console.log("req.user", req.user)

    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = ? ORDER BY id DESC LIMIT 3`,
      [role_data.id]
    );

    let loginDetails = null;
    let clientId = 0;

    // Get login details based on selectedClientId
    if (selectedClientId === 1) {
      // For admin (selectedClientId = 1), get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    } else {
      // For specific client, get details from tbl_admin using selectedClientId
      const clientDetails = await mySqlQury(
        'SELECT id, first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [selectedClientId]
      );
      if (clientDetails && clientDetails.length > 0) {
        loginDetails = clientDetails[0];
        clientId = selectedClientId;
      }
      
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [selectedClientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`, 
      [req.user.id]
    );

    // Fetch data from tbl_manuallrs with client name join
    const manualLrsData = await mySqlQury(`
      SELECT m.id, m.mlr_date, m.Client_id, m.aggrigator_id, m.agg_type, 
             m.Lr_Awb_no, m.lr_forwarder, m.product_type, m.status,
             c.company_name as client_name
      FROM tbl_manuallrs m
      LEFT JOIN tbl_admin c ON m.Client_id = c.id
    `);
    
    const clientsData = await mySqlQury(
      'SELECT id, company_name FROM tbl_admin'
    );
    
    const aggregatorsData = await mySqlQury(
      'SELECT id, Aggrigator_company_name FROM tbl_aggrigator'
    );

    // Map aggregators data to easily find Aggrigator_company_name by aggrigator_id
    const aggregators = aggregatorsData.reduce((acc, aggregator) => {
      acc[aggregator.id] = aggregator.Aggrigator_company_name;
      return acc;
    }, {});

    // Aggregate data by lr_forwarder, Client_id, and aggrigator_id
    const groupedData = manualLrsData.reduce((acc, entry) => {
      const aggregatorName = aggregators[entry.aggrigator_id] || 'Unknown Aggregator';
      const clientName = entry.client_name || 'Unknown Client';

      const key = `${entry.Client_id}-${entry.lr_forwarder}-${aggregatorName}`; 
      
      if (!acc[key]) {
        acc[key] = {
          Client_id: entry.Client_id,
          client_name: clientName,
          lr_forwarder: entry.lr_forwarder,
          aggrigator_company_name: aggregatorName,
          total: 0,
          nonConsumed: 0,
          consumed: 0,
          agg_type: entry.agg_type,
          product_type: entry.product_type,
        };
      }
      
      acc[key].total++;
      if (entry.status === 1) {
        acc[key].nonConsumed++;
      } else {
        acc[key].consumed++;
      }
      
      return acc;
    }, {});

    const groupedDataArray = Object.values(groupedData);

    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    let activeTopicIds = [];
    if (activeTopics && Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    res.render('pages/ecom/eshop-integration', { 
      title: 'Eshop integration',
      bodyClass: 'profile-page',
      activePage: 'profile',
      role_data,
      accessdata,
      layout: 'partials/layout-vertical',
      lang_data,
      language_name,
      notification_data,
      loginDetails,
      manualLrsData: groupedDataArray,
      clients: clientsData,
      activeTopicIds,
      profile,
      clientId,
      walletBalance,
      vasService,role
    });

  } catch (error) {
    console.error('Error in /master-docket:', error);
    next(error);
  }
}
// ... existing code ...
const eshopIntegrationDataSave = async (req, res) => {
  const { shopUrl, accessToken } = req.body;
  // const userId = req.user.id; // You should use the authenticated user's ID in production
  
  const userId = req.user.selectedClientId; // Using a hardcoded ID for now as per your snippet
  
  if (!shopUrl || !accessToken) {
    return res.status(400).json({ success: false, message: 'Shop URL and Access Token are required.' });
  }
  
  try {
    // Check if integration data for this user already exists
    const existingIntegration = await mySqlQury('SELECT * FROM tbl_shopify_integration WHERE clientId = ?', [userId]);
    
    if (existingIntegration.length > 0) {
      // Update existing record
      await mySqlQury('UPDATE tbl_shopify_integration SET shopyfy_url = ?, accessToken = ? WHERE clientId = ?', [shopUrl, accessToken, userId]);
    } else {
      // Insert new record
      await mySqlQury('INSERT INTO tbl_shopify_integration (clientId, shopyfy_url, accessToken) VALUES (?, ?, ?)', [userId, shopUrl, accessToken]);
    }
    
    res.status(200).json({ success: true, message: 'Shopify integration saved successfully.' });

  } catch (error) {
    console.error("Error saving e-shop integration data:", error);
    res.status(500).json({ success: false, message: 'An internal server error occurred. Please try again later.' });
  }
}
// ... existishopyfy_url

const apiAggrigatorId = async (req, res) => {
  const aggregatorId = req.params.id;
  // console.log("dskjdksds",dsjdsjdgsjd)
  
  try {
    // Start MySQL transaction
    await mySqlQury('START TRANSACTION');
    
    // First, get the aggregator details to determine the courier type
    const aggregatorDetails = await mySqlQury(`
      SELECT lp.id, lp.courier_id, cd.courier_type 
      FROM tbl_logistics_partner lp 
      LEFT JOIN tbl_courier_details cd ON lp.courier_id = cd.id 
      WHERE lp.id = ?
    `, [aggregatorId]);
    
    if (!aggregatorDetails || aggregatorDetails.length === 0) {
      await mySqlQury('ROLLBACK');
      return res.status(404).json({ success: false, message: 'Aggregator not found' });
    }
    
    const courierType = aggregatorDetails[0].courier_type?.toLowerCase();
    
    // Delete based on courier type
    if (courierType === 'express') {
      // Delete Express related data
      await mySqlQury('DELETE FROM tbl_exp_lp_additional_charges WHERE lp_id = ?', [aggregatorId]);
      await mySqlQury('DELETE FROM tbl_exp_lp_zones_rates WHERE lp_id = ?', [aggregatorId]);
      await mySqlQury('DELETE FROM tbl_exp_lp_slab_add_charges WHERE lp_id = ?', [aggregatorId]);
    } else if (courierType === 'ecom') {
      // Delete Ecom related data
      await mySqlQury('DELETE FROM tbl_ecom_lp_additional_charges WHERE lp_id = ?', [aggregatorId]);
      await mySqlQury('DELETE FROM tbl_ecom_lp_zones_rates WHERE lp_id = ?', [aggregatorId]);
      await mySqlQury('DELETE FROM tbl_ecom_lp_slab_add_charges WHERE lp_id = ?', [aggregatorId]);
    }
    
    // Delete from main logistics partner table
    await mySqlQury('DELETE FROM tbl_logistics_partner WHERE id = ?', [aggregatorId]);
    
    // Commit transaction
    await mySqlQury('COMMIT');
    
    res.json({ success: true, message: 'Aggregator deleted successfully' });
    
  } catch (error) {
    console.error('Error deleting aggregator:', error);
    await mySqlQury('ROLLBACK');
    res.status(500).json({ success: false, message: 'Failed to delete aggregator' });
  }
}
const getForwarders = async (req, res) => {
  const productType = req.query.productType;
  console.log("Product Type received:", productType); // Debugging

  try {
    const query = `
          SELECT id, company_name, Tagged_api, forwarder_type, service_type,productType
          FROM tbl_vendor_details
          WHERE productType = ?;
        `;

    const results = await mySqlQury(query, [productType]);
    console.log("Forwarders fetched:", results); // Debugging
    res.json({ success: true, data: results });
  } catch (error) {
    console.error('Error fetching forwarders:', error);
    res.status(500).json({ success: false, message: 'Failed to fetch forwarders.' });
  }
}
const adminViewId = async (req, res) => {
  const userId = req.params.id;

  try {
    // Query the database using mySqlQury
    const query = 'SELECT * FROM tbl_admin WHERE id = ?';
    const results = await mySqlQury(query, [userId]);

    // If no user is found, return a 404 error
    if (results.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Return the user data
    res.json(results[0]);

  } catch (error) {
    console.error('Database query error:', error);
    // Handle database error
    res.status(500).json({ error: 'Database query failed' });
  }
}

// const preDispatchClientSignIn = async (req, res) => {
//   await mySqlQury('START TRANSACTION');
//   try {
//     // const validationErrors = validateClientSignIn(req.body, req.files);
//     // if (validationErrors) {
//     //   return res.status(400).json({
//     //     status: 'error',
//     //     message: 'Validation failed',
//     //     errors: validationErrors
//     //   });
//     // }
//     const {
//       firstName,
//       lastName,
//       email,
//       mobileNo,
//       password,
//       isActive,
//       roleId,
//       userType
//     } = req.body;
//     let {selectedClientId, id:currentUserId} = req.user
//     // Check if email already exists
//     const emailExists = await mySqlQury(
//       'SELECT id FROM tbl_admin WHERE email = ?',
//       [email]
//     );
//     if (emailExists && emailExists.length > 0) {
//       return res.status(400).json({
//         status: 'error',
//         message: 'Validation failed',
//         errors: {
//           title: 'Client Sign In Validation Errors',
//           errors: [{
//             field: 'email',
//             message: 'This email is already registered in the system'
//           }]
//         }
//       });
//     }
//     // Handle the uploaded file path
//     let photoPath = null;
//     if (req.files && req.files.length > 0) {
//       // Get the filename from the uploaded file
//       const filename = req.files[0].filename; // Get the filename
//       photoPath = `assets/images/${filename}`; // Construct the relative path
//     } else {
//       console.log("No file uploaded.");
//     }

//     // Hash the password
//     const hash = await bcrypt.hash(password, 10);
// let level
//    let [selectedClientLevel] = await mySqlQury('select level from tbl_admin where id=? limit 1',[selectedClientId])
//     // Insert into tbl_admin with the new fields
//     if(userType=="user"){
//       level = 4
//     }
//     else if(userType=="client"){
//       level = selectedClientLevel.level-1
//     }
//     else{
//       throw new error('user type not defined')
//     }
//     let insertAdminSql = `
//       INSERT INTO tbl_admin (first_name, last_name, email, phone_no, password, is_active, logo_path, role_id, level, parent_id )
//       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
//     `;

//     // Set values for insertion
//     let adminValues = [
//       firstName,
//       lastName || null, // Set last_name to null if not provided
//       email,
//       mobileNo,
//       hash,
//       isActive ? 1 : 0,
//       photoPath, 
//       roleId, 
//       level,
//       selectedClientId
//     ];

//     // Execute the insert query for tbl_admin
//     const resultAdmin = await mySqlQury(insertAdminSql, adminValues);

//     // Commit the transaction
//     await mySqlQury('COMMIT');

//     return res.status(200).json({ message: 'Client onboarded successfully', resultAdmin });

//   } catch (error) {
//     // Rollback transaction in case of error
//     await mySqlQury('ROLLBACK');
//     console.error('Error onboarding client:', error);
//     res.status(500).json({ error: 'An error occurred during client onboarding' });
//   }
// }
const preDispatchClientSignIn = async (req, res) => {
  await mySqlQury('START TRANSACTION');
  try {
    const {
      firstName,
      lastName,
      email,
      mobileNo,
      password,
      isActive,
      roleId,
      userType
    } = req.body;

    let { selectedClientId, id: currentUserId } = req.user;

    // 1ï¸âƒ£ Check if email already exists
    const emailExists = await mySqlQury(
      'SELECT id FROM tbl_admin WHERE email = ?',
      [email]
    );
    if (emailExists && emailExists.length > 0) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        errors: {
          title: 'Client Sign In Validation Errors',
          errors: [{
            field: 'email',
            message: 'This email is already registered in the system'
          }]
        }
      });
    }

    // 2ï¸âƒ£ Handle uploaded file
    let photoPath = null;
    if (req.files && req.files.length > 0) {
      const filename = req.files[0].filename;
      photoPath = `assets/images/${filename}`;
    }

    // 3ï¸âƒ£ Hash password
    const hash = await bcrypt.hash(password, 10);

    // 4ï¸âƒ£ Determine user level
    // let level;
    // let [selectedClientLevel] = await mySqlQury(
    //   'SELECT level FROM tbl_admin WHERE id = ? LIMIT 1',
    //   [selectedClientId]
    // );

    // 5ï¸âƒ£ Insert into tbl_admin
    const insertAdminSql = `
      INSERT INTO tbl_admin 
        (first_name, last_name, email, phone_no, password, is_active, logo_path, role_id, level, parent_id,	is_verified,is_kyc_submitted,is_kyc_verified)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?,?)
    `;
    const adminValues = [
      firstName,
      lastName || null,
      email,
      mobileNo,
      hash,
      1 ,
      photoPath,
      roleId,
      4,
      selectedClientId,
      1,1,1
    ];

    const resultAdmin = await mySqlQury(insertAdminSql, adminValues);
    const newUserId = resultAdmin.insertId; // Newly created user ID

    // const insertRoleSql = `
    //   INSERT INTO roles (name, client_id)
    //   VALUES (?, ?)
    // `;
    // const roleValues = ['user', newUserId]; 
    // await mySqlQury(insertRoleSql, roleValues);

    // 7ï¸âƒ£ Commit transaction
    await mySqlQury('COMMIT');

    return res.status(200).json({ 
      message: 'User Added successfully', 
      userId: newUserId 
    });

  } catch (error) {
    await mySqlQury('ROLLBACK');
    console.error('Error onboarding client:', error);
    res.status(500).json({ error: 'An error occurred during client onboarding' });
  }
};

const clientManagement = async (req, res, next) => {
  try {
    const { user_type } = req.query;
    console.log("user_type", user_type);
    console.log("req body", req.user);

    // Fetch the company names based on user type
    const adminQuery = 'select company_name, id from tbl_admin where user_type = ?';
    const adminCompanyName = await mySqlQury(adminQuery, [user_type]);

    // Prepare the response structure
    let adminData = [];

    for (let i = 0; i < adminCompanyName.length; i++) {
      let companyName = adminCompanyName[i].company_name;

      // Fetch the first and last names of admins for the current company
      let adminQueryForCompany = 'select first_name, last_name from tbl_admin where company_name = ?';
      let admin_first_last_name = await mySqlQury(adminQueryForCompany, [companyName]);

      // Map the names into an array
      let adminNames = admin_first_last_name.map(
        (admin) => `${admin.first_name} ${admin.last_name}`
      );

      // Add the data to the result structure
      adminData.push({
        company_name: companyName,
        id: adminCompanyName[i].id,
        admin_names: adminNames
      });
    }

    // Send the grouped data as JSON
    res.json({
      adminData
    });
  } catch (error) {
    console.error('Error fetching data: ', error);
    next(error); // Pass the error to the next middleware
  }
}
const chooseUser = async (req, res, next) => {
  try {
    const { company_name } = req.query;  // Get company_name from request query

    // Ensure company_name is provided
    if (!company_name) {
      return res.status(400).json({
        message: 'Company name is required.'
      });
    }
    console.log("compnay name", company_name);

    // Query to fetch the user's first name, last name, id, and reporting_id based on the company_name
    const query = `
          SELECT first_name, last_name, id, reporting_id
          FROM tbl_admin
          WHERE reporting_id = ? OR id = ?`;

    // Execute the query
    const users = await mySqlQury(query, [company_name, company_name]);

    // Check if users are found
    if (users && users.length > 0) {
      return res.json(users);  // Return the list of users
    } else {
      return res.status(404).json({ message: 'No users found for the provided company name.' });
    }

  } catch (error) {
    console.error('Error fetching user details:', error);
    next(error); // Pass the error to the next middleware (for centralized error handling)
  }
}
const chooseClientCompClientId = async (req, res) => {
  try {
    const { clientId } = req.params;

    // Query to get login_id from tbl_admin based on id
    const clientQuery = `
              SELECT login_id, company_name 
              FROM tbl_admin 
              WHERE id = ?
          `;

    const clientResult = await mySqlQury(clientQuery, [clientId]);

    if (clientResult.length > 0) {
      res.status(200).json({
        success: true,
        data: {
          login_id: clientResult[0].login_id,
          company_name: clientResult[0].company_name
        }
      });
    } else {
      res.status(404).json({
        success: false,
        message: 'No client found with this ID'
      });
    }

  } catch (error) {
    console.error('Error fetching client details:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching client details',
      error: error.message
    });
  }
}
const adminEdit = async (req, res) => {
  const { id, first_name, last_name, email, password, reporting_user_id, role_id } = req.body;

  console.log("user data from edit", id, first_name, last_name, email, password, reporting_user_id, role_id);
  console.log("req.files", req.files);
  console.log("req.body", req.body);

  // Validate required fields
  if (!id) {
    return res.status(400).json({
      success: false,
      message: 'User ID is required.'
    });
  }



  try {
    // Fetch the reporting user's name
    const reportIds = 'SELECT first_name, last_name FROM tbl_admin WHERE id = ?';
    const reportingUser = await mySqlQury(reportIds, [id]);

    // Check if the reporting user exists
    if (!reportingUser || reportingUser.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Reporting user not found.'
      });
    }

    const adding_naming = `${reportingUser[0].first_name} ${reportingUser[0].last_name}`;

    // Role mapping
    const roleMapping = {
      1: 'Super Admin',
      2: 'Admin',
      3: 'Client',
      4: 'Operations',
      5: 'CRM',
      6: 'Support'
    };

    // Get role name based on role_id


    // Prepare the query for updating the user
    let query = 'UPDATE tbl_admin SET';
    const params = [];

    // Check for changes and only update if the new data is different from the existing data
    if (first_name) {
      query += ' first_name = ?,';
      params.push(first_name);
    }
    if (last_name) {
      query += ' last_name = ?,';
      params.push(last_name);
    }

    if (!isNaN(role_id) && role_id > 0) { // Only update if valid
      const role_name = roleMapping[role_id] || 'Unknown Role';
      query += ' role = ?, role_name = ?,';
      params.push(role_id, role_name);
    }

    if (email) {
      query += ' email = ?,';
      params.push(email);
    }
    if (password) {
      const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;

      // Check if the password matches the required format
      if (!passwordRegex.test(password)) {
        return res.status(400).json({ error: 'Password must be at least 8 characters long, contain one uppercase letter, one lowercase letter, one number, and one special character.' });
      }

      const hashedPassword = await bcrypt.hash(password, 10); // Hash the password
      query += ' password = ?,';
      params.push(hashedPassword);
    }

    // Handle photo upload
    if (req.files && req.files.length > 0) {
      const photoPath = `assets/images/${req.files[0].filename}`; // Construct the relative path
      query += ' logo_path = ?,';
      params.push(photoPath);
    }

    // Remove the last comma and add the WHERE clause
    query = query.slice(0, -1) + ' WHERE id = ?';
    params.push(id); // Add user ID to the parameters

    const results = await mySqlQury(query, params);

    // Check if any rows were affected
    if (results.affectedRows === 0) {
      return res.status(404).json({
        success: false,
        message: 'User not found or no changes made.'
      });
    }

    res.json({ success: true, message: 'User updated successfully' });
  } catch (error) {
    console.error('Error updating user:', error);
    return res.status(500).json({ success: false, error: 'Failed to update user' });
  }
}
const permissionManagement = async (req, res, next) => {
  try {
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;

    let loginDetails = null;
    let clientId = 0;
    let walletBalance = 0;
    let vasService = 0;


    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,company_name,vas,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    const allTopics = await mySqlQury(`
          SELECT t.topic_id, t.topic_name, t.category 
          FROM tbl_topics t 
          ORDER BY t.topic_id ASC
        `);

    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const roles = await mySqlQury(`
          SELECT role_id, role_name 
          FROM tbl_roles 
          WHERE role_id IN (1, 2, 3, 7, 4, 5, 6)
          ORDER BY FIELD(role_id, 1, 2, 3, 7, 4, 5, 6)
        `);

    const activePermissions = await mySqlQury(`
          SELECT topic_id, role_id, is_active 
          FROM tbl_permissions 
          WHERE role_id IN (1, 2, 3, 7, 4, 5, 6)
        `);

    const [profile] = await mySqlQury(
      'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
      [req.user.id]
    );

    let activeTopicIds = activeTopics?.map(topic => Number(topic.topic_id)) || [];

    const preDispatchTopics = allTopics.filter(topic => topic.category === 'pre_dispatch');
    const postDispatchTopics = allTopics.filter(topic => topic.category === 'post_dispatch');
    const onBoardingTopics = allTopics.filter(topic => topic.category === 'On Boarding');

    const mapTopicsWithPermissions = (topics) => topics.map(topic => ({
      id: topic.topic_id,
      name: topic.topic_name,
      roles: roles.reduce((acc, role) => {
        acc[role.role_id] = activePermissions.some(
          p => p.topic_id === topic.topic_id &&
            p.role_id === role.role_id &&
            p.is_active === 1
        );
        return acc;
      }, {})
    }));

    const preDispatchStatus = mapTopicsWithPermissions(preDispatchTopics);
    const postDispatchStatus = mapTopicsWithPermissions(postDispatchTopics);
    const onBoardingStatus = mapTopicsWithPermissions(onBoardingTopics);

    res.render('apps/permission-management', {
      title: 'Permission Manager',
      preDispatchStatus,
      postDispatchStatus,
      onBoardingStatus,
      roles,
      loginDetails: loginDetails || {}, // Provide empty object as fallback
      activeTopicIds,
      role_data,
      profile,
      clientId,
      walletBalance,
      vasService
    });

  } catch (err) {
    console.error('Error in permission management:', err);
    next(err);
  }
}
const orderDetailsOrderId = async (req, res) => {
  try {
    console.log("Fetching order details...");

    const { order_id } = req.params;

    if (!order_id) {
      return res.status(400).json({ message: 'Order ID is required.' });
    }

    // Query to fetch order details based on order_id
    const orderDetailsSql = `
          SELECT
            po.po_no,
            po.order_id,
            po.order_date,
            po.warehouse_address,
            po.consignee_address,
            po.total_boxes,
            po.payment_type,
            po.Amount,
            po.Invoice_amount,
            po.client_id,
            prod.product_name,
            prod.quantity,
            prod.order_value
          FROM
            tbl_unprocessed_order po
          LEFT JOIN
            tbl_products prod ON po.po_no = prod.po_no
          WHERE
            po.order_id = ?
        `;
    const orderDetailsResult = await mySqlQury(orderDetailsSql, [order_id]);

    if (!orderDetailsResult || orderDetailsResult.length === 0) {
      return res.status(404).json({ message: 'Order not found for the given Order ID.' });
    }

    const orderDetails = orderDetailsResult[0];
    const clientId = orderDetails.client_id;

    // Query to fetch client details
    const clientDetailsSql = `
          SELECT
            client.id,
            client.company_name,
            client.company_address,
            client.logo_path,
            client.gst
          FROM
            tbl_admin client
          WHERE
            client.id = ?
        `;
    const clientDetailsResult = await mySqlQury(clientDetailsSql, [clientId]);

    if (!clientDetailsResult || clientDetailsResult.length === 0) {
      return res.status(404).json({ message: 'Client details not found for the given Order ID.' });
    }

    const clientDetails = clientDetailsResult[0];

    const productDetails = orderDetailsResult.map(item => ({
      product_name: item.product_name,
      quantity: item.quantity,
      order_value: item.order_value,
    }));

    // Send the complete response
    return res.status(200).json({
      message: 'Order details fetched successfully',
      data: {
        orderDetails,
        clientDetails,
        productDetails,
      },
    });
  } catch (error) {
    console.error("Error fetching order details:", error);
    return res.status(500).json({ message: 'An error occurred while fetching order details', error: error.message });
  }
}
const permissionControl = async (req, res) => {
  const { topic_id, role_id } = req.body;

  // Log the incoming data for debugging
  console.log("Permissions Control - Topic ID:", topic_id, "Role ID:", role_id);

  // Validate input
  if (topic_id === undefined || role_id === undefined) {
    return res.status(400).json({ error: 'Topic ID and Role ID are required.' });
  }

  try {
    // Check if a record exists for the given topic_id and role_id
    const query = 'SELECT is_active FROM tbl_permissions WHERE topic_id = ? AND role_id = ?';
    const [result] = await mySqlQury(query, [topic_id, role_id]);
    console.log("shabbar in permission", result);

    if (result) {
      // Toggle the is_active field based on its current value
      const currentStatus = result.is_active; // Get the current is_active value
      const newStatus = currentStatus === 1 ? 0 : 1; // Toggle the status

      const updateQuery = 'UPDATE tbl_permissions SET is_active = ? WHERE topic_id = ? AND role_id = ?';
      await mySqlQury(updateQuery, [newStatus, topic_id, role_id]);

      // Respond with a success message
      res.json({ success: true, message: 'Permissions updated successfully.' });
    } else {
      // If no record exists, respond with an error message
      return res.status(404).json({ error: 'No permission record found for the specified topic and role.' });
    }
  } catch (error) {
    console.error('Error updating permissions:', error);
    return res.status(500).json({ error: 'Failed to update permissions' });
  }
}
const apiGetReportingUsersClientId = async (req, res) => {
  const clientId = req.params.clientId;

  try {
    const users = await mySqlQury('SELECT * FROM tbl_admin WHERE client_id = ?', [clientId]);
    res.json(users);
  } catch (error) {
    console.error('Error fetching reporting users:', error);
    res.status(500).json({ error: 'An error occurred while fetching users' });
  }
}
const apigetForwarderOptions = async (req, res) => {
  const { mode } = req.body;
  console.log("Selected mode: ", mode);

  try {
    let query = '';

    if (mode === 'Aggrigator') {
      query = `
                  SELECT id, Tagged_api, aggrigator_type AS category, service_type, logo_path, 
                         Aggrigator_company_name AS company_name,
                         'Aggrigator' AS type 
                  FROM tbl_aggrigator
                  WHERE status = 1
              `;
    } else if (mode === 'Forwarder') {
      query = `
                  SELECT id, Tagged_api, forwarder_type AS category, service_type, logo_path,       
                         company_name,
                         'Forwarder' AS type 
                  FROM tbl_vendor_details
              `;
    } else if (mode === 'both') {
      query = `
                  SELECT id, Tagged_api, aggrigator_type AS category, service_type, logo_path, 
                         Aggrigator_company_name AS company_name, 
                         'Aggrigator' AS type 
                  FROM tbl_aggrigator 
                  WHERE status = 1
                  UNION 
                  SELECT id, Tagged_api, forwarder_type AS category, service_type, logo_path,
                         company_name, 
                         'Forwarder' AS type 
                  FROM tbl_vendor_details
              `;
    } else {
      return res.status(400).json({ message: 'Invalid mode selected' });
    }

    // Execute the query
    const results = await mySqlQury(query);
    console.log("results in union", results);

    // Format response
    const options = results.map(row => ({
      logoPath: row.logo_path,
      category: row.category,
      companyName: row.company_name,
      serviceType: row.service_type,
      taggedApi: row.tagged_api,
      value: row.id,
      label: row.company_name,
      type: row.type || null // Include type only for 'both' mode
    }));
    console.log("options in the ", options);
    res.json(options);

  } catch (error) {
    console.error("Error fetching options: ", error);
    res.status(500).json({ message: 'Server error. Please try again later.' });
  }
}
const mannualLrVault = async (req, res, next) => {
  try {
    // Fetch login details for the logged-in user from the database
    const [loginDetails] = await mySqlQury(
      'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
      [req.user.id]
    );

    // If login details are not found, return an error or handle appropriately
    if (!loginDetails) {
      return res.status(404).send('User not found');
    }

    // Render the view and pass the login details
    res.render('apps/mannual-lr-vault', {
      title: 'Mannual Lr Vault',
      loginDetails: loginDetails // Pass loginDetails to the view
    });

  } catch (error) {
    // Handle any error that occurs
    console.error(error);
    next(error);
  }
}
const trackingMaster = async (req, res, next) => {
  try {
    const accessdata = await access(req.user);
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    const lang_data = req.language_data;
    const language_name = req.lang;
    let walletBalance = 0;
    let vasService = 0;

    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = ? ORDER BY id DESC LIMIT 3`,
      [role_data.id]
    );

    let loginDetails = null;
    let clientId = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,company_name,vas,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    let activeTopicIds = [];
    if (activeTopics && Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    res.render('pages/tracking-master', {
      role_data,
      accessdata,
      bodyClass: 'profile-page',
      activePage: 'profile',
      title: 'Tracking Master',
      layout: 'partials/layout-vertical',
      lang_data,
      language_name,
      notification_data,
      activeTopicIds,
      loginDetails: loginDetails || {},
      profile,
      clientId,
      walletBalance,
      vasService, role
    });

  } catch (error) {
    console.error(error);
    next(error);
  }
}
const helpdeskTickets = async (req, res, next) => {
  try {
    const [loginDetails] = await mySqlQury(
      'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
      [req.user.id]
    );

    if (!loginDetails) {
      return res.status(404).send('User not found');
    }

    let activeTopicIds = []; // Modify or populate based on your application logic
    res.render('apps/helpdesk-tickets', { title: 'Metrica', activeTopicIds, loginDetails });
  } catch (error) {
    console.error(error);
    next(error);
  }
}
const newClient = async (req, res) => {
  console.log("Uploaded files:", req.files);
  console.log("req.body is", req.body);


  // Start the MySQL transaction
  await mySqlQury('START TRANSACTION');
  try {
    const validationErrors = validateClientOnboarding(
      req.body.form1,
      req.body.form2,
      req.files,
      req.body.client_password,
      req.body.selectedForwarders,
    );

    if (validationErrors) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        errors: validationErrors
      });
    }

    // Check if email already exists
    const emailExists = await mySqlQury(
      'SELECT id FROM tbl_admin WHERE email = ?',
      [req.body.form1.client_Email]
    );

    if (emailExists && emailExists.length > 0) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        errors: {
          title: 'Client Sign In Validation Errors',
          errors: [{
            field: 'email',
            message: 'This email is already registered in the system'
          }]
        }
      });
    }

    let logoPath = null;

    // Handle the uploaded file
    if (req.files && req.files.length > 0) {
      logoPath = req.files[0].path.replace(/\\/g, '/');
      logoPath = logoPath.replace(/^.*[\\/]public[\\/]/, '');
      console.log("Logo path:", logoPath);
    } else {
      console.log("No file uploaded.");
    }

    // Destructure data from the request payload
    const { form1, client_password, form2: rawForm2, selectedForwarders } = req.body;
    const form2 = Object.assign({}, rawForm2);
    console.log("Form1 data:", form1);
    console.log("Form1 data:", selectedForwarders);
    console.log("form 2", form2)

    const hash = await bcrypt.hash(client_password, 10);

    // Insert admin data into `tbl_admin`
    const insertAdminSql = `
          INSERT INTO tbl_admin (
            first_name,
            last_name,
            email,
            country_code,
            phone_no,
            password,
            role,
            company_name,
            logo_path,
            client_id
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `;
    const adminValues = [
      form1.clientName || '',
      form1.last_name || '',
      form1.client_Email || '',
      form1.country_code || '',
      form1.client_mobile || '',
      hash || '',
      2, // Example role
      form1.companyName || '',
      logoPath,
      null // Initially set client_id as null
    ];
    const resultAdmin = await mySqlQury(insertAdminSql, adminValues);
    console.log("Admin inserted successfully, ID:", resultAdmin.insertId);

    // Update the client_id in tbl_admin with its own ID
    const updateAdminSql = `
          UPDATE tbl_admin 
          SET client_id = ? 
          WHERE id = ?
        `;
    await mySqlQury(updateAdminSql, [resultAdmin.insertId, resultAdmin.insertId]);

    // Insert client data into `tbl_admin`
    const insertClientSql = `
          INSERT INTO tbl_admin (
            login_id,
            mode_of_operations,
            first_name,
            last_name,
            email,
            country_code,
            mobile,
            company_country,
            company_state,
            company_city,
            company_address,
            company_name,
            website,
            from_date,
            from_to,
            fod,
            account_name,
            account_number,
            billing_cycle,
            choose_bank,
            logo_path,
            gst,payment_system,vas
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)
        `;

    const clientValues = [
      resultAdmin.insertId,
      form1.ops_mode || '',
      form1.clientName || '',
      form1.last_name || '',
      form1.client_Email || '',
      form1.country_code || '',
      form1.client_mobile || '',
      form1.companyCountry || '',
      form1.companyState || '',
      form1.companyDistrict || '',
      form1.companyAddress || '',
      form1.companyName || '',
      form1.website || '',
      form1.fromDate || null,
      form1.fromTo || '',
      form1.fod || null,
      form1.Bank_account_name || '',
      form1.accountNumber || '',
      form1.billingCycle || '',
      form1.chooseBank || '',
      logoPath,
      form1.gstNo || null,
      form1.paymentSystem || null,
      form1.vasOption || 0,
    ];

    console.log("Client Values Array:", clientValues);
    const resultClient = await mySqlQury(insertClientSql, clientValues);
    console.log("Client inserted successfully, ID:", resultClient.insertId);

    // Now insert contact data into `tbl_admin_contacts`
    if (form1.list_forwarder && Array.isArray(form1.list_forwarder)) {
      const aggrigatorValues = [];
      const forwarderValues = [];

      for (const forwarder of form1.list_forwarder) {
        const parts = forwarder.split('/');

        const ID = parts[0] || '';
        const type = parts[2] || '';

        if (type === 'Aggrigator' && ID) {
          const queryAggrigatorSql = `
                SELECT first_name, Tagged_api, aggrigator_type, service_type, logo_path 
                FROM tbl_aggrigator 
                WHERE id = ?
              `;
          const [aggrigatorDetails] = await mySqlQury(queryAggrigatorSql, [ID]);

          if (aggrigatorDetails) {
            const updateStatusSql = `
                  UPDATE tbl_aggrigator 
                  SET agg_assigned_status = 'A' 
                  WHERE id = ?
                `;
            await mySqlQury(updateStatusSql, [ID]);
            const value = [
              resultClient.insertId,
              ID,
              aggrigatorDetails.first_name,
              aggrigatorDetails.Tagged_api,
              aggrigatorDetails.aggrigator_type,
              aggrigatorDetails.service_type,
              aggrigatorDetails.logo_path
            ];
            aggrigatorValues.push(value);
          } else {
            console.error(`Aggrigator details not found for ID: ${ID}`);
          }
        } else if (type === 'Forwarder' && ID) {
          const queryForwarderSql = `
                SELECT name, tagged_api, category, service_type, tagged_logo 
                FROM tbl_vendor_details 
                WHERE Forwarder_id = ?
              `;
          const [forwarderDetails] = await mySqlQury(queryForwarderSql, [ID]);

          if (forwarderDetails) {
            const value = [
              resultClient.insertId,
              ID,
              forwarderDetails.name,
              forwarderDetails.tagged_api,
              forwarderDetails.category,
              forwarderDetails.service_type,
              forwarderDetails.tagged_logo
            ];
            forwarderValues.push(value);
          } else {
            console.error(`Forwarder details not found for ID: ${ID}`);
          }
        }
      }

      if (aggrigatorValues.length > 0) {
        const insertAggrigatorSql = `
              INSERT INTO tbl_client_aggrigator 
              (client_id, Aggrigator_id, name, tagged_api, category, service_type, tagged_logo)
              VALUES ?
            `;
        await mySqlQury(insertAggrigatorSql, [aggrigatorValues]);
        console.log("Aggrigator client entries inserted successfully.");
      }

      if (forwarderValues.length > 0) {
        const insertForwarderSql = `
              INSERT INTO tbl_client_Forwarder 
              (client_id, Forwarder_id, name, tagged_api, category, service_type, tagged_logo)
              VALUES ?
            `;
        await mySqlQury(insertForwarderSql, [forwarderValues]);
        console.log("Forwarder client entries inserted successfully.");
      }
    }

    const contactTypes = ['sales', 'ops', 'accounts', 'rvp'];
    const contactValuesArray = contactTypes.map(type => [
      resultClient.insertId,
      form2[`${type}_name`] || null,
      form2[`${type}_phone`] || null,
      form2[`${type}_email`] || null,
      form2[`${type}_designation`] || null,
      type
    ]);

    const bulkInsertContactSql = `
          INSERT INTO tbl_admin_contacts (client_new_id, name, phone, email, designation, department)
          VALUES ?
        `;

    await mySqlQury(bulkInsertContactSql, [contactValuesArray]);

    // Commit the transaction
    await mySqlQury('COMMIT');
    res.status(200).json({ success: true, message: 'Client created successfully.' });
  } catch (error) {
    console.error("Error during client creation:", error);
    await mySqlQury('ROLLBACK');
    res.status(500).json({ success: false, message: 'An error occurred while creating the client.', error: error.message });
  }
}
const apiClientGstNumber = async (req, res) => {
  try {
    const { clientId } = req.query;

    if (!clientId) {
      return res.status(400).json({ error: 'Client ID is required' });
    }

    // Fetch GST and payment system from tbl_admin
    const clientDetails = await mySqlQury(
      'SELECT gst, payment_mode FROM tbl_admin WHERE id = ?',
      [clientId]
    );

    if (clientDetails && clientDetails.length > 0) {
      const { gst, payment_mode } = clientDetails[0];
      res.status(200).json({
        gst: gst || null,
        payment_system: payment_mode || null
      });
    } else {
      // If no data found, return null values
      res.status(200).json({
        gst: null,
        payment_system: null
      });
    }
  } catch (error) {
    console.error('Error fetching client GST and payment system:', error);
    res.status(500).json({
      error: 'Failed to fetch client details',
      message: error.message
    });
  }
}
const predispatchEditId = (req, res, next) => {
  const vendorId = req.params.id; // Capture the vendor ID from the URL
  console.log("id is this ", vendorId)
  // Use vendorId to fetch vendor details or perform other actions
  res.render('apps/edit_forwarder', { title: 'Client Onboarding', layout: 'partials/layout-vertical', vendorId });
}
const apiCourierId = async (req, res) => {
  try {
    const forwarderId = req.params.id;



    // Fetch forwarder details using your existing query format
    const forwarderDetails = await mySqlQury(
      `SELECT * FROM  tbl_courier_details WHERE id = ?`,
      [forwarderId]
    );

    if (forwarderDetails && forwarderDetails.length > 0) {
      res.json(forwarderDetails[0]);
    } else {
      res.status(404).json({ error: 'Forwarder not found' });
    }
  } catch (error) {
    console.error('Error fetching forwarder:', error);
    res.status(500).json({ error: 'Failed to fetch forwarder data' });
  }
}
const getapiAggrigatorId = async (req, res) => {
  try {
    const aggrigatorId = req.params.id;

    // Fetch aggregator details
    const aggregatorResults = await mySqlQury(
      'SELECT * FROM tbl_aggrigator WHERE id = ?',
      [aggrigatorId]
    );

    if (!aggregatorResults || aggregatorResults.length === 0) {
      return res.status(404).json({ error: 'Aggregator not found' });
    }

    // Fetch customer details
    const customerResults = await mySqlQury(
      'SELECT * FROM tbl_customers WHERE Aggrigator_id = ?',
      [aggrigatorId]
    );

    // Format response
    const response = {
      aggregator: {
        ...aggregatorResults[0]
      },
      customers: customerResults
    };

    res.json(response);

  } catch (error) {
    console.error('Error fetching aggregator and customer data:', error);
    res.status(500).json({ error: 'Failed to fetch data' });
  }
}
const putapiCourierId = async (req, res) => {
  try {
    const courierId = req.params.id;
    const updateData = req.body;
    let logoPath = null;

    // Handle file upload if present
    if (req.files && req.files.length > 0) {
      logoPath = req.files[0].path.replace(/\\/g, '/');
      logoPath = logoPath.replace(/^.*[\\/]public[\\/]/, '');
    }
    console.log("logoPath", logoPath)
    console.log("updateData", updateData)
    console.log("req.files", req.files)

    // Map form fields to new database columns for tbl_courier_details
    const fieldMappings = {
      companyName: 'company_name',
      courierName: 'courier_name', // changed from forwarderName
      website: 'website',
      companyAddress: 'company_address',
      companyCountry: 'company_country',
      companyState: 'company_state',
      companyDistrict: 'company_district',
      forwarder_Email: 'email_id',
      forwarder_mobile: 'phone',
      fromDate: 'from_date',
      fromTo: 'from_to',
      company_pan: 'company_pan_code',
      vat: 'company_vat',
      gstNo: 'gst_no',
      company_uin: 'company_uin',
      Bank_account_name: 'company_bank_account',
      accountNumber: 'account_number',
      ifscCode: 'ifsc_code',
      billingCycle: 'billing_cycle',
      chooseBank: 'choose_bank',
      courierType: 'courier_type', // changed from forwarderType
      serviceType: 'service_type',
      creditTerms: 'credit_terms',
      volumetric_: 'volumetric_factor',
      shipmentType: 'shipment_type',
      chooseAPi: 'Tagged_api',
      ProductType: 'productType',
      businessVolume: 'business_volume',
      minimum_chargable_weight: 'minimum_chargable_weight', // new column
      company_cst: 'company_cst' // new column
    };

    // Build the update query dynamically
    const updateFields = [];
    const queryParams = [];

    for (const [formField, dbColumn] of Object.entries(fieldMappings)) {
      if (updateData[formField] !== undefined) {
        updateFields.push(`${dbColumn} = ?`);
        queryParams.push(updateData[formField]);
      }
    }

    // Add logo path to update if file was uploaded
    if (logoPath) {
      updateFields.push('logo_path = ?');
      queryParams.push(logoPath);
    }

    // Add ID to query params
    queryParams.push(courierId);

    // Execute update query if there are fields to update
    if (updateFields.length > 0) {
      const updateQuery = `
            UPDATE tbl_courier_details
            SET ${updateFields.join(', ')}
            WHERE id = ?
          `;

      await mySqlQury(updateQuery, queryParams);

      res.json({
        success: true,
        message: 'Courier details updated successfully',
        logoPath: logoPath // Return the new logo path if updated
      });
    } else {
      res.status(400).json({
        error: 'No fields to update'
      });
    }

  } catch (error) {
    console.error('Error updating courier details:', error);
    res.status(500).json({
      error: 'Failed to update courier details',
      details: error.message
    });
  }
}
const putapiAggrigatorId = async (req, res) => {
  try {
    const aggrigatorId = req.params.id;
    const updateData = req.body;
    let logoPath = null;

    // Handle file upload if present
    if (req.files?.length > 0) {
      logoPath = req.files[0].path.replace(/\\/g, '/').replace(/^.*[\\/]public[\\/]/, '');
    }

    // Map form fields to database columns
    const aggFieldMappings = {
      contact_person: 'first_name',
      Aggrigator_last_name: 'last_name',
      Aggrigator_Email: 'email',
      companyCountry: 'country_code',
      Aggrigator_mobile: 'phone_no',
      companyName: 'Aggrigator_company_name',
      serviceType: 'service_type',
      aggrigatorType: 'aggrigator_type',
      chooseAPi: 'Tagged_api'
    };

    const customerFieldMappings = {
      contact_person: 'first_name',
      contact_person_last_name: 'last_name',
      Aggrigator_Email: 'email',
      companyCountry: 'company_country',
      companyState: 'company_state',
      companyDistrict: 'company_city',
      Aggrigator_mobile: 'mobile',
      companyName: 'company_name',
      website: 'website',
      companyAddress: 'company_address',
      ProductType: 'client_type',
      serviceType: 'service_type',
      fromDate: 'from_date',
      fromTo: 'from_to',
      accountNumber: 'account_number',
      billingCycle: 'billing_cycle',
      chooseBank: 'choose_bank',
      creditTerms: 'credit_terms'
    };

    // Build update queries
    const buildUpdateQuery = (tableName, mappings) => {
      const fields = [];
      const params = [];

      for (const [formField, dbColumn] of Object.entries(mappings)) {
        if (updateData[formField] !== undefined) {
          fields.push(`${dbColumn} = ?`);
          params.push(updateData[formField]);
        }
      }

      if (tableName === 'tbl_aggrigator' && logoPath) {
        fields.push('logo_path = ?');
        params.push(logoPath);
      }

      params.push(aggrigatorId);

      return {
        query: fields.length ? `UPDATE ${tableName} SET ${fields.join(', ')} WHERE ${tableName === 'tbl_customers' ? 'Aggrigator_id' : 'id'} = ?` : null,
        params
      };
    };

    const aggUpdate = buildUpdateQuery('tbl_aggrigator', aggFieldMappings);
    const customerUpdate = buildUpdateQuery('tbl_customers', customerFieldMappings);

    // Execute updates if there are changes
    if (!aggUpdate.query && !customerUpdate.query) {
      return res.status(400).json({ error: 'No fields to update' });
    }

    await mySqlQury('START TRANSACTION');

    if (aggUpdate.query) {
      await mySqlQury(aggUpdate.query, aggUpdate.params);
    }

    if (customerUpdate.query) {
      await mySqlQury(customerUpdate.query, customerUpdate.params);
    }

    await mySqlQury('COMMIT');

    res.json({
      success: true,
      message: 'Aggrigator updated successfully',
      logoPath
    });

  } catch (error) {
    await mySqlQury('ROLLBACK');
    console.error('Error updating aggrigator:', error);
    res.status(500).json({
      error: 'Failed to update aggrigator',
      details: error.message
    });
  }
}
const forwarderContactsId = async (req, res) => {
  try {
    const forwarderId = req.params.id;


    // Fetch contact details
    const forwarderContacts = await mySqlQury(
      `SELECT * FROM tbl_vendor_contacts WHERE vendor_id = ?`,
      [forwarderId]
    );
    console.log("forwarderContacts", forwarderContacts)

    res.json(forwarderContacts);
  } catch (error) {
    console.error('Error fetching contacts:', error);
    res.status(500).json({ error: 'Failed to fetch contact data' });
  }
}
const putapiforContactsId = async (req, res) => {
  try {
    const forwarderId = req.params.id;
    const { contacts } = req.body;
    console.log("contacts", contacts)
    console.log("forwarderId", forwarderId)


    // Begin transaction
    await mySqlQury('START TRANSACTION');

    try {
      // First delete all existing contacts for this vendor
      await mySqlQury(
        'DELETE FROM tbl_vendor_contacts WHERE vendor_id = ?',
        [forwarderId]
      );

      // Then insert all new contacts
      for (const contact of contacts) {
        await mySqlQury(
          `INSERT INTO tbl_vendor_contacts (
                        vendor_id, name, phone, email, designation, department
                    ) VALUES (?, ?, ?, ?, ?, ?)`,
          [
            forwarderId,
            contact.name,
            contact.phone,
            contact.email,
            contact.designation,
            contact.department
          ]
        );
      }

      // Commit transaction
      await mySqlQury('COMMIT');

      res.json({
        success: true,
        message: 'Contact information updated successfully'
      });

    } catch (error) {
      // Rollback on error
      await mySqlQury('ROLLBACK');
      throw error;
    }

  } catch (error) {
    console.error('Error updating contacts:', error);
    res.status(500).json({
      error: 'Failed to update contact data',
      details: error.message
    });
  }
}
const apiforChargesId = async (req, res) => {
  try {
    const vendorId = req.params.id;
    const charges = await mySqlQury(
      'SELECT * FROM tbl_additional_charges WHERE vendor_id = ?',
      [vendorId]
    );
    res.json(charges);
  } catch (error) {
    console.error('Error fetching charges:', error);
    res.status(500).json({ error: 'Failed to fetch charges data' });
  }
}
const apiExpressAddchargeId = async (req, res) => {
  try {
    const vendorId = req.params.id;
    const charges = await mySqlQury(
      'SELECT * FROM tbl_courier_exp_additional_charges WHERE courier_id = ?',
      [vendorId]
    );
    res.json(charges);
  } catch (error) {
    console.error('Error fetching charges:', error);
    res.status(500).json({ error: 'Failed to fetch charges data' });
  }
}
const apiCourierChargeId = async (req, res) => {
  try {
    const vendorId = req.params.id;
    const { charges } = req.body;
    console.log("charges", charges)
    // console.log("vendorId", agdsdgsd)

    // Validate input
    if (!charges || !Array.isArray(charges) || charges.length === 0) {
      return res.status(400).json({ error: 'Invalid charges data' });
    }

    // Start transaction
    await mySqlQury('START TRANSACTION');

    try {
      // Delete existing charges
      await mySqlQury('DELETE FROM  tbl_courier_exp_additional_charges WHERE courier_id = ?', [vendorId]);

      // Insert new charges
      for (const charge of charges) {
        if (!charge.calculation_based_on_min || charge.calculation_based_on_min === '0') {
          console.log(`Skipping charge ${charge.charge_name} due to missing or zero calculation_based_on_min value`);
          continue;
        }
        // Validate required fields
        if (!charge.charge_name) {
          throw new Error('Charge name is required');
        }

        await mySqlQury(`
                    INSERT INTO  tbl_courier_exp_additional_charges 
                    (courier_id, charge_name, calculation_based_on_min, calculation_based_on_max, 
                    min_value, max_value, condition_based, chargable_value_type)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                `, [
          vendorId,
          charge.charge_name,
          charge.calculation_based_on_min === "null" || charge.calculation_based_on_min === "" ? null : charge.calculation_based_on_min,
          charge.calculation_based_on_max === "null" || charge.calculation_based_on_max === "" ? null : charge.calculation_based_on_max,
          charge.min_value === "null" || charge.min_value === "" ? null : charge.min_value,
          charge.max_value === "null" || charge.max_value === "" ? null : charge.max_value,
          charge.condition_based === "null" || charge.condition_based === "" ? null : charge.condition_based,
          charge.chargable_value_type === "null" || charge.chargable_value_type === "" ? null : charge.chargable_value_type
        ]);
      }

      // Commit transaction
      await mySqlQury('COMMIT');
      res.json({
        success: true,
        message: 'Charges updated successfully'
      });

    } catch (error) {
      // Rollback on error
      await mySqlQury('ROLLBACK');
      throw error;
    }

  } catch (error) {
    console.error('Error updating charges:', error);
    res.status(500).json({
      error: 'Failed to update charges',
      details: error.message
    });
  }
}
const apiStandardTatVendorId = async (req, res) => {
  try {
    const vendorId = req.params.vendorId;
    const query = 'SELECT * FROM tbl_standard_tat WHERE vendor_id = ?';

    const results = await mySqlQury(query, [vendorId]);
    res.json(results);

  } catch (error) {
    console.error('Error fetching standard TAT:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
const apiStandardTatSave = async (req, res) => {
  try {
    const { vendor_id, zones } = req.body;
    console.log("zones", zones)
    console.log("vendor_id", vendor_id)
    // console.log("req.body", iutydutdustd)

    // Delete existing entries
    await mySqlQury('DELETE FROM tbl_standard_tat WHERE vendor_id = ?', [vendor_id]);


    // Insert new entries
    for (const [zone, days] of Object.entries(zones)) {
      if (days) { // Only insert if days value exists
        await mySqlQury(
          'INSERT INTO tbl_standard_tat (vendor_id, zone, days) VALUES (?, ?, ?)',
          [vendor_id, zone, days]
        );
      }
    }


    res.json({ success: true, message: 'Standard TAT saved successfully' });
  } catch (error) {
    console.error('Error saving standard TAT:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
const apiStandardZoneMapVendor = async (req, res) => {
  try {
    const vendorId = req.params.vendorId;
    const query = 'SELECT * FROM tbl_standard_zone_map WHERE vendor_id = ?';

    const results = await mySqlQury(query, [vendorId]);
    res.json(results);

  } catch (error) {
    console.error('Error fetching standard zone mapping:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
const apiStandardZoneMapSave = async (req, res) => {

  try {
    await mySqlQury('START TRANSACTION');
    console.log("req.body", req.body)
    const { vendor_id, zones } = req.body;
    console.log("zones", zones)
    console.log("vendor_id", vendor_id)


    // Delete existing mappings
    await mySqlQury(

      'DELETE FROM tbl_standard_zone_map WHERE vendor_id = ?',
      [vendor_id]
    );

    // Insert new mappings
    for (const zone of zones) {
      const { zoneName, rule, cities, states } = zone;

      // Insert city mappings
      for (const city of cities) {
        await mySqlQury(
          'INSERT INTO tbl_standard_zone_map (vendor_id, zone, rule, city, state) VALUES (?, ?, ?, ?, NULL)',
          [vendor_id, zoneName, rule, city]
        );
      }


      // Insert state mappings
      for (const state of states) {
        await mySqlQury(
          'INSERT INTO tbl_standard_zone_map (vendor_id, zone, rule, city, state) VALUES (?, ?, ?, NULL, ?)',
          [vendor_id, zoneName, rule, state]
        );
      }

    }

    await mySqlQury('COMMIT');
    res.json({ success: true, message: 'Zone mapping saved successfully' });
  } catch (error) {
    await mySqlQury('ROLLBACK');
    console.error('Error saving zone mapping:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
const apiLtlZoneMapVendorId = async (req, res) => {
  try {
    const vendorId = req.params.vendorId;
    const tableName = `tbl_zone_mapping_${vendorId}`;

    // Check if table exists
    const tableExists = await mySqlQury(`
            SELECT COUNT(*) as count 
            FROM information_schema.tables 
            WHERE table_schema = DATABASE() 
            AND table_name = ?
        `, [tableName]);

    if (tableExists[0].count === 0) {
      // Create table if it doesn't exist
      await mySqlQury(`
                CREATE TABLE IF NOT EXISTS ${tableName} (
                    id BIGINT(20) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
                    zone VARCHAR(50),
                    city VARCHAR(255),
                    state VARCHAR(255),
                    forwarder_id BIGINT(20) UNSIGNED,
                    FOREIGN KEY (forwarder_id) REFERENCES tbl_vendor_details(id) ON DELETE CASCADE,
                    UNIQUE KEY (zone, city, state, forwarder_id)
                )
            `);
    }

    // Get zone mapping data
    const results = await mySqlQury(`SELECT * FROM ${tableName} WHERE forwarder_id = ?`, [vendorId]);
    res.json(results);

  } catch (error) {
    console.error('Error fetching LTL zone mapping:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
const apiLtlZoneMapSave = async (req, res) => {
  try {
    const { vendorId, zoneData } = req.body;
    const tableName = `tbl_zone_mapping_${vendorId}`;
    console.log("zoneData", zoneData)
    console.log("vendorId", vendorId)

    // Check if zoneData is valid
    if (!zoneData || typeof zoneData !== 'object') {
      throw new Error('Invalid zone data format');
    }

    // Begin transaction
    await mySqlQury('START TRANSACTION');

    // Delete existing mappings
    await mySqlQury(`DELETE FROM ${tableName} WHERE forwarder_id = ?`, [vendorId]);

    // Insert new mappings
    for (const zone in zoneData) {
      if (Object.prototype.hasOwnProperty.call(zoneData, zone)) {
        const zoneInfo = zoneData[zone];
        const cities = zoneInfo.cities || [];
        const states = zoneInfo.states || [];
        const secondaryStates = zoneInfo.secondaryStates || [];

        // Insert cities
        for (const city of cities) {
          if (city && city.trim()) {
            await mySqlQury(
              `INSERT INTO ${tableName} (zone, city, forwarder_id) VALUES (?, ?, ?)`,
              [zone, city, vendorId]
            );
          }
        }

        // Insert states
        const allStates = [...states, ...secondaryStates].filter(state => state && state.trim());
        for (const state of allStates) {
          await mySqlQury(
            `INSERT INTO ${tableName} (zone, state, forwarder_id) VALUES (?, ?, ?)`,
            [zone, state, vendorId]
          );
        }
      }
    }

    // Commit transaction
    await mySqlQury('COMMIT');

    res.json({ success: true, message: 'Zone mapping saved successfully' });
  } catch (error) {
    // Rollback on error
    await mySqlQury('ROLLBACK');
    console.error('Error saving LTL zone mapping:', error);
    res.status(500).json({ error: 'Internal server error', details: error.message });
  }
}
const apiVendorRateListLtlVendorId = async (req, res) => {
  try {
    const vendorId = req.params.vendorId;

    // Get rates from tbl_vendor_rates
    const ratesQuery = `
            SELECT zone_origin, zone_destination, rate 
            FROM tbl_vendor_rates 
            WHERE vendor_id = ? 
            AND forwarder_type = 'LTL' 
            AND service_type = 'surface'
        `;

    // Get volumetric factor and min chargeable weight from tbl_vendor_details
    const detailsQuery = `
            SELECT volumetric_factor, minimum_chargable_weight 
            FROM tbl_vendor_details 
            WHERE id = ?
        `;

    const [rates, details] = await Promise.all([
      mySqlQury(ratesQuery, [vendorId]),
      mySqlQury(detailsQuery, [vendorId])
    ]);

    res.json({
      rates,
      volumetric_factor: details[0]?.volumetric_factor || '',
      min_chargeable_weight: details[0]?.minimum_chargable_weight || ''
    });

  } catch (error) {
    console.error('Error fetching LTL rates:', error);
    res.status(500).json({ error: 'Failed to fetch rate list' });
  }
}
const apiLtlRateListCourierId = async (req, res) => {
  try {
    const courierId = req.params.courierId;
    // ... use courierId in your LTL logic ...
    res.json({ /* ...data... */ });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch rate list' });
  }
}
const apiExpressRateListCourierId = async (req, res) => {
  try {
    const courierId = req.params.courierId;
    const [courierDetails] = await mySqlQury(
      `SELECT volumetric_factor FROM tbl_courier_details WHERE id = ?`,
      [courierId]
    );
    console.log("skdhsjkdhs", courierDetails)
    const volumetric_factor = courierDetails ? courierDetails.volumetric_factor : null;

    // 1. Get all weight slabs for this courier
    const slabs = await mySqlQury(`
        SELECT slab_id, min_weight, max_weight, unit
        FROM tbl_exp_weightslabs
        WHERE courier_id = ?
      `, [courierId]);

    const formattedSlabs = [];

    for (const slab of slabs) {
      const { slab_id: slabId, min_weight, max_weight, unit } = slab;

      // 2. Get zone rates for this weight slab
      const zoneRates = await mySqlQury(`
          SELECT zone_name, zone_value
          FROM tbl_exp_zones_rates
          WHERE courier_id = ? AND weight_slab_id = ?
        `, [courierId, slabId]);

      const zones = {};
      zoneRates.forEach(rate => {
        zones[rate.zone_name] = parseFloat(rate.zone_value);
      });

      // 3. Get slab additional charges
      const slabAdditionalChargesRaw = await mySqlQury(`
          SELECT charge_id, description, weight, unit
          FROM tbl_exp_slab_additional_charges
          WHERE courier_id = ? AND weight_slab_id = ?
        `, [courierId, slabId]);

      const slab_additional_charges = [];

      for (const charge of slabAdditionalChargesRaw) {
        const amountsRaw = await mySqlQury(`
            SELECT zone_name, amount
            FROM tbl_exp_slab_additionalamounts
            WHERE additional_charge_id = ?
          `, [charge.charge_id]);

        const amounts = {};
        amountsRaw.forEach(item => {
          amounts[item.zone_name] = parseFloat(item.amount);
        });

        slab_additional_charges.push({
          desc: charge.description,
          weight: charge.weight,
          unit: charge.unit,
          amounts
        });
      }

      // 4. Push formatted slab
      formattedSlabs.push({
        min_weight,
        max_weight,
        unit,
        zones,
        slab_additional_charges
      });
    }

    // 5. Get global express additional charges
    const expressAdditionalCharges = await mySqlQury(`
        SELECT charge_id, charge_name, calculation_based_on_min, calculation_based_on_max, min_value, max_value, condition_based, chargable_value_type
        FROM tbl_courier_exp_additional_charges
        WHERE courier_id = ?
      `, [courierId]);

    res.json({
      slabs: formattedSlabs,
      express_additional_charges: expressAdditionalCharges,
      volumetric_factor

    });

  } catch (error) {
    console.error('Error fetching express rate list:', error);
    res.status(500).json({ error: 'Failed to fetch express rate list' });
  }
}
const apiputExpressrateCourierId = async (req, res) => {
  try {
    const courierId = req.params.courierId;
    const { slabs } = req.body;
    mySqlQury('START TRANSACTION');

    // 1. Delete existing data for this courier
    await mySqlQury('DELETE FROM tbl_exp_slab_additionalamounts WHERE additional_charge_id IN (SELECT charge_id FROM tbl_exp_slab_additional_charges WHERE courier_id = ?)', [courierId]);
    await mySqlQury('DELETE FROM tbl_exp_slab_additional_charges WHERE courier_id = ?', [courierId]);
    await mySqlQury('DELETE FROM tbl_exp_zones_rates WHERE courier_id = ?', [courierId]);
    await mySqlQury('DELETE FROM tbl_exp_weightslabs WHERE courier_id = ?', [courierId]);

    // 2. Insert new slabs and related data
    for (const slab of slabs) {
      const { weightSlab, zones, additionalCharges } = slab;
      // Insert into tbl_exp_weightslabs
      const result = await mySqlQury(
        'INSERT INTO tbl_exp_weightslabs (courier_id, min_weight, max_weight, unit) VALUES (?, ?, ?, ?)',
        [courierId, weightSlab.min, weightSlab.max, weightSlab.unit]
      );
      const slabId = result.insertId;

      // Insert zones for this slab
      for (const [zoneName, zoneValue] of Object.entries(zones)) {
        await mySqlQury(
          'INSERT INTO tbl_exp_zones_rates (courier_id, weight_slab_id, zone_name, zone_value) VALUES (?, ?, ?, ?)',
          [courierId, slabId, zoneName, zoneValue]
        );
      }

      // Insert additional charges for this slab
      if (additionalCharges && additionalCharges.length > 0) {
        for (const charge of additionalCharges) {
          const { desc, weight, unit, amounts } = charge;
          // Insert into tbl_exp_slab_additional_charges
          const addChargeResult = await mySqlQury(
            'INSERT INTO tbl_exp_slab_additional_charges (courier_id, weight_slab_id, description, weight, unit) VALUES (?, ?, ?, ?, ?)',
            [courierId, slabId, desc, weight, unit]
          );
          const chargeId = addChargeResult.insertId;

          // Insert zone-wise amounts for this charge
          for (const [zoneName, amount] of Object.entries(amounts)) {
            await mySqlQury(
              'INSERT INTO tbl_exp_slab_additionalamounts (additional_charge_id, zone_name, amount) VALUES (?, ?, ?)',
              [chargeId, zoneName, amount]
            );
          }
        }
      }
    }
    mySqlQury('COMMIT');

    res.json({ success: true, message: 'Express rate list updated.' });
  } catch (error) {
    await mySqlQury('ROLLBACK');
    console.error('Error updating express rate list:', error);
    res.status(500).json({ error: 'Failed to update express rate list' });
  }
}
const apiVendorTatLtl = async (req, res) => {
  try {
    const vendorId = req.params.vendorId;

    // Get TAT data from the dynamic table
    const query = `
            SELECT zone_origin, zone_destination, days 
            FROM tbl_tat_${vendorId}
            WHERE forwarder_id = ?
        `;

    const tatData = await mySqlQury(query, [vendorId]);
    res.json(tatData);

  } catch (error) {
    console.error('Error fetching LTL TAT:', error);
    res.status(500).json({ error: 'Failed to fetch TAT data' });
  }
}
const getapiStandardRateList = async (req, res) => {
  try {
    const vendorId = req.params.vendorId;

    // Get weight slabs
    const weightSlabsQuery = `
            SELECT * FROM tbl_std_weightslabs 
            WHERE vendor_id = ?
            ORDER BY slab_id
        `;
    const weightSlabs = await mySqlQury(weightSlabsQuery, [vendorId]);

    // Get all data for each weight slab
    const result = await Promise.all(weightSlabs.map(async (slab) => {
      // Get zones for this slab
      const zonesQuery = `
                SELECT zone_name, zone_value 
                FROM tbl_std_zones 
                WHERE weight_slab_id = ?
            `;
      const zones = await mySqlQury(zonesQuery, [slab.slab_id]);

      // Get additional charges
      const chargesQuery = `
                SELECT * FROM tbl_std_additional_charges 
                WHERE weight_slab_id = ?
            `;
      const charges = await mySqlQury(chargesQuery, [slab.slab_id]);

      // Get amounts for each charge
      const additional_charges = await Promise.all(charges.map(async (charge) => {
        const amountsQuery = `
                    SELECT zone_name, amount 
                    FROM tbl_std_additionalamounts 
                    WHERE additional_charge_id = ?
                `;
        const amounts = await mySqlQury(amountsQuery, [charge.charge_id]);

        // Convert amounts array to object
        const amountsObject = amounts.reduce((acc, curr) => {
          acc[curr.zone_name] = curr.amount;
          return acc;
        }, {});

        return {
          desc: charge.description,
          weight: charge.weight,
          unit: charge.unit,
          amounts: amountsObject
        };
      }));

      // Convert zones array to object
      const zonesObject = zones.reduce((acc, curr) => {
        acc[curr.zone_name] = curr.zone_value;
        return acc;
      }, {});

      return {
        min_weight: slab.min_weight,
        max_weight: slab.max_weight,
        unit: slab.unit,
        zones: zonesObject,
        additional_charges
      };
    }));

    res.json(result);

  } catch (error) {
    console.error('Error fetching standard rate list:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch standard rate list',
      error: error.message
    });
  }
}
const postapiStandardRateList = async (req, res) => {
  const vendorId = req.params.vendorId;
  const { slabs } = req.body;

  try {
    // Validate vendorId
    if (!vendorId || vendorId === 'null') {
      throw new Error('Invalid vendor ID');
    }
    console.log("slabs", slabs)

    // Start transaction
    await mySqlQury('START TRANSACTION');

    // Delete existing data for this vendor
    await mySqlQury('DELETE FROM tbl_std_weightslabs WHERE vendor_id = ?', [vendorId]);

    // Insert new data
    for (const slab of slabs) {
      // Validate slab data
      if (!slab.weightSlab || !slab.weightSlab.min || !slab.weightSlab.max || !slab.weightSlab.unit) {
        throw new Error('Invalid weight slab data');
      }

      // Insert weight slab
      const weightSlabQuery = `
                INSERT INTO tbl_std_weightslabs (vendor_id, min_weight, max_weight, unit) 
                VALUES (?, ?, ?, ?)
            `;
      const weightSlabResult = await mySqlQury(weightSlabQuery, [
        vendorId,
        slab.weightSlab.min,
        slab.weightSlab.max,
        slab.weightSlab.unit
      ]);
      const weightSlabId = weightSlabResult.insertId;

      // Insert zones if they exist
      if (slab.zones) {
        for (const [zoneName, zoneValue] of Object.entries(slab.zones)) {
          if (zoneValue) {
            const zoneQuery = `
                            INSERT INTO tbl_std_zones (vendor_id, zone_name, zone_value, weight_slab_id) 
                            VALUES (?, ?, ?, ?)
                        `;
            await mySqlQury(zoneQuery, [vendorId, zoneName, zoneValue, weightSlabId]);
          }
        }
      }

      // Insert additional charges if they exist
      if (slab.additionalCharges) {
        for (const charge of slab.additionalCharges) {
          if (charge.desc && charge.weight && charge.unit) {
            const chargeQuery = `
                            INSERT INTO tbl_std_additional_charges 
                            (vendor_id, weight_slab_id, description, weight, unit) 
                            VALUES (?, ?, ?, ?, ?)
                        `;
            const chargeResult = await mySqlQury(chargeQuery, [
              vendorId,
              weightSlabId,
              charge.desc,
              charge.weight,
              charge.unit
            ]);
            const chargeId = chargeResult.insertId;

            // Insert amounts for each zone
            if (charge.amounts) {
              for (const [zone, amount] of Object.entries(charge.amounts)) {
                if (amount) {
                  const amountQuery = `
                                        INSERT INTO tbl_std_additionalamounts 
                                        (vendor_id, additional_charge_id, zone_name, amount) 
                                        VALUES (?, ?, ?, ?)
                                    `;
                  await mySqlQury(amountQuery, [vendorId, chargeId, zone, amount]);
                }
              }
            }
          }
        }
      }
    }

    // Commit transaction
    await mySqlQury('COMMIT');

    res.json({
      success: true,
      message: 'Standard rate list updated successfully'
    });

  } catch (error) {
    // Rollback on error
    await mySqlQury('ROLLBACK');
    console.error('Error updating standard rate list:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to update standard rate list'
    });
  }
}
const apiVendorTatLtlSave = async (req, res) => {
  try {
    const { vendor_id, tat_data } = req.body;

    await mySqlQury('START TRANSACTION');
    console.log("tat_data", tat_data)
    // console.log("vendor_id", jasdgjsdgjs)

    // Delete existing TAT entries
    await mySqlQury(
      `DELETE FROM tbl_tat_${vendor_id} WHERE forwarder_id = ?`,
      [vendor_id]
    );

    // Insert new TAT entries
    for (const tat of tat_data) {
      await mySqlQury(`
                INSERT INTO tbl_tat_${vendor_id} 
                (forwarder_id, zone_origin, zone_destination, days)
                VALUES (?, ?, ?, ?)
            `, [
        vendor_id,
        tat.zone_origin,
        tat.zone_destination,
        tat.days
      ]);
    }

    await mySqlQury('COMMIT');
    res.json({ success: true, message: 'TAT data saved successfully' });

  } catch (error) {
    await mySqlQury('ROLLBACK');
    console.error('Error saving TAT data:', error);
    res.status(500).json({ error: 'Failed to save TAT data' });
  }
}
const apiVendorRateListLtl = async (req, res) => {
  try {
    const { vendor_id, rates, volumetric_factor, min_chargeable_weight } = req.body;

    await mySqlQury('START TRANSACTION');

    // Update vendor details
    await mySqlQury(`
            UPDATE tbl_vendor_details 
            SET volumetric_factor = ?, 
                minimum_chargable_weight = ?
            WHERE id = ?
        `, [volumetric_factor, min_chargeable_weight, vendor_id]);

    // Delete existing rates
    await mySqlQury(
      'DELETE FROM tbl_vendor_rates WHERE vendor_id = ? AND forwarder_type = ? AND service_type = ?',
      [vendor_id, 'LTL', 'surface']
    );

    // Insert new rates
    for (const rate of rates) {
      await mySqlQury(`
                INSERT INTO tbl_vendor_rates 
                (vendor_id, zone_origin, zone_destination, forwarder_type, service_type, rate)
                VALUES (?, ?, ?, ?, ?, ?)
            `, [
        vendor_id,
        rate.zone_origin,
        rate.zone_destination,
        'LTL',
        'surface',
        rate.rate
      ]);
    }

    await mySqlQury('COMMIT');
    res.json({ success: true, message: 'Rates and details saved successfully' });

  } catch (error) {
    await mySqlQury('ROLLBACK');
    console.error('Error saving rates:', error);
    res.status(500).json({ error: 'Failed to save rates' });
  }
}

// Unified API to fetch forwarder data (Additional Charges + Rate List) by ID and courier_type
const apiForwarderUnifiedData = async (req, res) => {
  try {
    const courierId = req.params.id;
    console.log("courier id", courierId);

    // Get courier details (exactly like the route logic)
    const [courierDetails] = await mySqlQury(
      `SELECT id, company_name, courier_type, service_type, tagged_api, 
              business_volume, packet_shipment, delhivery_api_variant, logo_path, volumetric_factor 
       FROM tbl_courier_details 
       WHERE id = ?`,
      [courierId]
    );

    if (!courierDetails) {
      return res.status(404).json({ success: false, error: 'Forwarder not found' });
    }

    console.log("courierDetails", courierDetails);
    const volumetric_factor = courierDetails.volumetric_factor;
    const courierType = courierDetails.courier_type?.toLowerCase();

    let formattedSlabs = [];
    let expressAdditionalCharges = [];

    if (courierType === 'express') {
      // 1. Get all weight slabs for this courier (using exact route logic)
      const slabs = await mySqlQury(`
        SELECT slab_id, min_weight, max_weight, unit
        FROM tbl_exp_weightslabs
        WHERE courier_id = ?
      `, [courierId]);

      for (const slab of slabs) {
        const { slab_id: slabId, min_weight, max_weight, unit } = slab;

        // 2. Get zone rates for this weight slab (using exact route logic)
        const zoneRates = await mySqlQury(`
          SELECT zone_name, zone_value
          FROM tbl_exp_zones_rates
          WHERE courier_id = ? AND weight_slab_id = ?
        `, [courierId, slabId]);

        const zones = {};
        zoneRates.forEach(rate => {
          zones[rate.zone_name] = parseFloat(rate.zone_value);
        });

        // 3. Get slab additional charges (using exact route logic)
        const slabAdditionalChargesRaw = await mySqlQury(`
          SELECT charge_id, description, weight, unit
          FROM tbl_exp_slab_additional_charges
          WHERE courier_id = ? AND weight_slab_id = ?
        `, [courierId, slabId]);

        const slab_additional_charges = [];

        for (const charge of slabAdditionalChargesRaw) {
          const amountsRaw = await mySqlQury(`
            SELECT zone_name, amount
            FROM tbl_exp_slab_additionalamounts
            WHERE additional_charge_id = ?
          `, [charge.charge_id]);

          const amounts = {};
          amountsRaw.forEach(item => {
            amounts[item.zone_name] = parseFloat(item.amount);
          });

          slab_additional_charges.push({
            desc: charge.description,
            weight: charge.weight,
            unit: charge.unit,
            amounts
          });
        }

        // 4. Push formatted slab (using exact route structure)
        formattedSlabs.push({
          min_weight,
          max_weight,
          unit,
          zones,
          slab_additional_charges
        });
      }

      // 5. Get global express additional charges (using exact route logic)
      expressAdditionalCharges = await mySqlQury(`
        SELECT charge_id, charge_name, calculation_based_on_min, calculation_based_on_max, min_value, max_value, condition_based, chargable_value_type
        FROM tbl_courier_exp_additional_charges
        WHERE courier_id = ?
      `, [courierId]);

    } else if (courierType === 'ecom') {
      // 1. Get all weight slabs for this courier (using exact route logic for ecom)
      const slabs = await mySqlQury(`
        SELECT slab_id, min_weight, max_weight, unit
        FROM tbl_ecom_weightslabs
        WHERE courier_id = ?
      `, [courierId]);

      for (const slab of slabs) {
        const { slab_id: slabId, min_weight, max_weight, unit } = slab;

        // 2. Get zone rates for this weight slab (using exact route logic)
        const zoneRates = await mySqlQury(`
          SELECT zone_name, zone_value
          FROM tbl_ecom_zones_rates
          WHERE courier_id = ? AND weight_slab_id = ?
        `, [courierId, slabId]);

        const zones = {};
        zoneRates.forEach(rate => {
          zones[rate.zone_name] = parseFloat(rate.zone_value);
        });

        // 3. Get slab additional charges (using exact route logic)
        const slabAdditionalChargesRaw = await mySqlQury(`
          SELECT charge_id, description, weight, unit
          FROM tbl_ecom_slab_additional_charges
          WHERE courier_id = ? AND weight_slab_id = ?
        `, [courierId, slabId]);

        const slab_additional_charges = [];

        for (const charge of slabAdditionalChargesRaw) {
          const amountsRaw = await mySqlQury(`
            SELECT zone_name, amount
            FROM tbl_ecom_slab_additionalamounts
            WHERE additional_charge_id = ?
          `, [charge.charge_id]);

          const amounts = {};
          amountsRaw.forEach(item => {
            amounts[item.zone_name] = parseFloat(item.amount);
          });

          slab_additional_charges.push({
            desc: charge.description,
            weight: charge.weight,
            unit: charge.unit,
            amounts
          });
        }

        // 4. Push formatted slab (using exact route structure)
        formattedSlabs.push({
          min_weight,
          max_weight,
          unit,
          zones,
          slab_additional_charges
        });
      }

      // 5. Get global ecom additional charges (using exact route logic)
      expressAdditionalCharges = await mySqlQury(`
        SELECT charge_id, charge_name, calculation_based_on_min, calculation_based_on_max, min_value, max_value, condition_based, chargable_value_type
        FROM tbl_courier_ecom_additional_charges
        WHERE courier_id = ?
      `, [courierId]);
    }

    // Return in exact same format as the route examples
    res.json({
      slabs: formattedSlabs,
      express_additional_charges: expressAdditionalCharges,
      volumetric_factor,
      forwarder: courierDetails
    });

  } catch (error) {
    console.error('Error fetching express rate list:', error);
    res.status(500).json({ error: 'Failed to fetch express rate list' });
  }
};

const postCourierDeleteId = async (req, res) => {
  try {
    console.log("in delete forwarder", req.params.id);
    const forwarderId = req.params.id;

    const result = await mySqlQury(`DELETE FROM tbl_courier_details WHERE id = ?`, [forwarderId]);
    if (result) {
      res.status(200).json(result);
    } else {
      res.status(500).json(result);
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ success: false, message: 'An unexpected error occurred' });
  }
}
const postForwarderUpdate = async (req, res) => {
  const forwarderId = req.params.forwarderId;
  const { form1, form2, form3 } = req.body;
  console.log("dhfdf")

  const MAX_RETRIES = 3;

  for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
    await mySqlQury('START TRANSACTION');

    try {
      // Update Vendor Details
      const updateVendorSql = `
            UPDATE tbl_vendor_details SET
              forwarder_name = ?, forwarder_type = ?, service_type = ?, company_name = ?, 
              company_address = ?, company_country = ?, company_state = ?, company_district = ?, 
              website = ?, from_date = ?, from_to = ?, choose_bank = ?, ifsc_code = ?, 
              account_number = ?, gst_no = ?, credit_terms = ?, billing_cycle = ?
            WHERE id = ?
          `;
      const vendorValues = [
        form1.forwarderName, form1.forwarderType, form1.serviceType, form1.companyName,
        form1.companyAddress, form1.companyCountry, form1.companyState, form1.companyDistrict,
        form1.website, form1.fromDate, form1.fromTo, form1.chooseBank, form1.ifscCode,
        form1.accountNumber, form1.gstNo, form1.creditTerms, form1.billingCycle,
        forwarderId
      ];
      await mySqlQury(updateVendorSql, vendorValues);

      // Fetch Existing Contacts
      const existingContactsSql = `SELECT * FROM tbl_vendor_contacts WHERE vendor_id = ?`;
      const existingContacts = await mySqlQury(existingContactsSql, [forwarderId]);

      const contactTypes = ['sales', 'ops', 'accounts', 'rvp'];

      for (const type of contactTypes) {
        const names = form2[`${type}_name[]`] || [];
        const designations = form2[`${type}_designation[]`] || [];
        const emails = form2[`${type}_email[]`] || [];
        const phones = form2[`${type}_phone[]`] || [];

        const formData = names.map((name, index) => ({
          name,
          designation: designations[index] || null,
          email: emails[index] || null,
          phone: phones[index] || null
        }));

        // Update or Insert contacts
        for (const contactData of formData) {
          const existingContact = existingContacts.find(
            (contact) => contact.name === contactData.name && contact.department === type
          );

          if (existingContact) {
            // Update existing contact if there are changes
            if (existingContact.phone !== contactData.phone ||
              existingContact.email !== contactData.email ||
              existingContact.designation !== contactData.designation) {
              const updateContactSql = `
                    UPDATE tbl_vendor_contacts SET
                      name = ?, phone = ?, email = ?, designation = ?, department = ?
                    WHERE id = ?
                  `;
              const contactValues = [
                contactData.name,
                contactData.phone,
                contactData.email,
                contactData.designation,
                type,
                existingContact.id
              ];
              await mySqlQury(updateContactSql, contactValues);
            }
          } else {
            // Insert new contact
            const insertContactSql = `
                  INSERT INTO tbl_vendor_contacts (
                    vendor_id, name, phone, email, designation, department
                  ) VALUES (?, ?, ?, ?, ?, ?)
                `;
            const contactValues = [
              forwarderId,
              contactData.name,
              contactData.phone,
              contactData.email,
              contactData.designation,
              type
            ];
            await mySqlQury(insertContactSql, contactValues);
          }
        }

        // Remove extra existing contacts that are not in the form
        const contactNamesInForm = formData.map(contact => contact.name);
        const contactsToDelete = existingContacts.filter(contact =>
          contact.department === type && !contactNamesInForm.includes(contact.name)
        );
        for (const contact of contactsToDelete) {
          const deleteContactSql = `DELETE FROM tbl_vendor_contacts WHERE id = ?`;
          await mySqlQury(deleteContactSql, [contact.id]);
        }
      }

      // Update Rates
      const insertRateSql = `
            INSERT INTO tbl_vendor_rates (
              vendor_id, zone_origin, zone_destination, forwarder_type, service_type, rate
            ) VALUES (?, ?, ?, ?, ?, ?)
            ON DUPLICATE KEY UPDATE
              rate = VALUES(rate)
          `;

      const rateEntries = Object.entries(form3).map(([key, value]) => {
        const matches = key.match(/^rate\[(.*?)\]\[(.*?)\]$/);
        if (matches) {
          const rateValue = value === '' ? null : parseFloat(value);
          if (rateValue !== null && !isNaN(rateValue)) {
            return [forwarderId, matches[1], matches[2], form1.forwarderType, form1.serviceType, rateValue];
          }
        }
        return null;
      }).filter(entry => entry !== null);

      for (const entry of rateEntries) {
        await mySqlQury(insertRateSql, entry);
      }
      // Commit the transaction if everything is successful
      await mySqlQury('COMMIT');
      res.status(200).send('Data of vendor is successfully updated');
      return; // Exit the loop on success
    } catch (error) {
      console.error('Error in updating vendor details:', error);
      await mySqlQury('ROLLBACK');
      if (error.code === 'ER_LOCK_DEADLOCK') {
        console.log('Deadlock detected, retrying...');
        if (attempt === MAX_RETRIES - 1) {
          res.status(500).send('Internal Server Error');
        }
      } else {
        res.status(500).send('Internal Server Error');
        return;
      }
    }
  }
}
const LtlUnprocessedOrder = async (req, res, next) => {
  try {
    let result;
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;

    let loginDetails = null;
    let clientId = 0;
    let walletBalance = 0;
    let vasService = 0;
    console.log("req.user", req.user)

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,company_name,vas,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

      // Get orders and company names filtered by client_id
      result = await mySqlQury(
        `SELECT o.*, c.company_name
           FROM tbl_unprocessed_order o
           LEFT JOIN tbl_admin c ON o.client_id = c.id
           WHERE o.is_unprocessesd = 1
           AND o.client_id = ?
           ORDER BY o.id DESC`,
        [clientId]
      );

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;


      // Get all orders for admin
      result = await mySqlQury(
        `SELECT o.*, c.company_name
           FROM tbl_unprocessed_order o
           LEFT JOIN tbl_admin c ON o.client_id = c.id
           WHERE o.is_unprocessesd = 1
           ORDER BY o.id DESC`
      );
    }

    // Fetch forwarder data
    const forwarder = await mySqlQury(`SELECT * FROM tbl_vendor_details ORDER BY id DESC;`);

    // Extract unique client IDs from the result
    const uniqueClientIds = [...new Set(result.map(order => order.client_id))];

    // Fetch clients data based on unique client IDs, handling the empty case
    let clients = [];
    if (uniqueClientIds.length > 0) {
      clients = await mySqlQury(
        `SELECT id AS client_id, company_name FROM tbl_admin WHERE id IN (?)`,
        [uniqueClientIds]
      );
    }

    // Get active topics
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Extract active topic IDs
    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    }

    let apiLTL = process.env.API_KEYLTL;
    let apistd = process.env.API_KEYSTD;
    let customerCodeLtl = process.env.CUSTOMER_CODE_LTL;
    let customerCodeStd = process.env.CUSTOMER_CODE_STD;
    // console.log("rtesults",result)
    // console.log("client id",clientId)

    // Render the EJS template with the updated clients data
    res.render('pages/ltl/unprocessed-orders', {
      title: 'Orders Pending To Process',
      bodyClass: 'profile-page',
      activePage: 'profile',
      data: result,
      loginDetails: loginDetails || {}, // Provide empty object as fallback
      forwarder,
      apiLTL,
      clients,
      role_data,
      activeTopicIds,
      profile,
      apiSTD: apistd,
      clientId,
      customerCodeLtl,
      customerCodeStd,
      walletBalance,
      vasService
    });

  } catch (error) {
    console.error('Error:', error);

    // Send JSON response if the error view doesn't exist
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
}
const ecomUnprocessedOrder = async (req, res, next) => {
  try {
    let result;
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;

    // Pagination parameters
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;

    let loginDetails = null;
    let clientId = 0;
    let walletBalance = 0;
    let vasService = 0;
    let totalItems = 0; // Initialize totalItems to avoid undefined error
    console.log("req.user",req.user)

    // Get login details based on selectedClientId
    if (selectedClientId === 1) {
      // For admin (selectedClientId = 1), get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;

      // Get total count for pagination
      const totalCountResult = await mySqlQury(
        `SELECT COUNT(*) as total
         FROM tbl_ecom_orders o
         WHERE o.is_unprocessed = 1`
      );
      const totalItems = totalCountResult[0].total;

      // Get paginated orders for admin
      result = await mySqlQury(
        `SELECT o.*, c.company_name
         FROM tbl_ecom_orders o
         LEFT JOIN tbl_admin c ON o.client_id = c.id
         WHERE o.is_unprocessed = 1
         ORDER BY o.id DESC
         LIMIT ? OFFSET ?`,
        [limit, offset]
      );
    } else {
      // For specific client, use selectedClientId directly
      loginDetails = {
        id: selectedClientId,
        first_name: 'Client',
        company_name: 'Client Company',
        logo_path: null,
        vas: 1
      };
      clientId = selectedClientId;
      vasService = 1;
      
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [selectedClientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

      // Get total count for pagination (client-specific)
      const totalCountResult = await mySqlQury(
        `SELECT COUNT(*) as total
         FROM tbl_ecom_orders o
         WHERE o.is_unprocessed = 1
         AND o.client_id = ?`,
        [selectedClientId]
      );
      const totalItems = totalCountResult[0].total;

      // Get paginated orders filtered by selectedClientId
      result = await mySqlQury(
        `SELECT o.*, c.company_name
         FROM tbl_ecom_orders o
         LEFT JOIN tbl_admin c ON o.client_id = c.id
         WHERE o.is_unprocessed = 1
         AND o.client_id = ?
         ORDER BY o.id DESC
         LIMIT ? OFFSET ?`,
        [selectedClientId, limit, offset]
      );
    }

    // Fetch forwarder data
    const forwarder = await mySqlQury(`SELECT * FROM tbl_courier_details ORDER BY id DESC;`);

    // Extract unique client IDs from the result
    const uniqueClientIds = [...new Set(result.map(order => order.client_id))];
    // console.log("result",result)

    // Create clients data based on unique client IDs
    let clients = [];
    if (uniqueClientIds.length > 0) {
      clients = uniqueClientIds.map(clientId => ({
        client_id: clientId,
        company_name: clientId === selectedClientId ? 'Client Company' : 'Other Company'
      }));
    }

    // Get active topics
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Extract active topic IDs
    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    }
    const orderIds = result.map(order => order.id);
    const warehouseIds = [...new Set(result.map(order => order.warehouse_id).filter(id => id))];

// Step 2: Fetch related tables in bulk
let consigneeDetails = [];

let productDetails = [];
let warehouseDetails = [];

if (orderIds.length > 0) {
  consigneeDetails = await mySqlQury(`SELECT * FROM tbl_ecom_consignee_details WHERE order_id IN (?)`, [orderIds]);
 
  productDetails = await mySqlQury(`SELECT * FROM tbl_ecom_product_details WHERE order_id IN (?)`, [orderIds]);
}
if (warehouseIds.length > 0) {
  warehouseDetails = await mySqlQury(
    `SELECT serial, warehouse_person, warehouse_pincode, warehouse_name,warehouse_contact_person,warehouse_city,warehouse_address,warehouse_state
     FROM tbl_add_warehouse 
     WHERE serial IN (?)`,
    [warehouseIds]
  );
  
}

// Step 3: Group by order_id
function groupBy(list, key) {
  return list.reduce((acc, item) => {
    const k = item[key];
    if (!acc[k]) acc[k] = [];
    acc[k].push(item);
    return acc;
  }, {});
}
const warehouseMap = warehouseDetails.reduce((acc, w) => {
  acc[w.serial] = w;
  return acc;
}, {});

const consigneeGrouped = groupBy(consigneeDetails, 'order_id');

const productsGrouped = groupBy(productDetails, 'order_id');

// Step 4: Attach grouped data to each order
const enrichedOrders = result.map(order => ({
  ...order,
  consignee: (consigneeGrouped[order.id] && consigneeGrouped[order.id][0]) || null, // ðŸ‘ˆ Single object
 
  products: productsGrouped[order.id] || [],
  warehouse: warehouseMap[order.warehouse_id] || null // âœ… Attach warehouse details
}));
console.log("enrichedOrders",enrichedOrders)

    // Calculate pagination metadata
    const totalPages = Math.ceil(totalItems / limit);
    const startItem = offset + 1;
    const endItem = Math.min(offset + limit, totalItems);

    let apiLTL = process.env.API_KEYLTL;
    let apistd = process.env.API_KEYSTD;
    let customerCodeLtl = process.env.CUSTOMER_CODE_LTL;
    let customerCodeStd = process.env.CUSTOMER_CODE_STD;
    // console.log("rtesults",result)
    // console.log("client id",clientId)
   
    // Render the EJS template with the updated clients data
    res.render('pages/ecom/unprocessed-orders', {
      title: 'Orders Pending To Process',
     bodyClass: 'profile-page',
    activePage: 'profile',
      data: enrichedOrders,
      loginDetails: loginDetails || {}, // Provide empty object as fallback
      forwarder,
      apiLTL,
      clients,
      role_data,
      activeTopicIds,
      profile,
      apiSTD: apistd,
      clientId,
      customerCodeLtl,
      customerCodeStd,
      walletBalance,
      vasService,
      role
    });

  } catch (error) {
    console.error('Error:', error);

    // Send JSON response if the error view doesn't exist
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
}
const expressunprocessedOrder = async (req, res, next) => {
  try {
    let result;
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;

    let loginDetails = null;
    let clientId = 0;
    let walletBalance = 0;
    let vasService = 0;
    console.log("req.user",req.user)

    // Get login details based on selectedClientId
    if (selectedClientId === 1) {
      // For admin (selectedClientId = 1), get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;

      // Get all orders for admin
      result = await mySqlQury(
        `SELECT o.*, c.company_name
         FROM tbl_exp_orders o
         LEFT JOIN tbl_admin c ON o.client_id = c.id
         WHERE o.is_unprocessed = 1
         ORDER BY o.id DESC`
      );
    } else {
      // For specific client, use selectedClientId directly
      loginDetails = {
        id: selectedClientId,
        first_name: 'Client',
        company_name: 'Client Company',
        logo_path: null,
        vas: 1
      };
      clientId = selectedClientId;
      vasService = 1;
      
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [selectedClientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

      // Get orders filtered by selectedClientId
      result = await mySqlQury(
        `SELECT o.*, c.company_name
         FROM tbl_exp_orders o
         LEFT JOIN tbl_admin c ON o.client_id = c.id
         WHERE o.is_unprocessed = 1
         AND o.client_id = ?
         ORDER BY o.id DESC`,
        [selectedClientId]
      );
    }

    // Fetch forwarder data
    const forwarder = await mySqlQury(`SELECT * FROM tbl_courier_details ORDER BY id DESC;`);

    // Extract unique client IDs from the result
    const uniqueClientIds = [...new Set(result.map(order => order.client_id))];
    // console.log("result",result)

    // Create clients data based on unique client IDs
    let clients = [];
    if (uniqueClientIds.length > 0) {
      clients = uniqueClientIds.map(clientId => ({
        client_id: clientId,
        company_name: clientId === selectedClientId ? 'Client Company' : 'Other Company'
      }));
    }

    // Get active topics
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Extract active topic IDs
    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    }
    const orderIds = result.map(order => order.id);
    const warehouseIds = [...new Set(result.map(order => order.warehouse_id).filter(id => id))];

// Step 2: Fetch related tables in bulk
let consigneeDetails = [];

let productDetails = [];
let warehouseDetails = [];

if (orderIds.length > 0) {
  consigneeDetails = await mySqlQury(`SELECT * FROM tbl_exp_consignee_details WHERE order_id IN (?)`, [orderIds]);
 
  productDetails = await mySqlQury(`SELECT * FROM tbl_exp_product_details WHERE order_id IN (?)`, [orderIds]);
}
if (warehouseIds.length > 0) {
  warehouseDetails = await mySqlQury(
    `SELECT serial, warehouse_person, warehouse_pincode, warehouse_name,warehouse_contact_person,warehouse_city,warehouse_address,warehouse_state
     FROM tbl_add_warehouse 
     WHERE serial IN (?)`,
    [warehouseIds]
  );
  
}

// Step 3: Group by order_id
function groupBy(list, key) {
  return list.reduce((acc, item) => {
    const k = item[key];
    if (!acc[k]) acc[k] = [];
    acc[k].push(item);
    return acc;
  }, {});
}
const warehouseMap = warehouseDetails.reduce((acc, w) => {
  acc[w.serial] = w;
  return acc;
}, {});

const consigneeGrouped = groupBy(consigneeDetails, 'order_id');

const productsGrouped = groupBy(productDetails, 'order_id');

// Step 4: Attach grouped data to each order
const enrichedOrders = result.map(order => ({
  ...order,
  consignee: (consigneeGrouped[order.id] && consigneeGrouped[order.id][0]) || null, // ðŸ‘ˆ Single object
 
  products: productsGrouped[order.id] || [],
  warehouse: warehouseMap[order.warehouse_id] || null // âœ… Attach warehouse details
}));
console.log("enrichedOrders",enrichedOrders[0])

    let apiLTL = process.env.API_KEYLTL;
    let apistd = process.env.API_KEYSTD;
    let customerCodeLtl = process.env.CUSTOMER_CODE_LTL;
    let customerCodeStd = process.env.CUSTOMER_CODE_STD;
    // console.log("rtesults",result)
    // console.log("client id",clientId)
   
    // Render the EJS template with the updated clients data
    res.render('pages/express/unprocessed-orders', {
      title: 'Orders Pending To Process',
     bodyClass: 'profile-page',
    activePage: 'profile',
      data: enrichedOrders,
      loginDetails: loginDetails || {}, // Provide empty object as fallback
      forwarder,
      apiLTL,
      clients,
      role_data,
      activeTopicIds,
      profile,
      apiSTD: apistd,
      clientId,
      customerCodeLtl,
      customerCodeStd,
      walletBalance,
      vasService,
      role
    });

  } catch (error) {
    console.error('Error:', error);

    // Send JSON response if the error view doesn't exist
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
}
const apiBoxDimensionREfNumber = async (req, res) => {
  console.log("shdsjdhsj")
  const refNumber = req.params.ref_number;
  try {
    const rows = await mySqlQury(
      'SELECT length, breadth, height, dimension_unit FROM tbl_exp_boxes_details WHERE order_id = ?',
      [refNumber]
    );
    console.log("rows", rows)
    res.json({ success: true, data: rows });
  } catch (err) {
    console.error('Error fetching box dimensions:', err);
    res.status(500).json({ success: false, error: 'Database error' });
  }
}
const apiBoxDimensionREfNumberEcom = async (req, res) => {
  console.log("shdsjdhsj")
  const refNumber = req.params.ref_number;
  try {
    const rows = await mySqlQury(
      'SELECT length, breadth, height, dimension_unit FROM tbl_ecom_boxes_details WHERE order_id = ?',
      [refNumber]
    );
    console.log("rows", rows)
    res.json({ success: true, data: rows });
  } catch (err) {
    console.error('Error fetching box dimensions:', err);
    res.status(500).json({ success: false, error: 'Database error' });
  }
}

const fetchOrder = async (req, res) => {
  try {
    const { client_id } = req.query;

    // Base query for unprocessed orders
    let sql1 = 'SELECT * FROM tbl_unprocessed_order WHERE is_unprocessesd = 1';
    let queryParams = [];

    if (client_id) {
      sql1 += ' AND client_id = ?';
      queryParams.push(client_id);
    }

    // Fetch unprocessed orders
    const result = await mySqlQury(sql1, queryParams);

    // Fetch forwarder data
    const forwarder = await mySqlQury(`SELECT * FROM tbl_vendor_details ORDER BY id DESC;`);

    // Fetch clients data
    const role_data = req.user.id;  // Assuming 'role_id' is the role identifier
    const clients = await mySqlQury(`SELECT client_id, company_name, billclient, fod, owner_risk, carrier_risk FROM tbl_customers WHERE client_id = ?`, [role_data]);

    // Get role data from authenticated user



    // Send the complete response
    res.status(200).json({
      data: result,
      forwarder,
      clients,

      role_data,
    });
  } catch (error) {
    console.error('Error fetching orders:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
}
const deleteOrders = async (req, res) => {
  const { po_no } = req.body;

  if (!po_no) {
    return res.status(400).json({ message: 'PO number is required' });
  }

  try {
    // Start a transaction
    await mySqlQury('START TRANSACTION');

    // Delete from tbl_unprocessed_order
    await mySqlQury('DELETE FROM tbl_unprocessed_order WHERE po_no = ?', [po_no]);

    // Delete from tbl_box_dimensions
    await mySqlQury('DELETE FROM tbl_boxes_dimension WHERE po_no = ?', [po_no]);

    // Delete from tbl_products
    await mySqlQury('DELETE FROM tbl_products WHERE po_no = ?', [po_no]);

    // Commit the transaction
    await mySqlQury('COMMIT');

    res.status(200).json({ message: 'Order deleted successfully' });
  } catch (error) {
    // Rollback the transaction in case of error
    await mySqlQury('ROLLBACK');
    console.error('Error deleting order:', error);
    res.status(500).json({ message: 'Failed to delete the order' });
  }
}
const  getAddressExpress=async (req, res, next) => {
  try {
    const { phoneNumber, storeId } = req.body;  // Extract both phoneNumber and storeId

    let query = '';
    let queryParams = [];

    if (phoneNumber) {
      console.log("Fetching addresses for phone number:", phoneNumber);
      query = 'SELECT * FROM tbl_exp_consignee_details WHERE phone = ?';
      queryParams = [phoneNumber];
    } else if (storeId) {
      console.log("Fetching addresses for store ID:", storeId);
      query = 'SELECT * FROM tbl_customer_details WHERE store_id = ?';
      queryParams = [storeId];
    } else {
      // If neither phoneNumber nor storeId is provided, return an error
      return res.status(400).json({ success: false, message: 'Please provide either a phone number or store ID.' });
    }

    // Execute the query with the appropriate parameters
    const results = await mySqlQury(query, queryParams);
    console.log('Results of address fetch:', results);

    // Always return a success response with the addresses
    res.status(200).json({ success: true, addresses: results });
  } catch (error) {
    console.error("Error fetching addresses:", error);
    res.status(500).json({ success: false, message: 'Server error' });
  }
}
const  getPickupAddressEcom=async (req, res, next) => {
  try {
    const { phoneNumber, storeId } = req.body;  // Extract both phoneNumber and storeId

    let query = '';
    let queryParams = [];

    if (phoneNumber) {
      console.log("Fetching addresses for phone number:", phoneNumber);
      query = 'SELECT * FROM tbl_ecom_consignee_details WHERE phone = ?';
      queryParams = [phoneNumber];
    } else if (storeId) {
      console.log("Fetching addresses for store ID:", storeId);
      query = 'SELECT * FROM tbl_customer_details WHERE store_id = ?';
      queryParams = [storeId];
    } else {
      // If neither phoneNumber nor storeId is provided, return an error
      return res.status(400).json({ success: false, message: 'Please provide either a phone number or store ID.' });
    }

    // Execute the query with the appropriate parameters
    const results = await mySqlQury(query, queryParams);
    console.log('Results of address fetch:', results);

    // Always return a success response with the addresses
    res.status(200).json({ success: true, addresses: results });
  } catch (error) {
    console.error("Error fetching addresses:", error);
    res.status(500).json({ success: false, message: 'Server error' });
  }
}
const deliveryStatusLrno = async (req, res) => {
  const lrNo = req.params.lrNo; // Get lrNo from the request parameters

  try {
    // Step 1: Fetch delivery status from tbl_delivery_status
    const sql = `SELECT * FROM tbl_delivery_status WHERE lrnum = ?`;
    const deliveryStatus = await mySqlQury(sql, [lrNo]);
    console.log("'deliveryStatus", deliveryStatus);

    // Check if delivery status was found
    if (deliveryStatus.length === 0) {
      return res.status(404).json({ message: 'Delivery status not found LTL.' });
    }

    // Step 2: Fetch aggregator_id from tbl_create_lr based on lrNo
    const createLrSql = `SELECT aggrigator_id FROM tbl_create_lr WHERE lr_No = ?`;
    const createLrResult = await mySqlQury(createLrSql, [lrNo]);
    console.log("createLrResult", createLrResult);

    if (createLrResult.length === 0) {
      return res.status(404).json({ message: 'Aggregator information not found.' });
    }

    const aggregatorId = createLrResult[0].aggrigator_id;
    console.log("Aggregator", aggregatorId);

    // Step 3: Fetch the logo_path from tbl_aggregator based on aggregator_id
    const aggregatorSql = `SELECT logo_path FROM tbl_aggrigator WHERE id = ?`;
    const aggregatorResult = await mySqlQury(aggregatorSql, [aggregatorId]);

    // If no logo is found, set logoPath to null
    const logoPath = aggregatorResult.length > 0 ? aggregatorResult[0].logo_path : null;

    // Step 4: Send the response with both delivery status and aggregator logo path
    res.json({
      deliveryStatus: deliveryStatus, // Assuming you want to return the first result from delivery status
      logoPath: logoPath
    });
  } catch (error) {
    console.error('Error fetching delivery status:', error);
    res.status(500).send('Internal Server Error');
  }
}
const deliveryStandStatusLr = async (req, res) => {
  const lrNo = req.params.lrNo;

  try {
    // Step 1: Fetch delivery status from tbl_delivery_standard_status
    console.log("lrNo in delivery-standard-status", lrNo)
    const sql = `SELECT * FROM tbl_delivery_standard_status WHERE lrnum = ?`;
    const deliveryStatus = await mySqlQury(sql, [lrNo]);
    console.log("'deliveryStatus", deliveryStatus);

    if (deliveryStatus.length === 0) {
      return res.status(404).json({ message: 'Delivery status not found standard.' });
    }

    // Step 2: Fetch aggregator_id from tbl_create_lr based on lrNo
    const createLrSql = `SELECT aggrigator_id FROM tbl_create_lr WHERE lr_No = ?`;
    const createLrResult = await mySqlQury(createLrSql, [lrNo]);
    console.log("createLrResult", createLrResult);

    if (createLrResult.length === 0) {
      return res.status(404).json({ message: 'Aggregator information not found.' });
    }

    const aggregatorId = createLrResult[0].aggrigator_id;
    console.log("Aggregator", aggregatorId);

    // Step 3: Fetch the logo_path from tbl_aggregator based on aggregator_id
    const aggregatorSql = `SELECT logo_path FROM tbl_aggrigator WHERE id = ?`;
    const aggregatorResult = await mySqlQury(aggregatorSql, [aggregatorId]);

    const logoPath = aggregatorResult.length > 0 ? aggregatorResult[0].logo_path : null;

    res.json({
      deliveryStatus: deliveryStatus,
      logoPath: logoPath
    });
  } catch (error) {
    console.error('Error fetching delivery status:', error);
    res.status(500).send('Internal Server Error');
  }
}
const dtdcLtlStatusLr = async (req, res) => {
  const lrNo = req.params.lrNo;

  try {
    // Step 1: Fetch delivery status from tbl_dtdc_ltl_status
    const sql = `SELECT * FROM tbl_dtdc_ltl_status WHERE lrnum = ?`;
    const deliveryStatus = await mySqlQury(sql, [lrNo]);

    if (deliveryStatus.length === 0) {
      return res.status(404).json({ message: 'Delivery status not found.' });
    }

    // Step 2: Fetch aggregator_id from tbl_create_lr based on lrNo
    const createLrSql = `SELECT aggrigator_id FROM tbl_create_lr WHERE lr_No = ?`;
    const createLrResult = await mySqlQury(createLrSql, [lrNo]);

    if (createLrResult.length === 0) {
      return res.status(404).json({ message: 'Aggregator information not found.' });
    }

    const aggregatorId = createLrResult[0].aggrigator_id;

    // Step 3: Fetch the logo_path from tbl_aggrigator based on aggregator_id
    const aggregatorSql = `SELECT logo_path FROM tbl_aggrigator WHERE id = ?`;
    const aggregatorResult = await mySqlQury(aggregatorSql, [aggregatorId]);

    // If no logo is found, set logoPath to null
    const logoPath = aggregatorResult.length > 0 ? aggregatorResult[0].logo_path : null;

    // Step 4: Send the response with both delivery status and aggregator logo path
    res.json({
      deliveryStatus: deliveryStatus, // Send the entire delivery status array
      logoPath: logoPath
    });
  } catch (error) {
    console.error('Error fetching DTDC/LTL delivery status:', error);
    res.status(500).send('Internal Server Error');
  }
}
const dtdcStandardStatusLr = async (req, res) => {
  const lrNo = req.params.lrNo;

  try {
    // Step 1: Fetch delivery status from tbl_dtdc_standard_status
    const sql = `SELECT * FROM tbl_dtdc_standard_status WHERE lrnum = ?`;
    const deliveryStatus = await mySqlQury(sql, [lrNo]);

    if (deliveryStatus.length === 0) {
      return res.status(404).json({ message: 'DTDC Standard delivery status not found.' });
    }

    // Step 2: Fetch aggregator_id from tbl_create_lr based on lrNo
    const createLrSql = `SELECT aggrigator_id FROM tbl_create_lr WHERE lr_No = ?`;
    const createLrResult = await mySqlQury(createLrSql, [lrNo]);

    if (createLrResult.length === 0) {
      return res.status(404).json({ message: 'Aggregator information not found.' });
    }

    const aggregatorId = createLrResult[0].aggrigator_id;

    // Step 3: Fetch the logo_path from tbl_aggrigator based on aggregator_id
    const aggregatorSql = `SELECT logo_path FROM tbl_aggrigator WHERE id = ?`;
    const aggregatorResult = await mySqlQury(aggregatorSql, [aggregatorId]);

    // If no logo is found, set logoPath to null
    const logoPath = aggregatorResult.length > 0 ? aggregatorResult[0].logo_path : null;

    // Step 4: Send the response with both delivery status and aggregator logo path
    res.json({
      deliveryStatus: deliveryStatus, // Send the entire delivery status array
      logoPath: logoPath
    });
  } catch (error) {
    console.error('Error fetching DTDC Standard delivery status:', error);
    res.status(500).send('Internal Server Error');
  }
}
const getPickupCode = async (req, res) => {
  const { pincode } = req.query;

  try {
    // Use your custom mySqlQury function to fetch the pick hub code based on pincode
    const result = await mySqlQury('SELECT docs_hub_code FROM tbl_pickhub_code WHERE pincode = ?', [pincode]);

    if (result.length > 0) {
      res.json({ pickhub_code: result[0].docs_hub_code });
    } else {
      res.status(404).json({ error: 'Pick hub code not found for this pincode' });
    }
  } catch (error) {
    console.error('Error fetching pick hub code:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
}
const expressbeesStdLrno = async (req, res) => {
  const lrNo = req.params.lrNo;
  console.log("in the expres_stad")

  try {
    // Step 1: Fetch delivery status from tbl_expressbees_status
    const sql = `SELECT * FROM tbl_expressbees_status WHERE lrnum = ?`;
    const deliveryStatus = await mySqlQury(sql, [lrNo]);

    if (deliveryStatus.length === 0) {
      return res.status(404).json({ message: 'Express Bees status not found.' });
    }
    console.log("deliveryStatus",deliveryStatus)

    // Step 2: Fetch aggregator_id from tbl_create_lr based on lrNo
    const createLrSql = `SELECT aggrigator_id FROM tbl_create_lr WHERE lr_No = ?`;
    const createLrResult = await mySqlQury(createLrSql, [lrNo]);

    if (createLrResult.length === 0) {
      return res.status(404).json({ message: 'Aggregator information not found.' });
    }

    const aggregatorId = createLrResult[0].aggrigator_id;

    // Step 3: Fetch the logo_path from tbl_aggrigator based on aggregator_id
    const aggregatorSql = `SELECT logo_path FROM tbl_aggrigator WHERE id = ?`;
    const aggregatorResult = await mySqlQury(aggregatorSql, [aggregatorId]);

    // If no logo is found, set logoPath to null
    const logoPath = aggregatorResult.length > 0 ? aggregatorResult[0].logo_path : null;

    // Step 4: Send the response with both delivery status and aggregator logo path
    res.json({
      deliveryStatus: deliveryStatus, // Send the entire delivery status array
      logoPath: logoPath
    });
  } catch (error) {
    console.error('Error fetching ExpressBees delivery status:', error);
    res.status(500).send('Internal Server Error');
  }
}
const callDeliveryapi = async (req, res) => {
  console.log("req body from the frontend", req.body);
  console.log("Uploaded files:", req.files); // You can see the uploaded files here

  try {
    // Parse delhiveryData from string to an object
    const { delhiveryData, lrn } = req.body;
    let parsedData;
    try {
      parsedData = JSON.parse(delhiveryData);
      console.log("parsed data", parsedData)
    } catch (error) {
      console.log("Error parsing delhiveryData:", error);
      return res.status(400).json({
        success: false,
        message: "Invalid delivery data format"
      });
    }

    const data = new FormData();

    // Handle uploaded files
    if (req.files && Array.isArray(req.files) && req.files.length > 0) {
      console.log("Files uploaded:", req.files);


      req.files.forEach(file => {
        // Append file from path
        if (file.path && file.originalname) {
          data.append('doc_file', fs.createReadStream(file.path), file.originalname); // Using fs.createReadStream to send the file
        } else {
          console.error("File does not have expected properties: ", file);
        }
      });
    }
    // console.log("Files uploaded:", dsjdsjdjs);

    // Ensure delhiveryData is valid and properly structured
    if (!parsedData || typeof parsedData !== "object") {
      console.log("Invalid delivery data request");
      return res.status(400).json({
        success: false,
        message: "Invalid request body"
      });
    }

    const staticDocData = [];

    // Dynamically generate doc_data based on uploaded files and invoice data
    if (req.files && req.files.length > 0) {
      let invoiceValue = req.body.invoiceValue
      req.files.forEach((file, index) => {
        if (file.originalname && parsedData.invoices && parsedData.invoices[index]) {
          staticDocData.push({
            doc_type: "INVOICE_COPY",
            doc_meta: {
              invoice_num: [invoiceValue] || [`Invoice_${index + 1}`] // Use invoice_number if available
            }
          });
        } else {
          console.warn(`File ${file.originalname} does not have a matching invoice or metadata.`);
        }
      });

      // Append doc_data only if files are present
      if (staticDocData.length > 0) {
        data.append('doc_data', JSON.stringify(staticDocData));
      } else {
        console.log("No valid invoice data to append.");
      }
    } else {
      console.log("No files uploaded. Skipping doc_data append.");
    }


    // if (Array.isArray(parsedData.invoices)) {
    //   const invoiceDocData = parsedData.invoices.map(invoice => ({
    //     doc_type: "INVOICE_COPY",
    //     doc_meta: {
    //       invoice_num: [invoice.invoice_number] // Assuming invoices contain an 'invoice_number' field
    //     }
    //   }));
    //   staticDocData.push(...invoiceDocData); // Append invoiceDocData to staticDocData
    // }

    // data.append('doc_data', JSON.stringify(staticDocData));
    // data.append('doc_data', JSON.stringify(staticDocData));

    // Extract delivery API token
    const token = await getValidDeliveryApiToken();

    // Build the form data for sending to the external Delhivery API
    data.append('lrn', lrn || '');
    data.append('pickup_location_name', parsedData.pickup_location_name);
    data.append('payment_mode', parsedData.payment_mode?.toLowerCase() === 'prepaid' ? 'prepaid' : parsedData.payment_mode?.toLowerCase() === 'cod' ? 'cod' : 'prepaid');
    data.append('cod_amount', parsedData.cod_amount || '0');
    data.append('weight', 1000);
    data.append('rov_insurance', parsedData.rov_insurance || 'False');

    // Handle shipment details
    if (Array.isArray(parsedData.shipment_details)) {
      const updatedShipmentDetails = parsedData.shipment_details.map(detail => ({
        ...detail,
        order_id: detail.order_id,
        box_count: detail.box_count,
        description: detail.description || 'Default Description',
        weight: 1000,
        waybills: detail.waybills || []
      }));
      data.append('shipment_details', JSON.stringify(updatedShipmentDetails));
    }

    // Handle invoices
    if (Array.isArray(parsedData.invoices) && parsedData.invoices.length > 0) {
      data.append('invoices', JSON.stringify(parsedData.invoices));
    } else {
      return res.status(400).json({
        success: false,
        message: "Invoices field is required."
      });
    }

    // Handle dimensions
    if (Array.isArray(parsedData.dimensions)) {
      const updatedDimensions = parsedData.dimensions.map(dimension => ({
        box_count: dimension.box_count || 1,
        length: dimension.length || 10,
        width: dimension.width || 10,
        height: dimension.height || 10,
        weight: dimension.weight >= 20 ? dimension.weight : 20
      }));
      data.append('dimensions', JSON.stringify(updatedDimensions));
    }

    // Handle drop-off location
    const dropoffLocation = {
      consignee_name: parsedData.dropoff_location?.name || 'Default Name',
      address: parsedData.dropoff_location?.address_line_1 || 'Default Address',
      city: parsedData.dropoff_location?.city || 'Default City',
      state: parsedData.dropoff_location?.state || 'Default State',
      zip: parsedData.dropoff_location?.pincode || '000000',
      phone: parsedData.dropoff_location?.phone || '0000000000',
      email: parsedData.dropoff_location?.email || ''
    };
    data.append('dropoff_location', JSON.stringify(dropoffLocation));
    console.log("data here", data)
    // console.log("datajdjsds",dsdsds)

    // Axios request to the Delhivery API
    const config = {
      method: 'post',
      url: 'https://ltl-clients-api.delhivery.com/manifest',
      headers: {
        'Authorization': `Bearer ${token}`,
        ...data.getHeaders(),
        'Content-Type': 'multipart/form-data' // Ensure this header is set correctly
      },
      data: data
    };

    // Call the Delhivery API
    const response = await axios(config);
    console.log("Delhivery API Response: ", response.data);

    if (response.data && response.data.success) {
      res.json({
        referenceNumber: response.data.reference_number,
        jobId: response.data.job_id,
        token: token,
        success: true
      });
    } else {
      res.status(400).json({
        message: 'Failed to get reference number from Delhivery',
        success: false
      });
    }
  } catch (error) {
    console.error("Error calling Delhivery API:", error.response?.data || error);

    // Handle API error
    if (error.response && error.response.data) {
      return res.status(400).json({
        success: false,
        error: {
          code: error.response.status || 400,
          message: error.response.data.error?.message || "Unknown error"
        },
        request_id: error.response.data.request_id || "N/A"
      });
    }

    // Fallback error handling
    res.status(500).json({
      success: false,
      error: {
        code: 500,
        message: 'Internal Server Error'
      },
      request_id: "N/A"
    });
  }
}
const apiTokenForExpressbees = async (req, res) => {
  try {
    const token = await getExpressbeesToken();
    res.json({ token });
  } catch (error) {
    console.error('Error fetching token:', error);
    res.status(500).json({ error: 'Failed to fetch token' });
  }
}
const getExpressbeesToken = async () => {
  const response = await axios.post(process.env.EXPRESSBEES_API_URL, {
    email: process.env.EXPRESSBEES_EMAIL,
    password: process.env.EXPRESSBEES_PASSWORD
  }, {
    headers: {
      'Content-Type': 'application/json'
    }
  });

  return response.data.data; // or .token based on your response structure
};
const apiTokenForDelhivery = (req, res) => {
  const delhiveryToken = process.env.DELHIVERY_STD;
  console.log("token for std in delivery") // Replace with actual token retrieval logic
  res.json({ token: delhiveryToken });
}
const apiCancelDelhiverystandard = async (req, res) => {
  const { lrNumber, po_number, client_id } = req.body; // Get lrNumber and po_number from request body
  console.log("LR number: " + lrNumber);
  console.log("PO number: " + po_number);
  console.log("Client ID: " + client_id);

  if (!lrNumber || !po_number) {
    return res.status(400).json({ error: 'LR number and PO number are required' });
  }

  const apiUrl = 'https://track.delhivery.com/api/p/edit';
  const token = process.env.DELHIVERY_STD; // Get the token from environment variable
  console.log("Delhivery Token: ", token); // Log the token for debugging

  const headers = {
    'Content-Type': 'application/json',
    'Authorization': `Token ${token}` // Use the token from environment variable
  };
  const requestBody = {
    "waybill": lrNumber,
    "cancellation": "true"
  };

  try {
    const response = await axios.post(apiUrl, requestBody, { headers });
    console.log("response data", response.data)

    // Check if the cancellation was successful
    if (response.data.status === true) {
      // Use the helper function to update the database
      await updateOrderStatus(po_number, client_id, lrNumber);
      return res.json(response.data);
    } else {
      return res.status(400).json({ error: 'Cancellation failed', details: response.data });
    }
  } catch (error) {
    console.error('Error cancelling LR:', error.response ? error.response.data : error.message);
    return res.status(500).json({ error: 'Failed to cancel LR' });
  }
}
const apiCancelDelhiveryLtl = async (req, res) => {
  const { lrNumber, po_number, client_id } = req.body;
  console.log("LR number: " + lrNumber);
  console.log("PO number: " + po_number);
  console.log("Client ID: " + client_id);

  if (!lrNumber || !po_number) {
    return res.status(400).json({ error: 'LR number and PO number are required' });
  }

  const apiUrl = `https://ltl-clients-api.delhivery.com/lrn/cancel/${lrNumber}`;
  const token = process.env.DELHIVERY_LTL_TOKEN; // Get token from environment variable

  const headers = {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${token}`
  };

  try {
    const response = await axios.delete(apiUrl, { headers });
    console.log("response data", response.data);

    if (response.data.success) {
      await updateOrderStatus(po_number, client_id, lrNumber);
      return res.json(response.data);
    } else {
      return res.status(400).json({ error: 'Cancellation failed', details: response.data });
    }
  } catch (error) {
    console.error('Error cancelling LR:', error.response ? error.response.data : error.message);
    return res.status(500).json({ error: 'Failed to cancel LR' });
  }
}
const apiCancelDtdcStandard = async (req, res) => {
  const { lrNumber, po_number, client_id } = req.body;
  console.log("LR number: " + lrNumber);
  console.log("PO number: " + po_number);
  console.log("Client ID: " + client_id);


  if (!lrNumber || !po_number) {
    return res.status(400).json({ error: 'LR number and PO number are required' });
  }

  const apiUrl = 'http://dtdcapi.shipsy.io/api/customer/integration/consignment/cancel';
  const apiKey = process.env.API_KEYSTD; // Get API key from environment variable
  const customerCode = process.env.CUSTOMER_CODE_STD; // Get customer code from environment variable

  const headers = {
    'Content-Type': 'application/json',
    'api-key': apiKey
  };

  const requestBody = {
    "AWBNo": [lrNumber],
    "customerCode": customerCode
  };

  try {
    const response = await axios.post(apiUrl, requestBody, { headers });
    console.log("response data", response.data);

    if (response.data.success) {
      await updateOrderStatus(po_number, client_id, lrNumber);
      return res.json(response.data);
    } else {
      return res.status(400).json({ error: 'Cancellation failed', details: response.data });
    }
  } catch (error) {
    console.error('Error cancelling LR:', error.response ? error.response.data : error.message);
    return res.status(500).json({ error: 'Failed to cancel LR' });
  }
}
const apiCancelExpressbeesStandard = async (req, res) => {
  const { lrNumber, po_number, client_id } = req.body;
  console.log("LR number: " + lrNumber);
  console.log("PO number: " + po_number);
  console.log("Client ID: " + client_id);

  if (!lrNumber || !po_number) {
    return res.status(400).json({ error: 'LR number and PO number are required' });
  }

  try {
    const expressbeeToken = await getExpressbeesToken(); // Reuse function directly

    const apiUrl = 'https://shipment.xpressbees.com/api/shipments2/cancel';
    const headers = {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${expressbeeToken}`
    };

    const requestBody = { awb: lrNumber };

    const response = await axios.post(apiUrl, requestBody, { headers });

    if (response.data.status === true || response.data.success) {
      await updateOrderStatus(po_number, client_id, lrNumber);
      return res.json(response.data);
    } else {
      return res.status(400).json({ error: 'Cancellation failed', details: response.data });
    }
  } catch (error) {
    console.error('Error cancelling LR:', error.response ? error.response.data : error.message);
    return res.status(500).json({ error: 'Failed to cancel LR' });
  }
}
const sellerDetailsClientId = async (req, res) => {
  const clientId = req.user.selectedClientId;

  try {
    // Query to get seller details using mySqlQury
    const query = 'SELECT * FROM tbl_admin WHERE id = ?';
    const rows = await mySqlQury(query, [clientId]);

    if (rows.length === 0) {
      return res.status(404).json({ error: 'Seller not found' });
    }

    // Extract required seller details
    const sellerDetails = rows[0];
    res.json({
      first_name: sellerDetails.first_name,
      last_name: sellerDetails.last_name,
      email: sellerDetails.email,
      mobile: sellerDetails.mobile,
      company_name: sellerDetails.company_name,
      company_country: sellerDetails.company_country,
      company_state: sellerDetails.company_state,
      company_city: sellerDetails.company_city,
      company_address: sellerDetails.company_address,
      pincode: sellerDetails.company_pincode,
      cst: sellerDetails.gst,
      payment_mode: sellerDetails.payment_mode
    });
  } catch (error) {
    console.error('Error fetching seller details:', error);
    res.status(500).json({ error: 'Failed to fetch seller details' });
  }
}
async function updateOrderStatus(po_number, client_id, lrNumber) {
  try {
    // Start transaction
    await mySqlQury('START TRANSACTION');

    // First update tbl_create_lr table with status = 0 for cancelled LRs
    const updateCreateLRQuery = 'UPDATE tbl_create_lr SET status = ? WHERE po_id = ?';
    const valuesCreateLR = [0, po_number]; // Fixed status = 0 for cancelled LRs
    await mySqlQury(updateCreateLRQuery, valuesCreateLR);

    console.log(`Updated po_id ${po_number} in tbl_create_lr to status = 0 (cancelled)`);

    // Check if there's an entry in tbl_lr_wallet_tnx for this LR number
    const findWalletTnxQuery = 'SELECT amount FROM tbl_lr_wallet_tnx WHERE lr_no = ?';
    const walletTnxResult = await mySqlQury(findWalletTnxQuery, [lrNumber]);

    // If we found a wallet transaction for this LR
    if (walletTnxResult && walletTnxResult.length > 0) {
      const amount = walletTnxResult[0].amount;

      // Generate date strings for transaction IDs
      const now = new Date();
      const dateString = now.getFullYear().toString() +
        (now.getMonth() + 1).toString().padStart(2, '0') +
        now.getDate().toString().padStart(2, '0') +
        now.getHours().toString().padStart(2, '0') +
        now.getMinutes().toString().padStart(2, '0') +
        now.getSeconds().toString().padStart(2, '0');

      // Insert entry into tbl_wallet_history
      const insertWalletHistoryQuery = `
          INSERT INTO tbl_wallet_history (
            user_id, amount, transaction_id, state, 
            m_transaction_id, m_id, transaction_type, 
            payment_method, pg_transaction_id, bank_transaction_id, 
            pg_authorization_code, bank_id, 
            brn, created_at, orderId
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), ?)
        `;

      const walletHistoryValues = [
        client_id,                          // user_id
        amount,                             // amount
        'Disp' + dateString,                // transaction_id
        'completed',                        // state
        'm_' + dateString,                  // m_transaction_id
        'mID' + dateString,                 // m_id
        'CREDIT',                           // transaction_type
        'cancel lr so refund by  DISPATCH',                  // payment_method
        'pg_' + dateString,                 // pg_transaction_id
        'bank_' + dateString,               // bank_transaction_id
        'pg_' + dateString,                 // pg_authorization_code
        client_id,                          // bank_id
        'LR' + lrNumber,                    // brn (using LR number as reference)
        po_number                           // orderId
      ];

      await mySqlQury(insertWalletHistoryQuery, walletHistoryValues);
      console.log(`Added refund of ${amount} to wallet history for client ${client_id} for cancelled LR ${lrNumber}`);

      // Find the latest wallet record for this client
      const findWalletQuery = 'SELECT id, total_amount FROM tbl_wallet WHERE user_id = ? ORDER BY id DESC LIMIT 1';
      const walletResult = await mySqlQury(findWalletQuery, [client_id]);

      if (walletResult && walletResult.length > 0) {
        // Calculate new total amount
        const walletId = walletResult[0].id;
        const currentAmount = parseFloat(walletResult[0].total_amount) || 0;
        const newTotalAmount = currentAmount + parseFloat(amount);

        // Update the wallet with the new total
        const updateWalletQuery = 'UPDATE tbl_wallet SET total_amount = ?, updated_at = NOW() WHERE id = ?';
        await mySqlQury(updateWalletQuery, [newTotalAmount, walletId]);

        console.log(`Updated wallet balance for client ${client_id}: ${currentAmount} + ${amount} = ${newTotalAmount}`);
      } else {
        // If wallet record doesn't exist, create a new one
        const createWalletQuery = 'INSERT INTO tbl_wallet (user_id, total_amount, created_at, updated_at) VALUES (?, ?, NOW(), NOW())';
        await mySqlQury(createWalletQuery, [client_id, amount]);

        console.log(`Created new wallet for client ${client_id} with initial balance ${amount}`);
      }
    } else {
      console.log(`No wallet transaction found for LR ${lrNumber}, no refund processed`);
    }

    // If everything was successful, commit the transaction
    await mySqlQury('COMMIT');
    console.log("Transaction committed successfully");

    return true;
  } catch (error) {
    // If anything went wrong, roll back the transaction
    await mySqlQury('ROLLBACK');
    console.log("Transaction rolled back due to error");

    console.error('Error processing cancelled LR:', error);
    throw error;
  }
}
const apiUpdateOrderStatus = async (req, res) => {
  const { po_number, status, client_id, lrNumber } = req.body; // Get po_number and status from request body
  console.log("PO number: " + po_number);
  console.log("Status: " + status);

  if (!po_number || status === undefined) {
    return res.status(400).json({ error: 'PO number and status are required' });
  }

  try {
    // Use the helper function to update the order status
    await updateOrderStatus(po_number, client_id, lrNumber);
    return res.json({ success: true, message: `Updated po_number ${po_number} to status ${status}` });
  } catch (error) {
    return res.status(500).json({ error: 'Failed to update order status' });
  }
}


async function storeLrDetailsNumbers(lr,cgst,sgst,igst,idPk,client_id,clientpaymentMode,orderNumber,payload = {},courier) {
  const {
    baserate,
    rate,
    insurance_type = null,
    volumetricWeight,
    chargableWeight,
    weight_unit,
    Aggrigator_id,
    TaggedApi,
     zones = {},
    forwarderTotalRateAndDetails = {},
    additionalCharges = {}
  } = payload;
  console.log("payload data",payload)
  // console.log("djshdjsghdjghs",shgahdhs)
 
  const total_gst = Number(cgst || 0) + Number(sgst || 0) + Number(igst || 0);
  console.log("payload data",payload)
  const base_rate = Number(baserate || 0);
  const total_additional = Number(additionalCharges.total || 0);
  const total_lr_charges = Number(rate || 0) + total_gst;
  const lr_no = lr;
  const forwarder_id = forwarderTotalRateAndDetails.forwarderId || null;
  const tagged_api = TaggedApi || forwarderTotalRateAndDetails.taggedApi || null;
  console.log("payload data",payload)
  // console.log("sajdhjsdh",djhdjsdhgsj)
  

try {
      // ðŸŸ¡ Start transaction
    await mySqlQury('START TRANSACTION');

  const insertLrQuery = `
      INSERT INTO tbl_exp_lr (
        order_id, client_id, lr_no, tagged_api,aggrigator_id,forwarder_id,
        insurance_type, volumetric_weight, chargable_weight, base_rate,
        total_additional, total_gst, total_lr_charges,
        status, eta, billing_status,
        pickup_zone, destination_zone
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;
 
    const values = [
      idPk,
      client_id,
      lr_no,
      tagged_api,
      Aggrigator_id,
      forwarder_id,
      insurance_type,
      volumetricWeight,
      chargableWeight,
      base_rate,
      total_additional,
      total_gst,
      total_lr_charges,
      1, // status
      null, // eta
      0, // billing_status
      zones.origin || null, // pickup_zone
      zones.destination || null // destination_zone
    ];
  console.log("additianl_charges",additionalCharges)
  // console.log("dsjhjf",sdghwdhghdg)

    const result = await mySqlQury(insertLrQuery, values);
    const lr_id = result.insertId;
        // Insert GST charges into tbl_exp_lr_agg_charges if not zero
    if (Number(cgst) > 0) {
      await mySqlQury(
        `INSERT INTO tbl_exp_lr_agg_charges (lr_id, charge_name, charge_value) VALUES (?, ?, ?)`,
        [lr_id, 'CGST', Number(cgst)]
      );
    }
   
    if (Number(sgst) > 0) {
      await mySqlQury(
        `INSERT INTO tbl_exp_lr_agg_charges (lr_id, charge_name, charge_value) VALUES (?, ?, ?)`,
        [lr_id, 'SGST', Number(sgst)]
      );
    }
    if (Number(igst) > 0) {
      await mySqlQury(
        `INSERT INTO tbl_exp_lr_agg_charges (lr_id, charge_name, charge_value) VALUES (?, ?, ?)`,
        [lr_id, 'IGST', Number(igst)]
      );
    }
      console.log("additianl_charges",additionalCharges)

    // Save aggregator charges
    if (additionalCharges.breakdown?.length > 0) {
      for (const charge of additionalCharges.breakdown) {
        await mySqlQury(
          `INSERT INTO tbl_exp_lr_agg_charges (lr_id, charge_name, charge_value) VALUES (?, ?, ?)`,
          [lr_id, charge.charge_name, charge.value]
        );
      }
    }

    // Save forwarder charges
    const forwarderCharges = forwarderTotalRateAndDetails.additionalCharges?.breakdown || [];
    if (forwarderCharges.length > 0) {
      for (const charge of forwarderCharges) {
        await mySqlQury(
          `INSERT INTO tbl_exp_lr_forwarder_charges (lr_id, charge_name, charge_value) VALUES (?, ?, ?)`,
          [lr_id, charge.charge_name, charge.value]
        );
      }
    }
        // ðŸšš Insert into courier-specific status tables based on courier type
        const courierLower = courier?.toLowerCase() || tagged_api?.toLowerCase();
        const currentDate = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
        const currentTime = new Date().toTimeString().slice(0, 8); // HH:MM:SS
        const currentDateTime = new Date().toISOString().slice(0, 19).replace('T', ' '); // YYYY-MM-DD HH:MM:SS
    
        if (courierLower === 'expressbees' || courierLower === 'xpressbees') {
          // Insert into ExpressBees status table
          await mySqlQury(`
            INSERT INTO tbl_exp_expressbees_status (
              lrnum, order_id, status_code, location, event_time, message, date
            ) VALUES (?, ?, ?, ?, ?, ?, ?)
          `, [
            lr_no,
            idPk,
            'MANIFESTED', // status_code
            zones.origin || 'Unknown', // location (origin)
            currentDateTime, // event_time
            'Manifested', // message
            currentDate // date
          ]);
        }
        else if (courierLower === 'dtdc') {
          // Insert into DTDC status table
          await mySqlQury(`
            INSERT INTO tbl_exp_dtdc_status (
              lrnum, order_id, strCode, strAction, strManifestNo, strOrigin, strDestination,
              strActionDate, strActionTime, strVehicleNo, strDriverName, strDriverNo,
              strDocWeight, strMfMode, strAddress, strMobileNo, strEmailID, strRemarks,
              strAttempt, strError, created_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `, [
            lr_no, // lrnum
            idPk, // order_id
            'MANIFESTED', // strCode (status code)
            'Manifested', // strAction
            lr_no, // strManifestNo (using LR as manifest number)
            zones.origin || null, // strOrigin
            zones.destination || null, // strDestination
            currentDate, // strActionDate
            currentTime, // strActionTime
            null, // strVehicleNo (unknown)
            null, // strDriverName (unknown)
            null, // strDriverNo (unknown)
            chargableWeight || volumetricWeight || null, // strDocWeight
            'Surface', // strMfMode (default to Surface)
            null, // strAddress (unknown)
            null, // strMobileNo (unknown)
            null, // strEmailID (unknown)
            'Order manifested successfully', // strRemarks
            1, // strAttempt
            null, // strError
            currentDateTime // created_at
          ]);
        }
        else if (courierLower === 'delhivery') {
          // Insert into Delhivery status table
          await mySqlQury(`
            INSERT INTO tbl_exp_delhivery_status (
              order_id, lrnum, scan_datetime, scan_type, scan, status_datetime,
              scanned_location, status_code, instructions, created_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          `, [
            idPk, // order_id
            lr_no, // lrnum
            currentDateTime, // scan_datetime
            'MANIFESTED', // scan_type
            'Order manifested successfully', // scan description
            currentDateTime, // status_datetime
            zones.origin || 'Unknown', // scanned_location
            'MANIFESTED', // status_code
            'Order has been manifested and is ready for pickup', // instructions
            currentDateTime // created_at
          ]);
        }
    // âœ… Mark order as processed
    await mySqlQury(
      `UPDATE tbl_exp_orders SET is_unprocessed = 0 WHERE id = ?`,
      [idPk]
    );
        // âœ… Wallet transaction if prepaid mode
    if (clientpaymentMode !== 'postpaid') {
      const Totalweight = Number(chargableWeight || volumetricWeight || 0);
      const unitweight = weight_unit || 'kg';

      await updateWalletAndTransaction(
        client_id,
        total_lr_charges,
        orderNumber,
        lr_no,
        zones.origin,
        zones.destination,
        `lr of ${TaggedApi}`,
        Totalweight,
        unitweight
      );
    }
    // âœ… Commit transaction
    await mySqlQury('COMMIT');

    console.log(`âœ… LR ${lr_no} saved successfully`);

  } catch (error) {
    console.error("âŒ Error saving LR and charges:", error.message);
      await mySqlQury('ROLLBACK');
    throw error; // âœ… Required to notify route handler
  }
}

async function storeLrDetailsNumbersEcom(lr,cgst,sgst,igst,idPk,client_id,clientpaymentMode,orderNumber,payload = {}) {
  const {
    baserate,
    rate,
    insurance_type = null,
    volumetricWeight,
    chargableWeight,
    weight_unit,
    Aggrigator_id,
    TaggedApi,
     zones = {},
    forwarderTotalRateAndDetails = {},
    additionalCharges = {}
  } = payload;
  console.log("payload data",payload)
  // console.log("djshdjsghdjghs",shgahdhs)
 
  const total_gst = Number(cgst || 0) + Number(sgst || 0) + Number(igst || 0);
  console.log("payload data",payload)
  const base_rate = Number(baserate || 0);
  const total_additional = Number(additionalCharges.total || 0);
  const total_lr_charges = Number(rate || 0) + total_gst;
  const lr_no = lr;
  const forwarder_id = forwarderTotalRateAndDetails.forwarderId || null;
  const tagged_api = TaggedApi || forwarderTotalRateAndDetails.taggedApi || null;
  console.log("payload data",payload)
  // console.log("sajdhjsdh",djhdjsdhgsj)
  

try {
      // ðŸŸ¡ Start transaction
    await mySqlQury('START TRANSACTION');

  const insertLrQuery = `
      INSERT INTO tbl_ecom_lr (
        order_id, client_id, lr_no, tagged_api,aggrigator_id,forwarder_id,
        insurance_type, volumetric_weight, chargable_weight, base_rate,
        total_additional, total_gst, total_lr_charges,
        status, eta, billing_status,
        pickup_zone, destination_zone
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;
 
    const values = [
      idPk,
      client_id,
      lr_no,
      tagged_api,
      Aggrigator_id,
      forwarder_id,
      insurance_type,
      volumetricWeight,
      chargableWeight,
      base_rate,
      total_additional,
      total_gst,
      total_lr_charges,
      1, // status
      null, // eta
      0, // billing_status
      zones.origin || null, // pickup_zone
      zones.destination || null // destination_zone
    ];
  console.log("additianl_charges",additionalCharges)
  // console.log("dsjhjf",sdghwdhghdg)

    const result = await mySqlQury(insertLrQuery, values);
    const lr_id = result.insertId;
        // Insert GST charges into tbl_exp_lr_agg_charges if not zero
    if (Number(cgst) > 0) {
      await mySqlQury(
        `INSERT INTO tbl_ecom_lr_agg_charges (lr_id, charge_name, charge_value) VALUES (?, ?, ?)`,
        [lr_id, 'CGST', Number(cgst)]
      );
    }
   
    if (Number(sgst) > 0) {
      await mySqlQury(
        `INSERT INTO tbl_ecom_lr_agg_charges (lr_id, charge_name, charge_value) VALUES (?, ?, ?)`,
        [lr_id, 'SGST', Number(sgst)]
      );
    }
    if (Number(igst) > 0) {
      await mySqlQury(
        `INSERT INTO tbl_ecom_lr_agg_charges (lr_id, charge_name, charge_value) VALUES (?, ?, ?)`,
        [lr_id, 'IGST', Number(igst)]
      );
    }
      console.log("additianl_charges",additionalCharges)

    // Save aggregator charges
    if (additionalCharges.breakdown?.length > 0) {
      for (const charge of additionalCharges.breakdown) {
        await mySqlQury(
          `INSERT INTO tbl_ecom_lr_agg_charges (lr_id, charge_name, charge_value) VALUES (?, ?, ?)`,
          [lr_id, charge.charge_name, charge.value]
        );
      }
    }

    // Save forwarder charges
    const forwarderCharges = forwarderTotalRateAndDetails.additionalCharges?.breakdown || [];
    if (forwarderCharges.length > 0) {
      for (const charge of forwarderCharges) {
        await mySqlQury(
          `INSERT INTO tbl_ecom_lr_forwarder_charges (lr_id, charge_name, charge_value) VALUES (?, ?, ?)`,
          [lr_id, charge.charge_name, charge.value]
        );
      }
    }
    // âœ… Mark order as processed
    await mySqlQury(
      `UPDATE tbl_ecom_orders SET is_unprocessed = 0 WHERE id = ?`,
      [idPk]
    );
        // âœ… Wallet transaction if prepaid mode
    if (clientpaymentMode !== 'postpaid') {
      const Totalweight = Number(chargableWeight || volumetricWeight || 0);
      const unitweight = weight_unit || 'kg';

      await updateWalletAndTransaction(
        client_id,
        total_lr_charges,
        orderNumber,
        lr_no,
        zones.origin,
        zones.destination,
        `lr of ${TaggedApi}`,
        Totalweight,
        unitweight
      );
    }
    // âœ… Commit transaction
    await mySqlQury('COMMIT');

    console.log(`âœ… LR ${lr_no} saved successfully`);

  } catch (error) {
    console.error("âŒ Error saving LR and charges:", error.message);
      await mySqlQury('ROLLBACK');
    throw error; // âœ… Required to notify route handler
  }
}

const delhiveryShipingLabelLinks = async (req, res) => {
  try {
    const { apiUrl, token, awbNo } = req.query;

    // Fetch label URLs from the provided API
    let urls = await axios.get(apiUrl, { headers: { Authorization: `Bearer ${token}` } });

    // Check if the response is structured as expected
    if (urls.data && Array.isArray(urls.data.data)) {
      const imagePromises = urls.data.data.map((url, i) =>
        axios.get(url, { headers: { Authorization: token } })
          .then(response => {
            if (response.status === 200 && response.data.data) {
              const base64Data = response.data.data.split(',')[1];
              if (!base64Data) throw new Error('Base64 string is missing.');

              // Extract AWB number from the response
              // const awbNo = response.data.awbNo || `unknown_${i + 1}`;

              // Define the directory for storing the label files
              const outputDir = path.join(__dirname, 'assets', awbNo);

              // Ensure the respective folder exists
              if (!fs.existsSync(outputDir)) {
                fs.mkdirSync(outputDir, { recursive: true }); // Create the folder if it doesn't exist
              }

              // Normalize the output path for the label file
              const outputPath = path.join(outputDir, `label_${i + 1}.png`);

              // Save the image to the respective folder
              fs.writeFileSync(outputPath, base64Data, 'base64');

              // Return the image URL that the browser can use
              return {
                imageUrl: `/assets/${awbNo}/label_${i + 1}.png`
              };
            } else {
              throw new Error('Invalid API response.');
            }
          })
      );

      const imageResults = await Promise.all(imagePromises);

      // Send response after all images have been processed
      res.json({ success: true, data: imageResults });
    } else {
      // Handle the case where the response is not in the expected format
      throw new Error('Expected a structure like { success: true, data: [ ... ] }, but got: ' + JSON.stringify(urls.data));
    }

  } catch (err) {
    console.error('Error fetching or saving labels:', err);
    res.status(500).json({ success: false, message: 'Failed to process labels', error: err.message });
  }
}
const delhiveryStandardLabel = async (req, res) => {
  try {
    const { awbNo } = req.query;
    const token = process.env.DELHIVERY_STD;

    // Make the request to Delhivery API with pdf=true parameter
    const response = await axios({
      method: 'get',
      url: `https://track.delhivery.com/api/p/packing_slip?wbns=${awbNo}&pdf=true`,
      headers: {
        'Authorization': `Token ${token}`,
        'Content-Type': 'application/json'
      },
      timeout: 10000
    });

    // Check if we have valid data
    if (response.data && response.data.packages && response.data.packages[0]) {
      res.json({
        success: true,
        pdfUrl: response.data.packages[0].pdf_download_link,
        pdfEncoding: response.data.packages[0].pdf_encoding
      });
    } else {
      res.status(400).json({
        success: false,
        message: 'No valid package data found'
      });
    }
  } catch (error) {
    console.error('Error fetching Delhivery label:', error.response?.data || error.message);

    res.status(error.response?.status || 500).json({
      success: false,
      message: error.response?.data?.message || 'Failed to fetch shipping label',
      error: error.message
    });
  }
}
const delhiveryPincodeCheck = async (req, res) => {
  const { pincode } = req.query; // Get the pincode from the query parameters

  // const { pincode } = req.query; // Get the pincode from the query parameters


  try {
    // Step 1: Check the pincode with Delhivery API
    const delhiveryToken = process.env.DELHIVERY_STD; // Replace with your actual token
    const delhiveryResponse = await axios.get(`https://track.delhivery.com/c/api/pin-codes/json/?token=${delhiveryToken}&filter_codes=${pincode}`, {
      headers: {
        'Accept': 'application/json'
      }
    });
    const deliveryCodes = delhiveryResponse.data.delivery_codes;

    // Check if deliveryCodes is an array and has at least one entry
    const isServiceable = Array.isArray(deliveryCodes) && deliveryCodes.length > 0;



    if (!isServiceable) {
      return res.json({
        serviceable: false,
        message: 'Pincode is not serviceable by Delhivery.'
      });
    }

    // Step 2: Check the pincode in your local database
    const sql = 'SELECT * FROM pincode_serviceability_delhivery WHERE pincode = ?'; // Adjust the query as needed
    const results = await mySqlQury(sql, [pincode]);

    if (results.length > 0) {
      // If the pincode is serviceable in the local database
      return res.json({
        serviceable: true,
        destinationPincode: pincode // Send the destination pincode back
      });
    } else {
      // If the pincode is not serviceable in the local database, insert it
      const insertSql = 'INSERT INTO pincode_serviceability_delhivery (pincode) VALUES (?)'; // Adjust the query as needed
      await mySqlQury(insertSql, [pincode]);

      return res.json({
        serviceable: true,
        message: 'Pincode is serviceable by Delhivery and has been added to the local database.',
        destinationPincode: pincode // Send the destination pincode back
      });
    }
  } catch (error) {
    console.error('Error checking pincode:', error);
    res.status(500).json({
      error: 'Internal Server Error',
      message: error.message // Include the error message from the caught exception
    });
  }
}
const deliveryLtlPincodeCheck = async (req, res) => {
  const { pincode } = req.query; // Get the pincode from the query parameters

  try {
    // Step 1: Check the pincode with Delhivery LTL API
    const delhiveryToken = await getValidDeliveryApiToken(); // Replace with your actual token
    const delhiveryResponse = await axios.get(`https://ltl-clients-api.delhivery.com/pincode-service/${pincode}?weight=1`, {
      headers: {
        'Authorization': `Bearer ${delhiveryToken}`,
        'Accept': 'application/json'
      }
    });
    console.log("pincode is not servisible", delhiveryResponse.data)

    // Check if the response indicates serviceability
    const isServiceable = delhiveryResponse.data.success; // Adjust based on the actual response structure

    if (!isServiceable) {
      return res.json({
        success: false,
        message: 'Pincode is not serviceable by Delhivery LTL.'
      });
    }

    // Step 2: Check the pincode in your local database
    const sql = 'SELECT * FROM tbl_delivery_ltl WHERE Pin = ?'; // Adjust the query as needed
    const results = await mySqlQury(sql, [pincode]);

    if (results.length > 0) {
      // If the pincode is serviceable in the local database
      return res.json({
        success: true,
        serviceable: true,
        destinationPincode: pincode // Send the destination pincode back
      });
    } else {
      // If the pincode is not serviceable in the local database, insert it
      const insertSql = 'INSERT INTO tbl_delivery_ltl (pincode) VALUES (?)'; // Adjust the query as needed
      await mySqlQury(insertSql, [pincode]);

      return res.json({
        success: true,
        serviceable: true,
        message: 'Pincode is serviceable by Delhivery LTL and has been added to the local database.',
        destinationPincode: pincode // Send the destination pincode back
      });
    }
  } catch (error) {
    console.error('Error checking pincode:', error);
    res.status(500).json({
      success: false,
      error: 'Internal Server Error',
      message: error.message // Include the error message from the caught exception
    });
  }
}
const expressbeesPincodeCheck = async (req, res) => {
  const { origin, destination } = req.query;
  console.log("checking pincode for expressbees", origin, destination);
  // Get both origin and destination pincodes from the query parameters

  try {
    // Step 1: Check the serviceability with Express Bees API
    const expressBeesToken = await fetchExpressBeesToken();
    if (!expressBeesToken) {
      console.error("âŒ Failed to fetch ExpressBees token");
      return res.status(500).json({
        error: "Failed to authenticate with ExpressBees API",
        errorType: 'authentication_error',
        suggestion: "Please check ExpressBees API credentials or try again later"
      });
    }
    console.log("âœ… ExpressBees token obtained successfully:", expressBeesToken.substring(0, 10) + '...') // Replace with your actual token
    const expressBeesResponse = await axios.post('https://shipment.xpressbees.com/api/courier/serviceability', {
      origin: origin,
      destination: destination,
      payment_type: "cod", // Adjust as needed
      order_amount: "999", // Adjust as needed
      weight: "600", // Adjust as needed
      length: "10", // Adjust as needed
      breadth: "10", // Adjust as needed
      height: "10" // Adjust as needed
    }, {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${expressBeesToken}`
      }
    });
    console.log("respionse", expressBeesResponse)

    const serviceable = expressBeesResponse.status; // Adjust based on the actual response structure

    if (!serviceable) {
      return res.json({
        serviceable: false,
        message: 'One or both pincodes are not serviceable by Express Bees.'
      });
    }

    // Step 2: Check the origin pincode in your local database
    const sql = 'SELECT * FROM xpressbees_pin_serv WHERE Pincode = ?'; // Adjust the query as needed
    const originResults = await mySqlQury(sql, [origin]);
    const destinationResults = await mySqlQury(sql, [destination]);

    // Check if origin pincode is serviceable in the local database
    if (originResults.length > 0) {
      // If the origin pincode is serviceable in the local database
      return res.json({
        serviceable: true,
        originPincode: origin // Send the origin pincode back
      });
    } else {
      // If the origin pincode is not serviceable in the local database, insert it
      const insertSql = 'INSERT INTO xpressbees_pin_serv (Pincode) VALUES (?)'; // Adjust the query as needed
      await mySqlQury(insertSql, [origin]);
    }

    // Check if destination pincode is serviceable in the local database
    if (destinationResults.length > 0) {
      // If the destination pincode is serviceable in the local database
      return res.json({
        serviceable: true,
        destinationPincode: destination // Send the destination pincode back
      });
    } else {
      // If the destination pincode is not serviceable in the local database, insert it
      const insertSql = 'INSERT INTO xpressbees_pin_serv (Pincode) VALUES (?)'; // Adjust the query as needed
      await mySqlQury(insertSql, [destination]);
    }

    return res.json({
      serviceable: true,
      message: 'Both pincodes are serviceable by Express Bees and have been added to the local database.',
      originPincode: origin,
      destinationPincode: destination
    });
  } catch (error) {
    console.error('Error checking pincodes:', error);
    res.status(500).json({
      error: 'Internal Server Error',
      message: error.message // Include the error message from the caught exception
    });
  }
}
const dtdcPincodeCheck = async (req, res) => {
  const { origin, destination } = req.query; // Get both origin and destination pincodes from the query parameters

  try {
    // Step 1: Check the origin pincode in your local database
    const originSql = 'SELECT * FROM tbl_dtdc_ltl WHERE pincode = ?'; // Adjust the query as needed
    const originResults = await mySqlQury(originSql, [origin]);

    // Check if origin pincode is serviceable in the local database
    if (originResults.length === 0) {
      return res.json({
        serviceable: false,
        message: 'Origin pincode is not serviceable by DTDC.'
      });
    }

    // Step 2: Check the destination pincode in your local database
    const destinationSql = 'SELECT * FROM tbl_dtdc_ltl WHERE pincode = ?'; // Adjust the query as needed
    const destinationResults = await mySqlQury(destinationSql, [destination]);

    // Check if destination pincode is serviceable in the local database
    if (destinationResults.length === 0) {
      return res.json({
        serviceable: false,
        message: 'Destination pincode is not serviceable by DTDC.'
      });
    }

    // If both pincodes are serviceable
    return res.json({
      serviceable: true,
      message: 'Both origin and destination pincodes are serviceable by DTDC.',
      originPincode: origin,
      destinationPincode: destination
    });
  } catch (error) {
    console.error('Error checking pincodes:', error);
    res.status(500).json({
      error: 'Internal Server Error',
      message: error.message // Include the error message from the caught exception
    });
  }
}

const createOrderNew = async (req, res, next) => {
  try {
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;

    let loginDetails = null;
    let clientId = 0;
    let walletBalance = 0;
    let vasService = 0;
    console.log("req user", req.user)

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,vas,company_name,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      console.log("login details", relatedClientId, loginDetails);

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];

      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    const lang_data = req.language_data;
    const language_name = req.lang;
    const clients = await mySqlQury(`SELECT id, company_name FROM tbl_admin`);

    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = '${role_data.id}' ORDER BY id DESC LIMIT 3`
    );

    // Get active topics
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const commodities = await mySqlQury(`SELECT COMMODITY_NAME FROM commodities`);
    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Extract active topic IDs
    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    }
    console.log("client id in craete order", clientId)
    // Render the apps/create-order template and pass all the data
    res.render('pages/create-order-new', {
      title: 'create-order',
      bodyClass: 'profile-page',
      activePage: 'profile',
      role_data: role_data,
      lang_data: lang_data,
      language_name: language_name,
      notification_data: notification_data,
      clients,
      commodities,
      activeTopicIds,
      loginDetails,
      profile,
      clientId,
      walletBalance,
      vasService
    });

  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
}
const apiClients = async (req, res) => {
  try {
    const clients = await mySqlQury(`SELECT id, company_name FROM tbl_admin`);
    res.json(clients);
  } catch (error) {
    console.error('Error fetching clients:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
}
const preDispatchapiLocationId = async (req, res) => {

  const { id } = req.params;
  console.log('predispatch location', id);
  try {
    const sql = 'SELECT * FROM tbl_add_warehouse WHERE serial = ?'; // Serial is the primary key
    const [location] = await mySqlQury(sql, [id]); // Use mySqlQury function to execute the query

    if (location) {
      res.json(location);
    } else {
      res.status(404).send('Location not found');
    }
  } catch (error) {
    console.error('Error fetching location details:', error);
    res.status(500).send('Internal Server Error');
  }
}
const getWarehouseAddress = async (req, res) => {
  try {
    const clientId = req.query.clientId; // Get the clientId from the query parameters
    let sql = 'SELECT * FROM tbl_add_warehouse'; // Base SQL query

    // If a clientId is provided, filter the results
    if (clientId) {
      sql += ' WHERE client_id = ?'; // Assuming client_id is the column name in your table
    }

    const addresses = await mySqlQury(sql, [clientId]); // Pass clientId as a parameter to prevent SQL injection

    if (!addresses || addresses.length === 0) {
      return res.json({
        allAddresses: [],
        filteredAddresses: [],
        totalItems: 0
      });
    }

    res.json({
      allAddresses: addresses,
      filteredAddresses: addresses, // Assuming no filter at first
      totalItems: addresses.length
    });
  } catch (error) {
    console.error('Error fetching addresses:', error);
    res.status(500).send('Internal Server Error');
  }
}
const ltlReadyToDispatchLr = async (req, res) => {
  try {
    let result;
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;

    let loginDetails = null;
    let clientId = 0;
    let walletBalance = 0;
    let vasService = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,vas,company_name,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

      // Get LR data with client company name and bidding total_rate filtered by client_id
      result = await mySqlQury(
        `SELECT lr.*, bid.total_rate, c.company_name, uo.consignee_phone,uo.consignee_alternate_mobile
           FROM tbl_create_lr lr
           LEFT JOIN tbl_aggrigator_bidding bid ON lr.lr_No = bid.lr_No 
           LEFT JOIN tbl_admin c ON lr.client_id = c.id
           LEFT JOIN tbl_unprocessed_order uo ON lr.client_id = uo.client_id
           WHERE lr.status = 1 AND lr.client_id = ? 
           ORDER BY lr.lr_id DESC`,
        [clientId]
      );

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;

      // Get all LR data and bidding total_rate for admin
      result = await mySqlQury(
        `SELECT lr.*, bid.total_rate, c.company_name, uo.consignee_phone,uo.consignee_alternate_mobile
           FROM tbl_create_lr lr
           LEFT JOIN tbl_aggrigator_bidding bid ON lr.lr_No = bid.lr_No 
           LEFT JOIN tbl_admin c ON lr.client_id = c.id
           LEFT JOIN tbl_unprocessed_order uo ON lr.client_id = uo.client_id
           WHERE lr.status = 1 
           ORDER BY lr.lr_id DESC`
      );
    }

    // Get active topics
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Extract active topic IDs
    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    }

    let apiLTL = process.env.API_KEYLTL;
    let apistd = process.env.API_KEYSTD;

    // console.log("results of the data in ready to dispatch",result)
    console.log("result length", result.length)
    const uniqueResults = [];
    const lrMap = new Map();

    result.forEach(item => {
      if (!lrMap.has(item.lr_No)) {
        lrMap.set(item.lr_No, true);
        uniqueResults.push(item);
      }
    });

    result = uniqueResults;
    console.log("length of the unique results", result.length)
    // console.log("result of the data in ready to dispatch",result)
    // console.log("result of the data in ready to dispatch",result[0].lr_No)
    // console.log("result of the data in ready to dispatch",result[0].lr_No)


    // Render the EJS template
    res.render('pages/ltl/ready_to_dispatch_assinged_lr', {
      title: 'Ready To Dispatch Orders',
      bodyClass: 'profile-page',
      activePage: 'profile',
      result: result,
      loginDetails: loginDetails || {}, // Provide empty object as fallback
      apiLTL,
      role_data,
      activeTopicIds,
      profile,
      apiSTD: apistd,
      clientId,
      walletBalance,
      vasService
    });

  } catch (error) {
    console.error('Error:', error);

    // Send JSON response if the error view doesn't exist
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
}


const ltlOrderInTransit = async (req, res, next) => {
  try {
    console.log('in unprocessed orders')
    const accessdata = await access(req.user);
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1; // Get clientId from auth token
    const lang_data = req.language_data;
    const language_name = req.lang;
    const notification_data = await mySqlQury(`SELECT * FROM tbl_notification WHERE received = '${role_data.id}' ORDER BY id DESC LIMIT 3`);

    let loginDetails = null; // Initialize as null
    let clientId = 0;
    let result;
    let walletBalance = 0;
    let vasService = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,vas,company_name,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

      // Get all LR data and bidding total_rate for admin
      // Get LR data and bidding total_rate filtered by client_id
      result = await mySqlQury(
        `SELECT lr.*, bid.total_rate, c.company_name, uo.consignee_phone
           FROM tbl_create_lr lr
           LEFT JOIN tbl_aggrigator_bidding bid ON lr.lr_No = bid.lr_No 
           LEFT JOIN tbl_admin c ON lr.client_id = c.id
           LEFT JOIN tbl_unprocessed_order uo ON lr.client_id = uo.client_id
           WHERE lr.status = 3 AND lr.client_id = ? 
           ORDER BY lr.lr_id DESC`,
        [clientId]
      );

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
      // Get all LR data and bidding total_rate for admin
      result = await mySqlQury(
        `SELECT lr.*, bid.total_rate, c.company_name, uo.consignee_phone
           FROM tbl_create_lr lr
           LEFT JOIN tbl_aggrigator_bidding bid ON lr.lr_No = bid.lr_No 
           LEFT JOIN tbl_admin c ON lr.client_id = c.id
           LEFT JOIN tbl_unprocessed_order uo ON lr.client_id = uo.client_id
           WHERE lr.status = 3 
           ORDER BY lr.lr_id DESC`
      );
    }

    // Get active topics
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Extract active topic IDs
    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    }

    let apiLTL = process.env.API_KEYLTL;
    let apistd = process.env.API_KEYSTD;
    const uniqueResults = [];
    const lrMap = new Map();

    result.forEach(item => {
      if (!lrMap.has(item.lr_No)) {
        lrMap.set(item.lr_No, true);
        uniqueResults.push(item);
      }
    });

    result = uniqueResults;
    console.log("length of the unique results", result.length)
    console.log("length of the unique results", result.length)

    res.render('pages/ltl/order-in-transit', {
      bodyClass: 'profile-page',
      activePage: 'profile',
      result: result,
      loginDetails: loginDetails || {}, // Provide empty object as fallback
      apiLTL,
      role_data,
      accessdata,
      lang_data,
      language_name,
      notification_data,
      activeTopicIds,
      profile,
      apiSTD: apistd,
      clientId,
      walletBalance,
      vasService,
      role
    });

  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
}
//express postdispatch
const expressOrderInTransit = async (req, res) => {
  try {
    const roleData = req.user || {};
    const selectedClientId = Number(roleData.selectedClientId || 1);

    // Wallet should reflect the "view" context:
    // - If Admin (selectedClientId === 1), show admin's wallet (req.user.id)
    // - Else show that client's wallet
    const walletOwnerId = selectedClientId === 1 ? Number(roleData.id) : selectedClientId;
    const [walletRow] = await mySqlQury(
      `SELECT total_amount FROM tbl_wallet WHERE user_id = ?`,
      [walletOwnerId]
    );
    const walletBalance = walletRow ? Number(walletRow.total_amount) : 0;

    // Base query (no client filter yet). Only one query string that we mutate.
    // NOTE: Keep only the columns you actually need in the EJS to avoid over-fetching.
    let query = `
      SELECT
        lr.id,
        lr.lr_no,
        lr.client_id,
        lr.order_id,
        lr.forwarder_id,
        lr.tagged_api,
        lr.aggrigator_id,
        lr.volumetric_weight,
        lr.chargable_weight,
        lr.base_rate,
        lr.total_additional,
        lr.total_gst,
        lr.total_lr_charges,
        lr.status,
        lr.eta,
        lr.billing_status,
        lr.created_at,

        c.company_name,

        cd.first_name      AS consignee_first_name,
        cd.last_name       AS consignee_last_name,
        cd.email           AS consignee_email,
        cd.phone           AS consignee_phone,
        cd.alternate_phone AS consignee_alternate_mobile,
        cd.address_line1   AS consignee_address1,
        cd.address_line2   AS consignee_address2,
        cd.landmark        AS consignee_landmark,
        cd.city            AS consignee_city,
        cd.state           AS consignee_state,
        cd.country         AS consignee_country,
        cd.pincode         AS consignee_pincode,
        cd.billing_same_as_shipping,

        w.warehouse_name,
        w.warehouse_city,
        w.warehouse_address,
        w.warehouse_contact_person,
        w.warehouse_pincode,
        w.warehouse_state,
        w.warehouse_person,

        courier.productType AS forwarder_product_type,

        o.orderid,
        o.created_at        AS order_date,
        o.payment_mode,
        o.grand_total,
        o.collectable_amount
      FROM tbl_exp_lr lr
      LEFT JOIN tbl_admin                 c        ON lr.client_id = c.id
      LEFT JOIN tbl_exp_consignee_details cd      ON lr.order_id = cd.order_id
      LEFT JOIN tbl_exp_orders            o       ON lr.order_id = o.id
      LEFT JOIN tbl_add_warehouse          w       ON o.warehouse_id = w.serial
      LEFT JOIN tbl_courier_details        courier ON lr.forwarder_id = courier.id
      WHERE lr.status = 3
    `;

    // Parameters array will grow only if we add client filter
    const params = [];

    // If not admin view, filter by client
    if (selectedClientId !== 1) {
      query += ` AND lr.client_id = ?`;
      params.push(selectedClientId);
    }

    // Sort once
    query += ` ORDER BY lr.id DESC`;

    console.log("ðŸ” [ecomOutForDelivery] Running query with params:", params);
    const result = await mySqlQury(query, params);
    console.log("ðŸ“¦ [ecomOutForDelivery] Rows:", Array.isArray(result) ? result.length : 0);

    // Render ONLY the values you asked for
    res.render('pages/express/order-In-transit', {
      title: 'Ready To Dispatch Orders',
      bodyClass: 'profile-page',
      activePage: 'profile',
      result,
      walletBalance
    });

  } catch (error) {
    console.error('âŒ [ecomOutForDelivery] Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
};
const expressAllData = async (req, res) => {
  try {
    const roleData = req.user || {};
    const selectedClientId = Number(roleData.selectedClientId);

    // Wallet should reflect the "view" context:
    // - If Admin (selectedClientId === 1), show admin's wallet (req.user.id)
    // - Else show that client's wallet
   

    // Base query (no client filter yet). Only one query string that we mutate.
    // NOTE: Keep only the columns you actually need in the EJS to avoid over-fetching.
    let query = `
      SELECT
        lr.id,
        lr.lr_no,
        lr.client_id,
        lr.order_id,
        lr.forwarder_id,
        lr.tagged_api,
        lr.aggrigator_id,
        lr.volumetric_weight,
        lr.chargable_weight,
        lr.base_rate,
        lr.total_additional,
        lr.total_gst,
        lr.total_lr_charges,
        lr.status,
        lr.eta,
        lr.billing_status,
        lr.created_at,

        c.company_name,

        cd.first_name      AS consignee_first_name,
        cd.last_name       AS consignee_last_name,
        cd.email           AS consignee_email,
        cd.phone           AS consignee_phone,
        cd.alternate_phone AS consignee_alternate_mobile,
        cd.address_line1   AS consignee_address1,
        cd.address_line2   AS consignee_address2,
        cd.landmark        AS consignee_landmark,
        cd.city            AS consignee_city,
        cd.state           AS consignee_state,
        cd.country         AS consignee_country,
        cd.pincode         AS consignee_pincode,
        cd.billing_same_as_shipping,

        w.warehouse_name,
        w.warehouse_city,
        w.warehouse_address,
        w.warehouse_contact_person,
        w.warehouse_pincode,
        w.warehouse_state,
        w.warehouse_person,

        courier.productType AS forwarder_product_type,

        o.orderid,
        o.created_at   AS order_date,
        o.payment_mode,
        o.grand_total,
        o.collectable_amount
      FROM tbl_exp_lr lr
      LEFT JOIN tbl_admin c ON lr.client_id = c.id
      LEFT JOIN tbl_exp_consignee_details cd ON lr.order_id = cd.order_id
      LEFT JOIN tbl_exp_orders o ON lr.order_id = o.id
      LEFT JOIN tbl_add_warehouse w ON o.warehouse_id = w.serial
      LEFT JOIN tbl_courier_details        courier ON lr.forwarder_id = courier.id
    `;

    // Parameters array will grow only if we add client filter
    const params = [];
    console.log("type of the client id",typeof selectedClientId,selectedClientId)
    

    // If not admin view, filter by client
    if (selectedClientId != 1) {
      console.log("here selected client id incondition")
      query += ` WHERE lr.client_id = ?`;
      params.push(selectedClientId);
    }

    // Sort once
    query += ` ORDER BY lr.id DESC`;

    console.log("ðŸ” [ecomOutForDelivery] Running query with params:", params);
    const result = await mySqlQury(query, params);
    console.log("ðŸ“¦ [ecomOutForDelivery] Rows:", Array.isArray(result) ? result.length : 0);

    // Render ONLY the values you asked for
    res.render('pages/all-data', {
      title: 'Ready To Dispatch Orders',
      bodyClass: 'profile-page',
      activePage: 'profile',
      segment: 'express',
      result
     
    });

  } catch (error) {
    console.error('âŒ [ecomOutForDelivery] Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
};
const ecomAllData = async (req, res) => {
  try {
    const roleData = req.user || {};
    const selectedClientId = Number(roleData.selectedClientId);

    // Wallet should reflect the "view" context:
    // - If Admin (selectedClientId === 1), show admin's wallet (req.user.id)
    // - Else show that client's wallet
    
    // const [walletRow] = await mySqlQury(
    //   `SELECT total_amount FROM tbl_wallet WHERE user_id = ?`,
    //   [selectedClientId]
    // );
    // const walletBalance = walletRow ? Number(walletRow.total_amount) : 0;

    // Base query (no client filter yet). Only one query string that we mutate.
    // NOTE: Keep only the columns you actually need in the EJS to avoid over-fetching.
    let query = `
      SELECT
        lr.id,
        lr.lr_no,
        lr.client_id,
        lr.order_id,
        lr.forwarder_id,
        lr.tagged_api,
        lr.aggrigator_id,
        lr.volumetric_weight,
        lr.chargable_weight,
        lr.base_rate,
        lr.total_additional,
        lr.total_gst,
        lr.total_lr_charges,
        lr.status,
        lr.eta,
        lr.billing_status,
        lr.created_at,

        c.company_name,

        cd.first_name      AS consignee_first_name,
        cd.last_name       AS consignee_last_name,
        cd.email           AS consignee_email,
        cd.phone           AS consignee_phone,
        cd.alternate_phone AS consignee_alternate_mobile,
        cd.address_line1   AS consignee_address1,
        cd.address_line2   AS consignee_address2,
        cd.landmark        AS consignee_landmark,
        cd.city            AS consignee_city,
        cd.state           AS consignee_state,
        cd.country         AS consignee_country,
        cd.pincode         AS consignee_pincode,
        cd.billing_same_as_shipping,

        w.warehouse_name,
        w.warehouse_city,
        w.warehouse_address,
        w.warehouse_contact_person,
        w.warehouse_pincode,
        w.warehouse_state,
        w.warehouse_person,

        courier.productType AS forwarder_product_type,

        o.orderid,
        o.created_at        AS order_date,
        o.payment_mode,
        o.grand_total,
        o.collectable_amount
      FROM tbl_ecom_lr lr
      LEFT JOIN tbl_admin c ON lr.client_id = c.id
      LEFT JOIN tbl_ecom_consignee_details cd  ON lr.order_id = cd.order_id
      LEFT JOIN tbl_ecom_orders o ON lr.order_id = o.id
      LEFT JOIN tbl_add_warehouse w ON o.warehouse_id = w.serial
      LEFT JOIN tbl_courier_details courier ON lr.forwarder_id = courier.id
    `;

    // Parameters array will grow only if we add client filter
    const params = [];
    console.log("type of the client id",typeof selectedClientId,selectedClientId)
    

    // If not admin view, filter by client
    if (selectedClientId != 1) {
      console.log("here selected client id incondition")
      query += ` WHERE lr.client_id = ?`;
      params.push(selectedClientId);
    }

    // Sort once
    query += ` ORDER BY lr.id DESC`;

    console.log("ðŸ” [ecomOutForDelivery] Running query with params:", params);
    const result = await mySqlQury(query, params);
    console.log("ðŸ“¦ [ecomOutForDelivery] Rows:", Array.isArray(result) ? result.length : 0);

    // Render ONLY the values you asked for
    res.render('pages/all-data', {
      title: 'Ready To Dispatch Orders',
      bodyClass: 'profile-page',
      activePage: 'profile',
      segment: 'ecom',
      result,
      
    });

  } catch (error) {
    console.error('âŒ [ecomOutForDelivery] Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
};
const expressOutForDelivery = async (req, res) => {
  try {
    const roleData = req.user || {};
    const selectedClientId = Number(roleData.selectedClientId || 1);

    // Wallet should reflect the "view" context:
    // - If Admin (selectedClientId === 1), show admin's wallet (req.user.id)
    // - Else show that client's wallet
    const walletOwnerId = selectedClientId === 1 ? Number(roleData.id) : selectedClientId;
    const [walletRow] = await mySqlQury(
      `SELECT total_amount FROM tbl_wallet WHERE user_id = ?`,
      [walletOwnerId]
    );
    const walletBalance = walletRow ? Number(walletRow.total_amount) : 0;

    // Base query (no client filter yet). Only one query string that we mutate.
    // NOTE: Keep only the columns you actually need in the EJS to avoid over-fetching.
    let query = `
      SELECT
        lr.id,
        lr.lr_no,
        lr.client_id,
        lr.order_id,
        lr.forwarder_id,
        lr.tagged_api,
        lr.aggrigator_id,
        lr.volumetric_weight,
        lr.chargable_weight,
        lr.base_rate,
        lr.total_additional,
        lr.total_gst,
        lr.total_lr_charges,
        lr.status,
        lr.eta,
        lr.billing_status,
        lr.created_at,

        c.company_name,

        cd.first_name      AS consignee_first_name,
        cd.last_name       AS consignee_last_name,
        cd.email           AS consignee_email,
        cd.phone           AS consignee_phone,
        cd.alternate_phone AS consignee_alternate_mobile,
        cd.address_line1   AS consignee_address1,
        cd.address_line2   AS consignee_address2,
        cd.landmark        AS consignee_landmark,
        cd.city            AS consignee_city,
        cd.state           AS consignee_state,
        cd.country         AS consignee_country,
        cd.pincode         AS consignee_pincode,
        cd.billing_same_as_shipping,

        w.warehouse_name,
        w.warehouse_city,
        w.warehouse_address,
        w.warehouse_contact_person,
        w.warehouse_pincode,
        w.warehouse_state,
        w.warehouse_person,

        courier.productType AS forwarder_product_type,

        o.orderid,
        o.created_at        AS order_date,
        o.payment_mode,
        o.grand_total,
        o.collectable_amount
      FROM tbl_exp_lr lr
      LEFT JOIN tbl_admin                 c        ON lr.client_id = c.id
      LEFT JOIN tbl_exp_consignee_details cd      ON lr.order_id = cd.order_id
      LEFT JOIN tbl_exp_orders            o       ON lr.order_id = o.id
      LEFT JOIN tbl_add_warehouse          w       ON o.warehouse_id = w.serial
      LEFT JOIN tbl_courier_details        courier ON lr.forwarder_id = courier.id
      WHERE lr.status = 8
    `;

    // Parameters array will grow only if we add client filter
    const params = [];

    // If not admin view, filter by client
    if (selectedClientId !== 1) {
      query += ` AND lr.client_id = ?`;
      params.push(selectedClientId);
    }

    // Sort once
    query += ` ORDER BY lr.id DESC`;

    console.log("ðŸ” [ecomOutForDelivery] Running query with params:", params);
    const result = await mySqlQury(query, params);
    console.log("ðŸ“¦ [ecomOutForDelivery] Rows:", Array.isArray(result) ? result.length : 0);

    // Render ONLY the values you asked for
    res.render('pages/express/out-for-delivery', {
      title: 'Ready To Dispatch Orders',
      bodyClass: 'profile-page',
      activePage: 'profile',
      result,
      walletBalance
    });

  } catch (error) {
    console.error('âŒ [ecomOutForDelivery] Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
};
const expressReadyToDispatch = async (req, res) => {
  try {
    const roleData = req.user || {};
    const selectedClientId = Number(roleData.selectedClientId || 1);

    // Wallet should reflect the "view" context:
    // - If Admin (selectedClientId === 1), show admin's wallet (req.user.id)
    // - Else show that client's wallet
    const walletOwnerId = selectedClientId === 1 ? Number(roleData.id) : selectedClientId;
    const [walletRow] = await mySqlQury(
      `SELECT total_amount FROM tbl_wallet WHERE user_id = ?`,
      [walletOwnerId]
    );
    const walletBalance = walletRow ? Number(walletRow.total_amount) : 0;

    // Base query (no client filter yet). Only one query string that we mutate.
    // NOTE: Keep only the columns you actually need in the EJS to avoid over-fetching.
    let query = `
      SELECT
        lr.id,
        lr.lr_no,
        lr.client_id,
        lr.order_id,
        lr.forwarder_id,
        lr.tagged_api,
        lr.aggrigator_id,
        lr.volumetric_weight,
        lr.chargable_weight,
        lr.base_rate,
        lr.total_additional,
        lr.total_gst,
        lr.total_lr_charges,
        lr.status,
        lr.eta,
        lr.billing_status,
        lr.created_at,

        c.company_name,

        cd.first_name      AS consignee_first_name,
        cd.last_name       AS consignee_last_name,
        cd.email           AS consignee_email,
        cd.phone           AS consignee_phone,
        cd.alternate_phone AS consignee_alternate_mobile,
        cd.address_line1   AS consignee_address1,
        cd.address_line2   AS consignee_address2,
        cd.landmark        AS consignee_landmark,
        cd.city            AS consignee_city,
        cd.state           AS consignee_state,
        cd.country         AS consignee_country,
        cd.pincode         AS consignee_pincode,
        cd.billing_same_as_shipping,

        w.warehouse_name,
        w.warehouse_city,
        w.warehouse_address,
        w.warehouse_contact_person,
        w.warehouse_pincode,
        w.warehouse_state,
        w.warehouse_person,

        courier.productType AS forwarder_product_type,

        o.orderid,
        o.created_at        AS order_date,
        o.payment_mode,
        o.grand_total,
        o.collectable_amount
      FROM tbl_exp_lr lr
      LEFT JOIN tbl_admin                 c        ON lr.client_id = c.id
      LEFT JOIN tbl_exp_consignee_details cd      ON lr.order_id = cd.order_id
      LEFT JOIN tbl_exp_orders            o       ON lr.order_id = o.id
      LEFT JOIN tbl_add_warehouse          w       ON o.warehouse_id = w.serial
      LEFT JOIN tbl_courier_details        courier ON lr.forwarder_id = courier.id
      WHERE lr.status = 1
    `;

    // Parameters array will grow only if we add client filter
    const params = [];

    // If not admin view, filter by client
    if (selectedClientId !== 1) {
      query += ` AND lr.client_id = ?`;
      params.push(selectedClientId);
    }

    // Sort once
    query += ` ORDER BY lr.id DESC`;

    console.log("ðŸ” [ecomOutForDelivery] Running query with params:", params);
    const result = await mySqlQury(query, params);
    console.log("ðŸ“¦ [ecomOutForDelivery] Rows:", Array.isArray(result) ? result.length : 0);

    // Render ONLY the values you asked for
    res.render('pages/express/ready_to_dispatch_assinged_lr', {
      title: 'Ready To Dispatch Orders',
      bodyClass: 'profile-page',
      activePage: 'profile',
      result,
      walletBalance
    });

  } catch (error) {
    console.error('âŒ [ecomOutForDelivery] Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
};
const expressOrderDelivered = async (req, res) => {
  try {
    const roleData = req.user || {};
    const selectedClientId = Number(roleData.selectedClientId || 1);

    // Wallet should reflect the "view" context:
    // - If Admin (selectedClientId === 1), show admin's wallet (req.user.id)
    // - Else show that client's wallet
    const walletOwnerId = selectedClientId === 1 ? Number(roleData.id) : selectedClientId;
    const [walletRow] = await mySqlQury(
      `SELECT total_amount FROM tbl_wallet WHERE user_id = ?`,
      [walletOwnerId]
    );
    const walletBalance = walletRow ? Number(walletRow.total_amount) : 0;

    // Base query (no client filter yet). Only one query string that we mutate.
    // NOTE: Keep only the columns you actually need in the EJS to avoid over-fetching.
    let query = `
      SELECT
        lr.id,
        lr.lr_no,
        lr.client_id,
        lr.order_id,
        lr.forwarder_id,
        lr.tagged_api,
        lr.aggrigator_id,
        lr.volumetric_weight,
        lr.chargable_weight,
        lr.base_rate,
        lr.total_additional,
        lr.total_gst,
        lr.total_lr_charges,
        lr.status,
        lr.eta,
        lr.billing_status,
        lr.created_at,

        c.company_name,

        cd.first_name      AS consignee_first_name,
        cd.last_name       AS consignee_last_name,
        cd.email           AS consignee_email,
        cd.phone           AS consignee_phone,
        cd.alternate_phone AS consignee_alternate_mobile,
        cd.address_line1   AS consignee_address1,
        cd.address_line2   AS consignee_address2,
        cd.landmark        AS consignee_landmark,
        cd.city            AS consignee_city,
        cd.state           AS consignee_state,
        cd.country         AS consignee_country,
        cd.pincode         AS consignee_pincode,
        cd.billing_same_as_shipping,

        w.warehouse_name,
        w.warehouse_city,
        w.warehouse_address,
        w.warehouse_contact_person,
        w.warehouse_pincode,
        w.warehouse_state,
        w.warehouse_person,

        courier.productType AS forwarder_product_type,

        o.orderid,
        o.created_at        AS order_date,
        o.payment_mode,
        o.grand_total,
        o.collectable_amount
      FROM tbl_exp_lr lr
      LEFT JOIN tbl_admin                 c        ON lr.client_id = c.id
      LEFT JOIN tbl_exp_consignee_details cd      ON lr.order_id = cd.order_id
      LEFT JOIN tbl_exp_orders            o       ON lr.order_id = o.id
      LEFT JOIN tbl_add_warehouse          w       ON o.warehouse_id = w.serial
      LEFT JOIN tbl_courier_details        courier ON lr.forwarder_id = courier.id
      WHERE lr.status = 4
    `;

    // Parameters array will grow only if we add client filter
    const params = [];

    // If not admin view, filter by client
    if (selectedClientId !== 1) {
      query += ` AND lr.client_id = ?`;
      params.push(selectedClientId);
    }

    // Sort once
    query += ` ORDER BY lr.id DESC`;

    console.log("ðŸ” [ecomOutForDelivery] Running query with params:", params);
    const result = await mySqlQury(query, params);
    console.log("ðŸ“¦ [ecomOutForDelivery] Rows:", Array.isArray(result) ? result.length : 0);

    // Render ONLY the values you asked for
    res.render('pages/express/order-delivered', {
      title: 'Ready To Dispatch Orders',
      bodyClass: 'profile-page',
      activePage: 'profile',
      result,
      walletBalance
    });

  } catch (error) {
    console.error('âŒ [ecomOutForDelivery] Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
};
const expressOrderReturn = async (req, res) => {
  try {
    const roleData = req.user || {};
    const selectedClientId = Number(roleData.selectedClientId || 1);

    // Wallet should reflect the "view" context:
    // - If Admin (selectedClientId === 1), show admin's wallet (req.user.id)
    // - Else show that client's wallet
    const walletOwnerId = selectedClientId === 1 ? Number(roleData.id) : selectedClientId;
    const [walletRow] = await mySqlQury(
      `SELECT total_amount FROM tbl_wallet WHERE user_id = ?`,
      [walletOwnerId]
    );
    const walletBalance = walletRow ? Number(walletRow.total_amount) : 0;

    // Base query (no client filter yet). Only one query string that we mutate.
    // NOTE: Keep only the columns you actually need in the EJS to avoid over-fetching.
    let query = `
      SELECT
        lr.id,
        lr.lr_no,
        lr.client_id,
        lr.order_id,
        lr.forwarder_id,
        lr.tagged_api,
        lr.aggrigator_id,
        lr.volumetric_weight,
        lr.chargable_weight,
        lr.base_rate,
        lr.total_additional,
        lr.total_gst,
        lr.total_lr_charges,
        lr.status,
        lr.eta,
        lr.billing_status,
        lr.created_at,

        c.company_name,

        cd.first_name      AS consignee_first_name,
        cd.last_name       AS consignee_last_name,
        cd.email           AS consignee_email,
        cd.phone           AS consignee_phone,
        cd.alternate_phone AS consignee_alternate_mobile,
        cd.address_line1   AS consignee_address1,
        cd.address_line2   AS consignee_address2,
        cd.landmark        AS consignee_landmark,
        cd.city            AS consignee_city,
        cd.state           AS consignee_state,
        cd.country         AS consignee_country,
        cd.pincode         AS consignee_pincode,
        cd.billing_same_as_shipping,

        w.warehouse_name,
        w.warehouse_city,
        w.warehouse_address,
        w.warehouse_contact_person,
        w.warehouse_pincode,
        w.warehouse_state,
        w.warehouse_person,

        courier.productType AS forwarder_product_type,

        o.orderid,
        o.created_at        AS order_date,
        o.payment_mode,
        o.grand_total,
        o.collectable_amount
      FROM tbl_exp_lr lr
      LEFT JOIN tbl_admin                 c        ON lr.client_id = c.id
      LEFT JOIN tbl_exp_consignee_details cd      ON lr.order_id = cd.order_id
      LEFT JOIN tbl_exp_orders            o       ON lr.order_id = o.id
      LEFT JOIN tbl_add_warehouse          w       ON o.warehouse_id = w.serial
      LEFT JOIN tbl_courier_details        courier ON lr.forwarder_id = courier.id
      WHERE lr.status = 5
    `;

    // Parameters array will grow only if we add client filter
    const params = [];

    // If not admin view, filter by client
    if (selectedClientId !== 1) {
      query += ` AND lr.client_id = ?`;
      params.push(selectedClientId);
    }

    // Sort once
    query += ` ORDER BY lr.id DESC`;

    console.log("ðŸ” [ecomOutForDelivery] Running query with params:", params);
    const result = await mySqlQury(query, params);
    console.log("ðŸ“¦ [ecomOutForDelivery] Rows:", Array.isArray(result) ? result.length : 0);

    // Render ONLY the values you asked for
    res.render('pages/express/order-return', {
      title: 'Ready To Dispatch Orders',
      bodyClass: 'profile-page',
      activePage: 'profile',
      result,
      walletBalance
    });

  } catch (error) {
    console.error('âŒ [ecomOutForDelivery] Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
};
const expressCancelledOrder = async (req, res) => {
  try {
    const roleData = req.user || {};
    const selectedClientId = Number(roleData.selectedClientId || 1);

    // Wallet should reflect the "view" context:
    // - If Admin (selectedClientId === 1), show admin's wallet (req.user.id)
    // - Else show that client's wallet
    const walletOwnerId = selectedClientId === 1 ? Number(roleData.id) : selectedClientId;
    const [walletRow] = await mySqlQury(
      `SELECT total_amount FROM tbl_wallet WHERE user_id = ?`,
      [walletOwnerId]
    );
    const walletBalance = walletRow ? Number(walletRow.total_amount) : 0;

    // Base query (no client filter yet). Only one query string that we mutate.
    // NOTE: Keep only the columns you actually need in the EJS to avoid over-fetching.
    let query = `
      SELECT
        lr.id,
        lr.lr_no,
        lr.client_id,
        lr.order_id,
        lr.forwarder_id,
        lr.tagged_api,
        lr.aggrigator_id,
        lr.volumetric_weight,
        lr.chargable_weight,
        lr.base_rate,
        lr.total_additional,
        lr.total_gst,
        lr.total_lr_charges,
        lr.status,
        lr.eta,
        lr.billing_status,
        lr.created_at,

        c.company_name,

        cd.first_name      AS consignee_first_name,
        cd.last_name       AS consignee_last_name,
        cd.email           AS consignee_email,
        cd.phone           AS consignee_phone,
        cd.alternate_phone AS consignee_alternate_mobile,
        cd.address_line1   AS consignee_address1,
        cd.address_line2   AS consignee_address2,
        cd.landmark        AS consignee_landmark,
        cd.city            AS consignee_city,
        cd.state           AS consignee_state,
        cd.country         AS consignee_country,
        cd.pincode         AS consignee_pincode,
        cd.billing_same_as_shipping,

        w.warehouse_name,
        w.warehouse_city,
        w.warehouse_address,
        w.warehouse_contact_person,
        w.warehouse_pincode,
        w.warehouse_state,
        w.warehouse_person,

        courier.productType AS forwarder_product_type,

        o.orderid,
        o.created_at        AS order_date,
        o.payment_mode,
        o.grand_total,
        o.collectable_amount
      FROM tbl_exp_lr lr
      LEFT JOIN tbl_admin                 c        ON lr.client_id = c.id
      LEFT JOIN tbl_exp_consignee_details cd      ON lr.order_id = cd.order_id
      LEFT JOIN tbl_exp_orders            o       ON lr.order_id = o.id
      LEFT JOIN tbl_add_warehouse          w       ON o.warehouse_id = w.serial
      LEFT JOIN tbl_courier_details        courier ON lr.forwarder_id = courier.id
      WHERE lr.status = 0
    `;

    // Parameters array will grow only if we add client filter
    const params = [];

    // If not admin view, filter by client
    if (selectedClientId !== 1) {
      query += ` AND lr.client_id = ?`;
      params.push(selectedClientId);
    }

    // Sort once
    query += ` ORDER BY lr.id DESC`;

    console.log("ðŸ” [ecomOutForDelivery] Running query with params:", params);
    const result = await mySqlQury(query, params);
    console.log("ðŸ“¦ [ecomOutForDelivery] Rows:", Array.isArray(result) ? result.length : 0);

    // Render ONLY the values you asked for
    res.render('pages/express/cancelled-orders', {
      title: 'Ready To Dispatch Orders',
      bodyClass: 'profile-page',
      activePage: 'profile',
      result,
      walletBalance
    });

  } catch (error) {
    console.error('âŒ [ecomOutForDelivery] Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
};
const ltlOutForDelivery = async (req, res, next) => {
  try {
    let result;
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;

    let loginDetails = null;
    let clientId = 0;
    let walletBalance = 0;
    let vasService = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,company_name,vas,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

      // Get LR data and bidding total_rate filtered by client_id
      result = await mySqlQury(
        `SELECT lr.*, bid.total_rate, c.company_name
           FROM tbl_create_lr lr
           LEFT JOIN tbl_aggrigator_bidding bid ON lr.lr_No = bid.lr_No 
           LEFT JOIN tbl_admin c ON lr.client_id = c.id
           WHERE lr.status = 8 AND lr.client_id = ? 
           ORDER BY lr.lr_id DESC`,
        [clientId]
      );

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;

      // Get all orders for admin
      result = await mySqlQury(
        `SELECT lr.*, bid.total_rate, c.company_name 
           FROM tbl_create_lr lr
           LEFT JOIN tbl_aggrigator_bidding bid ON lr.lr_No = bid.lr_No 
           LEFT JOIN tbl_admin c ON lr.client_id = c.id
           WHERE lr.status = 8 
           ORDER BY lr.lr_id DESC`
      );
    }

    // Get active topics
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Extract active topic IDs
    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    }

    let apiLTL = process.env.API_KEYLTL;
    let apistd = process.env.API_KEYSTD;

    res.render('pages/ltl/out-for-delivery', {
      title: 'Orders Delivered',
      bodyClass: 'profile-page',
      activePage: 'profile',
      result: result,
      loginDetails: loginDetails || {}, // Provide empty object as fallback
      apiLTL,
      role_data,
      activeTopicIds,
      profile,
      apiSTD: apistd,
      clientId,
      walletBalance,
      vasService,
      role

    });

  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
}

///ecom ready to dispatch post dispatch
const ecomReadyToDispatch =  async (req, res) => {
  try {
    const roleData = req.user || {};
    const selectedClientId = Number(roleData.selectedClientId || 1);

    // Wallet should reflect the "view" context:
    // - If Admin (selectedClientId === 1), show admin's wallet (req.user.id)
    // - Else show that client's wallet
    const walletOwnerId = selectedClientId === 1 ? Number(roleData.id) : selectedClientId;
    const [walletRow] = await mySqlQury(
      `SELECT total_amount FROM tbl_wallet WHERE user_id = ?`,
      [walletOwnerId]
    );
    const walletBalance = walletRow ? Number(walletRow.total_amount) : 0;

    // Base query (no client filter yet). Only one query string that we mutate.
    // NOTE: Keep only the columns you actually need in the EJS to avoid over-fetching.
    let query = `
      SELECT
        lr.id,
        lr.lr_no,
        lr.client_id,
        lr.order_id,
        lr.forwarder_id,
        lr.tagged_api,
        lr.aggrigator_id,
        lr.volumetric_weight,
        lr.chargable_weight,
        lr.base_rate,
        lr.total_additional,
        lr.total_gst,
        lr.total_lr_charges,
        lr.status,
        lr.eta,
        lr.billing_status,
        lr.created_at,

        c.company_name,

        cd.first_name      AS consignee_first_name,
        cd.last_name       AS consignee_last_name,
        cd.email           AS consignee_email,
        cd.phone           AS consignee_phone,
        cd.alternate_phone AS consignee_alternate_mobile,
        cd.address_line1   AS consignee_address1,
        cd.address_line2   AS consignee_address2,
        cd.landmark        AS consignee_landmark,
        cd.city            AS consignee_city,
        cd.state           AS consignee_state,
        cd.country         AS consignee_country,
        cd.pincode         AS consignee_pincode,
        cd.billing_same_as_shipping,

        w.warehouse_name,
        w.warehouse_city,
        w.warehouse_address,
        w.warehouse_contact_person,
        w.warehouse_pincode,
        w.warehouse_state,
        w.warehouse_person,

        courier.productType AS forwarder_product_type,

        o.orderid,
        o.created_at        AS order_date,
        o.payment_mode,
        o.grand_total,
        o.collectable_amount
      FROM tbl_ecom_lr lr
      LEFT JOIN tbl_admin                 c        ON lr.client_id = c.id
      LEFT JOIN tbl_ecom_consignee_details cd      ON lr.order_id = cd.order_id
      LEFT JOIN tbl_ecom_orders            o       ON lr.order_id = o.id
      LEFT JOIN tbl_add_warehouse          w       ON o.warehouse_id = w.serial
      LEFT JOIN tbl_courier_details        courier ON lr.forwarder_id = courier.id
      WHERE lr.status = 1
    `;

    // Parameters array will grow only if we add client filter
    const params = [];

    // If not admin view, filter by client
    if (selectedClientId !== 1) {
      query += ` AND lr.client_id = ?`;
      params.push(selectedClientId);
    }

    // Sort once
    query += ` ORDER BY lr.id DESC`;

    console.log("ðŸ” [ecomOutForDelivery] Running query with params:", params);
    const result = await mySqlQury(query, params);
    console.log("ðŸ“¦ [ecomOutForDelivery] Rows:", Array.isArray(result) ? result.length : 0);

    // Render ONLY the values you asked for
    res.render('pages/ecom/ready_to_dispatch_assinged_lr', {
      title: 'Ready To Dispatch Orders',
      bodyClass: 'profile-page',
      activePage: 'profile',
      result,
      walletBalance
    });

  } catch (error) {
    console.error('âŒ [ecomOutForDelivery] Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
};
const ecomOrderInTransit = async (req, res) => {
  try {
    const roleData = req.user || {};
    const selectedClientId = Number(roleData.selectedClientId || 1);

    // Wallet should reflect the "view" context:
    // - If Admin (selectedClientId === 1), show admin's wallet (req.user.id)
    // - Else show that client's wallet
    const walletOwnerId = selectedClientId === 1 ? Number(roleData.id) : selectedClientId;
    const [walletRow] = await mySqlQury(
      `SELECT total_amount FROM tbl_wallet WHERE user_id = ?`,
      [walletOwnerId]
    );
    const walletBalance = walletRow ? Number(walletRow.total_amount) : 0;

    // Base query (no client filter yet). Only one query string that we mutate.
    // NOTE: Keep only the columns you actually need in the EJS to avoid over-fetching.
    let query = `
      SELECT
        lr.id,
        lr.lr_no,
        lr.client_id,
        lr.order_id,
        lr.forwarder_id,
        lr.tagged_api,
        lr.aggrigator_id,
        lr.volumetric_weight,
        lr.chargable_weight,
        lr.base_rate,
        lr.total_additional,
        lr.total_gst,
        lr.total_lr_charges,
        lr.status,
        lr.eta,
        lr.billing_status,
        lr.created_at,

        c.company_name,

        cd.first_name      AS consignee_first_name,
        cd.last_name       AS consignee_last_name,
        cd.email           AS consignee_email,
        cd.phone           AS consignee_phone,
        cd.alternate_phone AS consignee_alternate_mobile,
        cd.address_line1   AS consignee_address1,
        cd.address_line2   AS consignee_address2,
        cd.landmark        AS consignee_landmark,
        cd.city            AS consignee_city,
        cd.state           AS consignee_state,
        cd.country         AS consignee_country,
        cd.pincode         AS consignee_pincode,
        cd.billing_same_as_shipping,

        w.warehouse_name,
        w.warehouse_city,
        w.warehouse_address,
        w.warehouse_contact_person,
        w.warehouse_pincode,
        w.warehouse_state,
        w.warehouse_person,

        courier.productType AS forwarder_product_type,

        o.orderid,
        o.created_at        AS order_date,
        o.payment_mode,
        o.grand_total,
        o.collectable_amount
      FROM tbl_ecom_lr lr
      LEFT JOIN tbl_admin                 c        ON lr.client_id = c.id
      LEFT JOIN tbl_ecom_consignee_details cd      ON lr.order_id = cd.order_id
      LEFT JOIN tbl_ecom_orders            o       ON lr.order_id = o.id
      LEFT JOIN tbl_add_warehouse          w       ON o.warehouse_id = w.serial
      LEFT JOIN tbl_courier_details        courier ON lr.forwarder_id = courier.id
      WHERE lr.status = 3
    `;

    // Parameters array will grow only if we add client filter
    const params = [];

    // If not admin view, filter by client
    if (selectedClientId !== 1) {
      query += ` AND lr.client_id = ?`;
      params.push(selectedClientId);
    }

    // Sort once
    query += ` ORDER BY lr.id DESC`;

    console.log("ðŸ” [ecomOutForDelivery] Running query with params:", params);
    const result = await mySqlQury(query, params);
    console.log("ðŸ“¦ [ecomOutForDelivery] Rows:", Array.isArray(result) ? result.length : 0);

    // Render ONLY the values you asked for
    res.render('pages/ecom/order-In-transit', {
      title: 'Ready To Dispatch Orders',
      bodyClass: 'profile-page',
      activePage: 'profile',
      result,
      walletBalance
    });

  } catch (error) {
    console.error('âŒ [ecomOutForDelivery] Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
};
const ecomOutForDelivery = async (req, res) => {
  try {
    const roleData = req.user || {};
    const selectedClientId = Number(roleData.selectedClientId || 1);

    // Wallet should reflect the "view" context:
    // - If Admin (selectedClientId === 1), show admin's wallet (req.user.id)
    // - Else show that client's wallet
    const walletOwnerId = selectedClientId === 1 ? Number(roleData.id) : selectedClientId;
    const [walletRow] = await mySqlQury(
      `SELECT total_amount FROM tbl_wallet WHERE user_id = ?`,
      [walletOwnerId]
    );
    const walletBalance = walletRow ? Number(walletRow.total_amount) : 0;

    // Base query (no client filter yet). Only one query string that we mutate.
    // NOTE: Keep only the columns you actually need in the EJS to avoid over-fetching.
    let query = `
      SELECT
        lr.id,
        lr.lr_no,
        lr.client_id,
        lr.order_id,
        lr.forwarder_id,
        lr.tagged_api,
        lr.aggrigator_id,
        lr.volumetric_weight,
        lr.chargable_weight,
        lr.base_rate,
        lr.total_additional,
        lr.total_gst,
        lr.total_lr_charges,
        lr.status,
        lr.eta,
        lr.billing_status,
        lr.created_at,

        c.company_name,

        cd.first_name      AS consignee_first_name,
        cd.last_name       AS consignee_last_name,
        cd.email           AS consignee_email,
        cd.phone           AS consignee_phone,
        cd.alternate_phone AS consignee_alternate_mobile,
        cd.address_line1   AS consignee_address1,
        cd.address_line2   AS consignee_address2,
        cd.landmark        AS consignee_landmark,
        cd.city            AS consignee_city,
        cd.state           AS consignee_state,
        cd.country         AS consignee_country,
        cd.pincode         AS consignee_pincode,
        cd.billing_same_as_shipping,

        w.warehouse_name,
        w.warehouse_city,
        w.warehouse_address,
        w.warehouse_contact_person,
        w.warehouse_pincode,
        w.warehouse_state,
        w.warehouse_person,

        courier.productType AS forwarder_product_type,

        o.orderid,
        o.created_at        AS order_date,
        o.payment_mode,
        o.grand_total,
        o.collectable_amount
      FROM tbl_ecom_lr lr
      LEFT JOIN tbl_admin                 c        ON lr.client_id = c.id
      LEFT JOIN tbl_ecom_consignee_details cd      ON lr.order_id = cd.order_id
      LEFT JOIN tbl_ecom_orders            o       ON lr.order_id = o.id
      LEFT JOIN tbl_add_warehouse          w       ON o.warehouse_id = w.serial
      LEFT JOIN tbl_courier_details        courier ON lr.forwarder_id = courier.id
      WHERE lr.status = 8
    `;

    // Parameters array will grow only if we add client filter
    const params = [];

    // If not admin view, filter by client
    if (selectedClientId !== 1) {
      query += ` AND lr.client_id = ?`;
      params.push(selectedClientId);
    }

    // Sort once
    query += ` ORDER BY lr.id DESC`;

    console.log("ðŸ” [ecomOutForDelivery] Running query with params:", params);
    const result = await mySqlQury(query, params);
    console.log("ðŸ“¦ [ecomOutForDelivery] Rows:", Array.isArray(result) ? result.length : 0);

    // Render ONLY the values you asked for
    res.render('pages/ecom/out-for-delivery', {
      title: 'Ready To Dispatch Orders',
      bodyClass: 'profile-page',
      activePage: 'profile',
      result,
      walletBalance
    });

  } catch (error) {
    console.error('âŒ [ecomOutForDelivery] Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
};
const ecomOrderDelivered =  async (req, res) => {
  try {
    const roleData = req.user || {};
    const selectedClientId = Number(roleData.selectedClientId || 1);

    // Wallet should reflect the "view" context:
    // - If Admin (selectedClientId === 1), show admin's wallet (req.user.id)
    // - Else show that client's wallet
    const walletOwnerId = selectedClientId === 1 ? Number(roleData.id) : selectedClientId;
    const [walletRow] = await mySqlQury(
      `SELECT total_amount FROM tbl_wallet WHERE user_id = ?`,
      [walletOwnerId]
    );
    const walletBalance = walletRow ? Number(walletRow.total_amount) : 0;

    // Base query (no client filter yet). Only one query string that we mutate.
    // NOTE: Keep only the columns you actually need in the EJS to avoid over-fetching.
    let query = `
      SELECT
        lr.id,
        lr.lr_no,
        lr.client_id,
        lr.order_id,
        lr.forwarder_id,
        lr.tagged_api,
        lr.aggrigator_id,
        lr.volumetric_weight,
        lr.chargable_weight,
        lr.base_rate,
        lr.total_additional,
        lr.total_gst,
        lr.total_lr_charges,
        lr.status,
        lr.eta,
        lr.billing_status,
        lr.created_at,

        c.company_name,

        cd.first_name      AS consignee_first_name,
        cd.last_name       AS consignee_last_name,
        cd.email           AS consignee_email,
        cd.phone           AS consignee_phone,
        cd.alternate_phone AS consignee_alternate_mobile,
        cd.address_line1   AS consignee_address1,
        cd.address_line2   AS consignee_address2,
        cd.landmark        AS consignee_landmark,
        cd.city            AS consignee_city,
        cd.state           AS consignee_state,
        cd.country         AS consignee_country,
        cd.pincode         AS consignee_pincode,
        cd.billing_same_as_shipping,

        w.warehouse_name,
        w.warehouse_city,
        w.warehouse_address,
        w.warehouse_contact_person,
        w.warehouse_pincode,
        w.warehouse_state,
        w.warehouse_person,

        courier.productType AS forwarder_product_type,

        o.orderid,
        o.created_at        AS order_date,
        o.payment_mode,
        o.grand_total,
        o.collectable_amount
      FROM tbl_ecom_lr lr
      LEFT JOIN tbl_admin                 c        ON lr.client_id = c.id
      LEFT JOIN tbl_ecom_consignee_details cd      ON lr.order_id = cd.order_id
      LEFT JOIN tbl_ecom_orders            o       ON lr.order_id = o.id
      LEFT JOIN tbl_add_warehouse          w       ON o.warehouse_id = w.serial
      LEFT JOIN tbl_courier_details        courier ON lr.forwarder_id = courier.id
      WHERE lr.status = 4
    `;

    // Parameters array will grow only if we add client filter
    const params = [];

    // If not admin view, filter by client
    if (selectedClientId !== 1) {
      query += ` AND lr.client_id = ?`;
      params.push(selectedClientId);
    }

    // Sort once
    query += ` ORDER BY lr.id DESC`;

    console.log("ðŸ” [ecomOutForDelivery] Running query with params:", params);
    const result = await mySqlQury(query, params);
    console.log("ðŸ“¦ [ecomOutForDelivery] Rows:", Array.isArray(result) ? result.length : 0);

    // Render ONLY the values you asked for
    res.render('pages/ecom/order-delivered', {
      title: 'Ready To Dispatch Orders',
      bodyClass: 'profile-page',
      activePage: 'profile',
      result,
      walletBalance
    });

  } catch (error) {
    console.error('âŒ [ecomOutForDelivery] Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
};
const ecomOrderReturn =  async (req, res) => {
  try {
    const roleData = req.user || {};
    const selectedClientId = Number(roleData.selectedClientId || 1);

    // Wallet should reflect the "view" context:
    // - If Admin (selectedClientId === 1), show admin's wallet (req.user.id)
    // - Else show that client's wallet
    const walletOwnerId = selectedClientId === 1 ? Number(roleData.id) : selectedClientId;
    const [walletRow] = await mySqlQury(
      `SELECT total_amount FROM tbl_wallet WHERE user_id = ?`,
      [walletOwnerId]
    );
    const walletBalance = walletRow ? Number(walletRow.total_amount) : 0;

    // Base query (no client filter yet). Only one query string that we mutate.
    // NOTE: Keep only the columns you actually need in the EJS to avoid over-fetching.
    let query = `
      SELECT
        lr.id,
        lr.lr_no,
        lr.client_id,
        lr.order_id,
        lr.forwarder_id,
        lr.tagged_api,
        lr.aggrigator_id,
        lr.volumetric_weight,
        lr.chargable_weight,
        lr.base_rate,
        lr.total_additional,
        lr.total_gst,
        lr.total_lr_charges,
        lr.status,
        lr.eta,
        lr.billing_status,
        lr.created_at,

        c.company_name,

        cd.first_name      AS consignee_first_name,
        cd.last_name       AS consignee_last_name,
        cd.email           AS consignee_email,
        cd.phone           AS consignee_phone,
        cd.alternate_phone AS consignee_alternate_mobile,
        cd.address_line1   AS consignee_address1,
        cd.address_line2   AS consignee_address2,
        cd.landmark        AS consignee_landmark,
        cd.city            AS consignee_city,
        cd.state           AS consignee_state,
        cd.country         AS consignee_country,
        cd.pincode         AS consignee_pincode,
        cd.billing_same_as_shipping,

        w.warehouse_name,
        w.warehouse_city,
        w.warehouse_address,
        w.warehouse_contact_person,
        w.warehouse_pincode,
        w.warehouse_state,
        w.warehouse_person,

        courier.productType AS forwarder_product_type,

        o.orderid,
        o.created_at        AS order_date,
        o.payment_mode,
        o.grand_total,
        o.collectable_amount
      FROM tbl_ecom_lr lr
      LEFT JOIN tbl_admin                 c        ON lr.client_id = c.id
      LEFT JOIN tbl_ecom_consignee_details cd      ON lr.order_id = cd.order_id
      LEFT JOIN tbl_ecom_orders            o       ON lr.order_id = o.id
      LEFT JOIN tbl_add_warehouse          w       ON o.warehouse_id = w.serial
      LEFT JOIN tbl_courier_details        courier ON lr.forwarder_id = courier.id
      WHERE lr.status = 5
    `;

    // Parameters array will grow only if we add client filter
    const params = [];

    // If not admin view, filter by client
    if (selectedClientId !== 1) {
      query += ` AND lr.client_id = ?`;
      params.push(selectedClientId);
    }

    // Sort once
    query += ` ORDER BY lr.id DESC`;

    console.log("ðŸ” [ecomOutForDelivery] Running query with params:", params);
    const result = await mySqlQury(query, params);
    console.log("ðŸ“¦ [ecomOutForDelivery] Rows:", Array.isArray(result) ? result.length : 0);

    // Render ONLY the values you asked for
    res.render('pages/ecom/order-return', {
      title: 'Ready To Dispatch Orders',
      bodyClass: 'profile-page',
      activePage: 'profile',
      result,
      walletBalance
    });

  } catch (error) {
    console.error('âŒ [ecomOutForDelivery] Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
};
const ecomCancelledOrder =  async (req, res) => { 
  try {
    const roleData = req.user || {};
    const selectedClientId = Number(roleData.selectedClientId || 1);

    // Wallet should reflect the "view" context:
    // - If Admin (selectedClientId === 1), show admin's wallet (req.user.id)
    // - Else show that client's wallet
    const walletOwnerId = selectedClientId === 1 ? Number(roleData.id) : selectedClientId;
    const [walletRow] = await mySqlQury(
      `SELECT total_amount FROM tbl_wallet WHERE user_id = ?`,
      [walletOwnerId]
    );
    const walletBalance = walletRow ? Number(walletRow.total_amount) : 0;

    // Base query (no client filter yet). Only one query string that we mutate.
    // NOTE: Keep only the columns you actually need in the EJS to avoid over-fetching.
    let query = `
      SELECT
        lr.id,
        lr.lr_no,
        lr.client_id,
        lr.order_id,
        lr.forwarder_id,
        lr.tagged_api,
        lr.aggrigator_id,
        lr.volumetric_weight,
        lr.chargable_weight,
        lr.base_rate,
        lr.total_additional,
        lr.total_gst,
        lr.total_lr_charges,
        lr.status,
        lr.eta,
        lr.billing_status,
        lr.created_at,

        c.company_name,

        cd.first_name      AS consignee_first_name,
        cd.last_name       AS consignee_last_name,
        cd.email           AS consignee_email,
        cd.phone           AS consignee_phone,
        cd.alternate_phone AS consignee_alternate_mobile,
        cd.address_line1   AS consignee_address1,
        cd.address_line2   AS consignee_address2,
        cd.landmark        AS consignee_landmark,
        cd.city            AS consignee_city,
        cd.state           AS consignee_state,
        cd.country         AS consignee_country,
        cd.pincode         AS consignee_pincode,
        cd.billing_same_as_shipping,

        w.warehouse_name,
        w.warehouse_city,
        w.warehouse_address,
        w.warehouse_contact_person,
        w.warehouse_pincode,
        w.warehouse_state,
        w.warehouse_person,

        courier.productType AS forwarder_product_type,

        o.orderid,
        o.created_at        AS order_date,
        o.payment_mode,
        o.grand_total,
        o.collectable_amount
      FROM tbl_ecom_lr lr
      LEFT JOIN tbl_admin                 c        ON lr.client_id = c.id
      LEFT JOIN tbl_ecom_consignee_details cd      ON lr.order_id = cd.order_id
      LEFT JOIN tbl_ecom_orders            o       ON lr.order_id = o.id
      LEFT JOIN tbl_add_warehouse          w       ON o.warehouse_id = w.serial
      LEFT JOIN tbl_courier_details        courier ON lr.forwarder_id = courier.id
      WHERE lr.status = 0
    `;

    // Parameters array will grow only if we add client filter
    const params = [];

    // If not admin view, filter by client
    if (selectedClientId !== 1) {
      query += ` AND lr.client_id = ?`;
      params.push(selectedClientId);
    }

    // Sort once
    query += ` ORDER BY lr.id DESC`;

    console.log("ðŸ” [ecomOutForDelivery] Running query with params:", params);
    const result = await mySqlQury(query, params);
    console.log("ðŸ“¦ [ecomOutForDelivery] Rows:", Array.isArray(result) ? result.length : 0);

    // Render ONLY the values you asked for
    res.render('pages/ecom/cancelled-orders', {
      title: 'Ready To Dispatch Orders',
      bodyClass: 'profile-page',
      activePage: 'profile',
      result,
      walletBalance
    });

  } catch (error) {
    console.error('âŒ [ecomOutForDelivery] Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
};
const ltlOrderDelivered = async (req, res, next) => {
  try {
    let result;
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;

    let loginDetails = null;
    let clientId = 0;
    let walletBalance = 0;
    let vasService = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,company_name,vas,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

      // Get LR data and bidding total_rate filtered by client_id
      result = await mySqlQury(
        `SELECT lr.*, bid.total_rate, c.company_name
           FROM tbl_create_lr lr
           LEFT JOIN tbl_aggrigator_bidding bid ON lr.lr_No = bid.lr_No 
           LEFT JOIN tbl_admin c ON lr.client_id = c.id
           WHERE lr.status = 4 AND lr.client_id = ? 
           ORDER BY lr.lr_id DESC`,
        [clientId]
      );

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
      // Get all orders for admin
      result = await mySqlQury(
        `SELECT lr.*, bid.total_rate, c.company_name 
           FROM tbl_create_lr lr
           LEFT JOIN tbl_aggrigator_bidding bid ON lr.lr_No = bid.lr_No 
           LEFT JOIN tbl_admin c ON lr.client_id = c.id
           WHERE lr.status = 4 
           ORDER BY lr.lr_id DESC`
      );
    }

    // Get active topics
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Extract active topic IDs
    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    }

    let apiLTL = process.env.API_KEYLTL;
    let apistd = process.env.API_KEYSTD;

    res.render('pages/ltl/order-delivered', {
      title: 'Orders Delivered',
      bodyClass: 'profile-page',
      activePage: 'profile',
      result: result,
      loginDetails: loginDetails || {}, // Provide empty object as fallback
      apiLTL,
      role_data,
      activeTopicIds,
      profile,
      apiSTD: apistd,
      clientId,
      walletBalance,
      vasService, role
    });

  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
}



const ltlOrderReturn = async (req, res, next) => {
  try {
    let result;
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;

    let loginDetails = null;
    let clientId = 0;
    let walletBalance = 0;
    let vasService = 0;
    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,company_name,vas,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;

      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      // Get LR data and bidding total_rate filtered by client_id
      result = await mySqlQury(
        `SELECT lr.*, bid.total_rate, c.company_name 
           FROM tbl_create_lr lr
           LEFT JOIN tbl_aggrigator_bidding bid ON lr.lr_No = bid.lr_No 
           LEFT JOIN tbl_admin c ON lr.client_id = c.id
           WHERE lr.status = 5 AND lr.client_id = ? 
           ORDER BY lr.lr_id DESC`,
        [clientId]
      );

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
      // Get all orders for admin
      result = await mySqlQury(
        `SELECT lr.*, bid.total_rate, c.company_name 
           FROM tbl_create_lr lr
           LEFT JOIN tbl_aggrigator_bidding bid ON lr.lr_No = bid.lr_No 
           LEFT JOIN tbl_admin c ON lr.client_id = c.id
           WHERE lr.status = 5 
           ORDER BY lr.lr_id DESC`
      );
    }

    // Get active topics
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Extract active topic IDs
    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    }

    let apiLTL = process.env.API_KEYLTL;
    let apistd = process.env.API_KEYSTD;

    res.render('pages/ltl/order-return', {
      title: 'Orders Returned',
      bodyClass: 'profile-page',
      activePage: 'profile',
      result: result,
      loginDetails: loginDetails || {}, // Provide empty object as fallback
      apiLTL,
      role_data,
      activeTopicIds,
      profile,
      apiSTD: apistd,
      clientId,
      walletBalance,
      vasService, role
    });

  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
}


const ltlCancelledOrder = async (req, res) => {
  try {
    let result;
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;

    let loginDetails = null;
    let clientId = 0;
    let walletBalance = 0;
    let vasService = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,vas,company_name,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      // Get orders filtered by client_id
      // Get LR data and bidding total_rate filtered by client_id
      result = await mySqlQury(
        `SELECT lr.*, bid.total_rate, c.company_name 
           FROM tbl_create_lr lr
           LEFT JOIN tbl_aggrigator_bidding bid ON lr.lr_No = bid.lr_No 
           LEFT JOIN tbl_admin c ON lr.client_id = c.id
           WHERE lr.status = 0 AND lr.client_id = ? 
           ORDER BY lr.lr_id DESC`,
        [clientId]
      );

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;

      result = await mySqlQury(
        `SELECT lr.*, bid.total_rate, c.company_name 
           FROM tbl_create_lr lr
           LEFT JOIN tbl_aggrigator_bidding bid ON lr.lr_No = bid.lr_No 
           LEFT JOIN tbl_admin c ON lr.client_id = c.id
           WHERE lr.status = 0 
           ORDER BY lr.lr_id DESC`
      );
    }

    // Get active topics
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Extract active topic IDs
    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    }

    let apiLTL = process.env.API_KEYLTL;
    let apistd = process.env.API_KEYSTD;

    res.render('pages/ltl/cancelled-orders', {
      title: 'Cancelled Orders',
      bodyClass: 'profile-page',
      activePage: 'profile',
      result: result,
      loginDetails: loginDetails || {}, // Provide empty object as fallback
      apiLTL,
      role_data,
      activeTopicIds,
      profile,
      apiSTD: apistd,
      clientId,
      walletBalance,
      vasService, role
    });

  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
}



const orderDispatch = async (req, res, next) => {
  try {
    console.log('in unprocessed orders')
    const accessdata = await access(req.user);
    const role_data = req.user;
    const lang_data = req.language_data;
    const language_name = req.lang;
    const notification_data = await mySqlQury(`SELECT * FROM tbl_notification WHERE received = '${role_data.id}' ORDER BY id DESC LIMIT 3`);

    // Fetch LR data
    const lrSql = 'SELECT * FROM tbl_create_lr WHERE status = 2 ORDER BY lr_id DESC';

    const lrResult = await mySqlQury(lrSql);
    console.log("lrResult")
    let apiLTL = process.env.API_KEYLTL;
    let apistd = process.env.API_KEYSTD;
    // console.log("here api is", api)

    // Fetch file details for each LR



    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );
    const [loginDetails] = await mySqlQury(
      'SELECT first_name, role_name,company_name,logo_path FROM tbl_admin WHERE id = ?', [req.user.id]
    );

    // Log the activeTopics to see what is being returned
    // console.log("Active Topics:", activeTopics);

    // Check if activeTopics is defined and has rows
    let activeTopicIds = [];
    if (activeTopics && Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id)); // Convert to numbers
    } else if (activeTopics && activeTopics.topic_id) {
      // In case there's only one topic returned as an object
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    // Render the EJS template
    if (role_data.role == 1 || role_data.role == 2) {
      res.render('apps/order-dispatched', {
        role_data: role_data,
        accessdata: accessdata,
        title: 'lr',
        layout: 'partials/layout-vertical',
        lang_data: lang_data,
        language_name: language_name,
        notification_data: notification_data,
        apiLTL: apiLTL,
        apiSTD: apistd,
        result: lrResult,
        activeTopicIds,
        loginDetails
      });
    } else {
      res.redirect('/index');
    }
  } catch (error) {
    console.log('error', error);
  }
}
const apiPhonepayInitiatePayment = async (req, res) => {
  try {
    const { amount, merchantTransactionId, merchantUserId } = req.body;
    console.log("merchant user id in the phonepe api", merchantUserId, merchantTransactionId, amount);

    if (!amount || !merchantTransactionId || !merchantUserId) {
      return res.status(400).json({ success: false, message: 'Missing required fields' });
    }

    // Step 1: Authorization to get the token
    const authResponse = await axios.post('https://api.phonepe.com/apis/identity-manager/v1/oauth/token',
      new URLSearchParams({
        client_id: process.env.PHONEPE_CLIENT_ID,
        client_version: '1',
        client_secret: process.env.PHONEPE_CLIENT_SECRET,
        grant_type: 'client_credentials'
      }), {
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      }
    }
    );

    const accessToken = authResponse.data.access_token;

   
    const role = req.user.role;
    let userId = req.user.selectedClientId || 1;



    const payload = {
      merchantOrderId: merchantTransactionId,
      amount: amount * 100, // Convert to paise
      expireAfter: 1200,
      metaInfo: {
        udf1: "additional-information-1",
        udf2: "additional-information-2",
        udf3: "additional-information-3",
        udf4: "additional-information-4",
        udf5: "additional-information-5"
      },
      paymentFlow: {
        type: "PG_CHECKOUT",
        message: "Payment message used for collect requests",
        merchantUrls: {
          redirectUrl: `${process.env.BASE_URL}/api/phonepay/callback/${userId}/${merchantTransactionId}`
        }
      }
    };

    const paymentResponse = await axios.post('https://api.phonepe.com/apis/pg/checkout/v2/pay',
      payload, {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `O-Bearer ${accessToken}`
      }
    }
    );

    console.log("Payment initiation response:", paymentResponse.data);
    return res.json({
      success: true,
      message: 'Payment initiation successful',
      data: paymentResponse.data
    });

  } catch (error) {
    console.error('âŒ PhonePe payment initiation error:', error);
    return res.status(500).json({
      success: false,
      message: 'Failed to initiate payment',
      error: error.response?.data || error.message
    });
  }
}
const apiPhonepayMerchantOrderId = async (req, res) => {
  try {
    const { userId, merchantOrderId } = req.params;

    // Fetch order status
    const authResponse = await axios.post('https://api.phonepe.com/apis/identity-manager/v1/oauth/token',
      new URLSearchParams({
        client_id: process.env.PHONEPE_CLIENT_ID,
        client_version: '1',
        client_secret: process.env.PHONEPE_CLIENT_SECRET,
        grant_type: 'client_credentials'
      }), {
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
    });

    const accessToken = authResponse.data.access_token;
    if (!accessToken) {
      return res.redirect('/domestic-wallet?error=unauthorized');
    }

    const orderStatusResponse = await axios.get(
      `https://api.phonepe.com/apis/pg/checkout/v2/order/${merchantOrderId}/status?details=false`,
      { headers: { 'Content-Type': 'application/json', 'Authorization': `O-Bearer ${accessToken}` } }
    );

    const orderData = orderStatusResponse.data;
    console.log("Order status response:", orderData);

    const state = orderData.state;
    const amount = orderData.amount / 100;
    const orderId = orderData.orderId;
    const paymentDetails = orderData.paymentDetails?.[0] || {};
    const transactionId = paymentDetails.transactionId || null;
    const paymentMethod = paymentDetails.rail?.type === 'UPI'
      ? 'UPI'
      : paymentDetails.splitInstruments?.[0]?.instrument?.type || 'UNKNOWN';
    const utr = paymentDetails.rail?.utr || paymentDetails.rail?.transactionId || null;
    const upiTransactionId = paymentDetails.rail?.upiTransactionId || paymentDetails.rail?.serviceTransactionId || null;
    const authCode = paymentDetails.rail?.authorizationCode || null;
    if (state === "COMPLETED") {
      // Update or insert wallet balance
      const existingWallet = await mySqlQury(
        'SELECT id FROM tbl_wallet WHERE user_id = ?', [userId]
      );

      if (existingWallet.length > 0) {
        await mySqlQury(
          `UPDATE tbl_wallet SET 
             total_amount = total_amount + ?, updated_at = CURRENT_TIMESTAMP 
             WHERE user_id = ?`,
          [amount, userId]
        );
      } else {
        await mySqlQury(
          `INSERT INTO tbl_wallet (user_id, total_amount, created_at, updated_at)
             VALUES (?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`,
          [userId, amount]
        );
      }

      // Insert into transaction history
      await mySqlQury(
        `INSERT INTO tbl_wallet_history (
            user_id, amount, transaction_id, transaction_type,
            payment_method, pg_transaction_id, bank_transaction_id,
            pg_authorization_code, arn, bank_id, brn, created_at, orderId, state
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, ?, ?)`,
        [
          userId, amount, transactionId, 'CREDIT', paymentMethod,
          upiTransactionId, utr, authCode, null, null, null, orderId, state
        ]
      );

      return res.redirect('/domestic-wallet?status=success');

    } else if (state === "PENDING") {
      // Log pending transaction
      await mySqlQury(
        `INSERT INTO tbl_wallet_history (
            user_id, amount, transaction_id, transaction_type,
            payment_method, pg_transaction_id, bank_transaction_id,
            pg_authorization_code, arn, bank_id, brn, created_at, orderId, state
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, ?, ?)`,
        [
          userId, amount, transactionId, 'PENDING', paymentMethod,
          upiTransactionId, utr, authCode, null, null, null, orderId, state
        ]
      );

      return res.redirect('/domestic-wallet?status=pending');

    } else if (state === "FAILED") {
      // Log failed transaction
      await mySqlQury(
        `INSERT INTO tbl_wallet_history (
            user_id, amount, transaction_id, transaction_type,
            payment_method, pg_transaction_id, bank_transaction_id,
            pg_authorization_code, arn, bank_id, brn, created_at, orderId, state
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, ?, ?)`,
        [
          userId, amount, transactionId, 'FAILED', paymentMethod,
          upiTransactionId, utr, authCode, null, null, null, orderId, state
        ]
      );

      return res.redirect('/domestic-wallet?status=failed');
    } else {
      return res.redirect('/domestic-wallet?error=invalid_order');
    }

  } catch (error) {
    console.error('âŒ Error retrieving order status:', error);
    return res.redirect(`/domestic-wallet?error=${encodeURIComponent(error.message)}`);
  }
}
const apiWhatsappInitiatePayment = async (req, res) => {
  try {
    const { amount, merchantTransactionId, merchantUserId } = req.body;
    console.log("merchant user id in the phonepe api", merchantUserId, merchantTransactionId, amount);

    if (!amount || !merchantTransactionId || !merchantUserId) {
      return res.status(400).json({ success: false, message: 'Missing required fields' });
    }

    // Step 1: Authorization to get the token
    const authResponse = await axios.post('https://api.phonepe.com/apis/identity-manager/v1/oauth/token',
      new URLSearchParams({
        client_id: process.env.PHONEPE_CLIENT_ID,
        client_version: '1',
        client_secret: process.env.PHONEPE_CLIENT_SECRET,
        grant_type: 'client_credentials'
      }), {
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      }
    }
    );

    const accessToken = authResponse.data.access_token;

    // Step 2: Payment initiation
    let userId;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;

    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );
      if (loginDetailsResult && loginDetailsResult.length > 0) {
        userId = loginDetailsResult[0].id;
      }
    } else {
      userId = req.user.id;
    }

    if (!userId) {
      throw new Error('Could not determine user ID');
    }

    const payload = {
      merchantOrderId: merchantTransactionId,
      amount: amount * 100, // Convert to paise
      expireAfter: 1200,
      metaInfo: {
        udf1: "additional-information-1",
        udf2: "additional-information-2",
        udf3: "additional-information-3",
        udf4: "additional-information-4",
        udf5: "additional-information-5"
      },
      paymentFlow: {
        type: "PG_CHECKOUT",
        message: "Payment message used for collect requests",
        merchantUrls: {
          redirectUrl: `${process.env.BASE_URL}/api/whatsapp/callback/${userId}/${merchantTransactionId}`
        }
      }
    };

    const paymentResponse = await axios.post('https://api.phonepe.com/apis/pg/checkout/v2/pay',
      payload, {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `O-Bearer ${accessToken}`
      }
    }
    );

    console.log("Payment initiation response:", paymentResponse.data);
    return res.json({
      success: true,
      message: 'Payment initiation successful',
      data: paymentResponse.data
    });

  } catch (error) {
    console.error('âŒ PhonePe payment initiation error:', error);
    return res.status(500).json({
      success: false,
      message: 'Failed to initiate payment',
      error: error.response?.data || error.message
    });
  }
}
const apiWhatsappUseridMerchantOrderId = async (req, res) => {
  try {
    const { userId, merchantOrderId } = req.params;

    // Fetch order status
    const authResponse = await axios.post('https://api.phonepe.com/apis/identity-manager/v1/oauth/token',
      new URLSearchParams({
        client_id: process.env.PHONEPE_CLIENT_ID,
        client_version: '1',
        client_secret: process.env.PHONEPE_CLIENT_SECRET,
        grant_type: 'client_credentials'
      }), {
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
    });

    const accessToken = authResponse.data.access_token;
    if (!accessToken) {
      return res.redirect('/chat-ui?error=unauthorized'); // Updated redirect
    }

    const orderStatusResponse = await axios.get(
      `https://api.phonepe.com/apis/pg/checkout/v2/order/${merchantOrderId}/status?details=false`,
      { headers: { 'Content-Type': 'application/json', 'Authorization': `O-Bearer ${accessToken}` } }
    );

    const orderData = orderStatusResponse.data;
    console.log("Order status response:", orderData);

    const state = orderData.state;
    const amount = orderData.amount / 100; // Convert back to original amount
    const orderId = orderData.orderId;
    const paymentDetails = orderData.paymentDetails?.[0] || {};
    const transactionId = paymentDetails.transactionId || null;
    const paymentMethod = paymentDetails.rail?.type === 'UPI'
      ? 'UPI'
      : paymentDetails.splitInstruments?.[0]?.instrument?.type || 'UNKNOWN';
    const utr = paymentDetails.rail?.utr || paymentDetails.rail?.transactionId || null;
    const upiTransactionId = paymentDetails.rail?.upiTransactionId || paymentDetails.rail?.serviceTransactionId || null;
    const authCode = paymentDetails.rail?.authorizationCode || null;

    if (state === "COMPLETED") {
      // Update or insert wallet balance
      const existingWallet = await mySqlQury(
        'SELECT id FROM whatsapp_wallet WHERE client_id = ?', [userId]
      );

      if (existingWallet.length > 0) {
        await mySqlQury(
          `UPDATE whatsapp_wallet SET 
             balance = balance + ?, updated_at = CURRENT_TIMESTAMP 
             WHERE client_id = ?`,
          [amount, userId]
        );
      } else {
        await mySqlQury(
          `INSERT INTO whatsapp_wallet (client_id, balance, prev_balance, updated_at)
             VALUES (?, ?, 0, CURRENT_TIMESTAMP)`,
          [userId, amount]
        );
      }

      // Insert into transaction history
      await mySqlQury(
        `INSERT INTO whatsapp_wallet_tranx (
            client_id, amount, transaction_id, state,
            m_transaction_id, m_id, transaction_type, payment_method,
            pg_transaction_id, bank_transaction_id, pg_authorization_code, arn, bank_id, brn, created_at, orderId
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, ?)`,
        [
          userId, amount, transactionId, 'COMPLETED',
          null, null, 'CREDIT', paymentMethod,
          upiTransactionId, utr, authCode, null, null, null, orderId
        ]
      );

      return res.redirect('/chat-ui?status=success'); // Updated redirect

    } else if (state === "PENDING") {
      // Log pending transaction
      await mySqlQury(
        `INSERT INTO whatsapp_wallet_tranx (
            client_id, amount, transaction_id, state,
            m_transaction_id, m_id, transaction_type, payment_method,
            pg_transaction_id, bank_transaction_id, pg_authorization_code, arn, bank_id, brn, created_at, orderId
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, ?)`,
        [
          userId, amount, transactionId, 'PENDING',
          null, null, 'PENDING', paymentMethod,
          upiTransactionId, utr, authCode, null, null, null, orderId
        ]
      );

      return res.redirect('/chat-ui?status=pending'); // Updated redirect

    } else if (state === "FAILED") {
      // Log failed transaction
      await mySqlQury(
        `INSERT INTO whatsapp_wallet_tranx (
            client_id, amount, transaction_id, state,
            m_transaction_id, m_id, transaction_type, payment_method,
            pg_transaction_id, bank_transaction_id, pg_authorization_code, arn, bank_id, brn, created_at, orderId
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, ?)`,
        [
          userId, amount, transactionId, 'FAILED',
          null, null, 'FAILED', paymentMethod,
          upiTransactionId, utr, authCode, null, null, null, orderId
        ]
      );

      return res.redirect('/chat-ui?status=failed'); // Updated redirect
    } else {
      return res.redirect('/chat-ui?error=invalid_order'); // Updated redirect
    }

  } catch (error) {
    console.error('âŒ Error retrieving order status:', error);
    return res.redirect(`/chat-ui?error=${encodeURIComponent(error.message)}`); // Updated redirect
  }
}
const domesticWallet = async (req, res, next) => {
  try {
    const selectedClientId = Number(req.user.selectedClientId || 1);
    const isAdminView = selectedClientId === 1;

    // 1) Resolve accountUserId (only by id â€” no login_id, no extra cols)
    const accountUserId = isAdminView ? req.user.id : selectedClientId;

    // 2) Fetch login details (only allowed columns)
    const [loginDetails] = await mySqlQury(
      `SELECT id, first_name, role_name, company_name, logo_path
       FROM tbl_admin
       WHERE id = ?`,
      [accountUserId]
    );

    // 3) Wallet (by accountUserId)
    const [walletRow] = await mySqlQury(
      `SELECT id, user_id, total_amount, created_at, updated_at
       FROM tbl_wallet
       WHERE user_id = ?`,
      [accountUserId]
    );
    const walletData = walletRow || null;
    const walletBalance = walletRow ? walletRow.total_amount : 0;

    const walletHistory = await mySqlQury(
      `SELECT * FROM tbl_wallet_history
       WHERE user_id = ?
       ORDER BY created_at DESC`,
      [accountUserId]
    );

    const walletTransactions = await mySqlQury(
      `SELECT * FROM tbl_lr_wallet_tnx
       WHERE user_id = ?
       ORDER BY created_at DESC`,
      [accountUserId]
    );

    // 4) Orders
    const result = isAdminView
      ? await mySqlQury(
          `SELECT * FROM tbl_create_lr
           WHERE status = 0
           ORDER BY lr_id DESC`
        )
      : await mySqlQury(
          `SELECT * FROM tbl_create_lr
           WHERE status = 0 AND client_id = ?
           ORDER BY lr_id DESC`,
          [accountUserId]
        );

    // 5) Permissions + current user profile (only allowed columns)
    const activeTopics = await mySqlQury(
      `SELECT topic_id FROM tbl_permissions
       WHERE role_id = ? AND is_active = 1`,
      [req.user.role]
    );
    const activeTopicIds = Array.isArray(activeTopics)
      ? activeTopics.map(t => Number(t.topic_id))
      : [];

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path
       FROM tbl_admin
       WHERE id = ?`,
      [req.user.id]
    );

    // 6) Render
    res.render('pages/domestic-wallet', {
      title: 'Wallet',
      data: result,
      bodyClass: 'profile-page',
      activePage: 'profile',
      activeTopicIds,
      loginDetails: loginDetails || {},
      role_data: req.user,
      profile,
      clientId: accountUserId,
      walletData,
      walletHistory,
      walletTransactions,
      walletBalance,
      role: req.user.role,
    });
  } catch (error) {
    console.error('domesticWallet error:', error);
    next(error);
  }
};


const getforwarderOnboarding = async (req, res, next) => {
  try {
    const accessdata = await access(req.user);
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    const lang_data = req.language_data;
    const language_name = req.lang;
    let walletBalance = 0;
    let vasService = 1;
    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = ? ORDER BY id DESC LIMIT 3`,
      [role_data.id]
    );

    let loginDetails = null;
    let clientId = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,company_name,vas,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetailsResult[0].vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [req.user.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    // Fetch forwarder data
    const result = await mySqlQury('SELECT forwarder_name,company_name,forwarder_type FROM tbl_vendor_details');
    const states = await mySqlQury('SELECT DISTINCT state FROM tbl_master_pincode');
    const plans = await mySqlQury('SELECT * FROM plans');
    console.log("plans data", plans);

    // Get active topics
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    let activeTopicIds = [];
    if (activeTopics && Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Render the EJS template
    res.render('pages/forwarder-onboarding', {
      role_data,
      accessdata,
      title: 'Forwarder Onboarding',
      layout: 'partials/layout-vertical',
      lang_data,
      language_name,
      notification_data,
      result,
      states: states.map(row => row.state),
      activeTopicIds,
      loginDetails: loginDetails || {},
      profile,
      clientId: loginDetails?.id,
      walletBalance,
      vasService,
      plans, role
    });
  } catch (error) {
    console.error('Error in forwarder onboarding:', error);
    res.status(500).send('Internal Server Error');
  }
}
const userManagement = async (req, res, next) => {
  try {
    // 1) Resolve the selected client context (parent)
    const selectedClientId = Number(req.user?.selectedClientId);
    if (!selectedClientId) {
      return res.status(400).send('Selected client ID is not set.');
    }
    // 2) Fetch the selected client's basic profile (used in header/UI)
    const [clientProfile] = await mySqlQury(
      `SELECT id, first_name, last_name, role_name, company_name, logo_path
         FROM tbl_admin
        WHERE id = ?
        LIMIT 1`,
      [selectedClientId]
    );

    // 3) Wallet balance for the selected client (if any)
    const [walletRow] = await mySqlQury(
      `SELECT total_amount
         FROM tbl_wallet
        WHERE user_id = ?
        LIMIT 1`,
      [selectedClientId]
    );
    const walletBalance = walletRow?.total_amount || 0;

    // 4) Pull ONLY users under this client (parent_id = selectedClientId), sorted by level
    const admins = await mySqlQury(
      `SELECT id, first_name, last_name, email, role, role_id, level, reporting_id,
              is_active, company_name, logo_path
         FROM tbl_admin
        WHERE parent_id = ?
        ORDER BY level ASC, first_name ASC, last_name ASC`,
      [selectedClientId]
    );

    // 5) Split into active/inactive (no â€œSELECT *â€ over the whole table)
    const activeAdmins = admins.filter(a => Number(a.is_active) === 1);
    const inactiveAdmins = admins.filter(a => Number(a.is_active) === 0);

    // 6) Roles belonging to the selected client (kept small & relevant)
    const roles = await mySqlQury(
      `SELECT id, name
         FROM roles
        WHERE client_id = ?
        ORDER BY name ASC`,
      [selectedClientId]
    );
 
    // 7) Render
    return res.render('pages/user-management', {
      title: 'User Manager',
      activeAdmins,
      inactiveAdmins,
      loginDetails: clientProfile || {},   // for your header/card
      profile: clientProfile || null,      // if template expects 'profile'
      walletBalance,
      roles,
      clientId: selectedClientId,
    });
  } catch (error) {
    console.error('Error in userManagement:', error);
    return next(error);
  }
};

const adminDeactivate = async (req, res) => {
  const userId = req.body.id; // Ensure the property matches your request payload

  try {
    // Update the is_active field to the opposite value
    const query = 'UPDATE tbl_admin SET is_active = NOT is_active WHERE id = ?';
    const results = await mySqlQury(query, [userId]);

    // Check if any rows were affected (user found and updated)
    if (results.affectedRows > 0) {
      res.json({ success: true, message: 'User status updated successfully' });
    } else {
      res.status(404).json({ error: 'User not found' });
    }
  } catch (error) {
    console.error('Error updating user status:', error);
    return res.status(500).json({ error: 'Failed to update user status' });
  }
}
const apigetReportingUserClientid = async (req, res) => {
  const clientId = req.params.clientId;

  try {
    const users = await mySqlQury('SELECT * FROM tbl_admin WHERE client_id = ?', [clientId]);
    res.json(users);
  } catch (error) {
    console.error('Error fetching reporting users:', error);
    res.status(500).json({ error: 'An error occurred while fetching users' });
  }
}
const getClientOnboarding = async (req, res, next) => {
  try {
    console.log('in unprocessed orders')
    const accessdata = await access(req.user);
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    const lang_data = req.language_data;
    const language_name = req.lang;
    let walletBalance = 0;
    let vasService = 1;
    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = ? ORDER BY id DESC LIMIT 3`,
      [role_data.id]
    );

    // Fetch LR data
    const result = await mySqlQury(`
        SELECT id, 
               Tagged_api, 
               aggrigator_type AS category, 
               service_type, 
               logo_path, 
               Aggrigator_company_name AS company_name,
               'Aggrigator' AS type 
        FROM tbl_aggrigator
        WHERE agg_assigned_status = 'NA'
      `);
    console.log("result", result);

    const states = await mySqlQury(`SELECT DISTINCT state FROM tbl_master_pincode`);

    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    let loginDetails = null;
    let clientId = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,company_name,vas,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetailsResult[0].vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [req.user.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    let activeTopicIds = [];
    if (activeTopics && Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    res.render('pages/client-onboarding', {
      role_data: role_data,
      accessdata: accessdata,
      bodyClass: 'profile-page',
      activePage: 'profile',
      title: 'Client Onboarding',
      layout: 'partials/layout-vertical',
      lang_data: lang_data,
      language_name: language_name,
      notification_data: notification_data,
      result: result,
      states: states.map(row => row.state),
      activeTopicIds,
      loginDetails: loginDetails || {},
      profile,
      clientId,
      walletBalance,
      vasService,
      role
    });

  } catch (error) {
    console.log('error', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
const getClientList = async (req, res, next) => {
  try {
    const accessdata = await access(req.user);
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    const lang_data = req.language_data;
    const language_name = req.lang;
    let walletBalance = 0;
    let vasService = 1;
    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = ? ORDER BY id DESC LIMIT 3`,
      [role_data.id]
    );

    let loginDetails = null;
    let clientId = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,company_name,vas,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetailsResult[0].vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [req.user.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    let clientData;
    if (role === 1) {
      // Get all clients for admin
      const clientQuery = `
          SELECT c.*, a.email, a.phone_no, a.country_code,
                 GROUP_CONCAT(cc.name) as contact_names,
                 GROUP_CONCAT(cc.phone) as contact_phones,
                 GROUP_CONCAT(cc.email) as contact_emails,
                 GROUP_CONCAT(cc.department) as departments
          FROM tbl_admin c
          LEFT JOIN tbl_admin a ON c.login_id = a.id
          LEFT JOIN tbl_admin_contacts cc ON c.id = cc.client_new_id
          GROUP BY c.id
        `;
      clientData = await mySqlQury(clientQuery);
    } else {
      // Get clients based on reporting relationship
      const clientQuery = `
          SELECT c.*, a.email, a.phone_no, a.country_code,
                 GROUP_CONCAT(cc.name) as contact_names,
                 GROUP_CONCAT(cc.phone) as contact_phones,
                 GROUP_CONCAT(cc.email) as contact_emails,
                 GROUP_CONCAT(cc.department) as departments
          FROM tbl_admin c
          LEFT JOIN tbl_admin a ON c.login_id = a.id
          LEFT JOIN tbl_admin_contacts cc ON c.id = cc.client_new_id
          WHERE c.login_id = ? OR a.reporting_id = ?
          GROUP BY c.id
        `;
      clientData = await mySqlQury(clientQuery, [relatedClientId, relatedClientId]);
    }

    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    let activeTopicIds = [];
    if (activeTopics && Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    res.render('pages/client-list', {
      role_data,
      accessdata,
      bodyClass: 'profile-page',
      activePage: 'profile',
      title: 'Client List',
      layout: 'partials/layout-vertical',
      lang_data,
      language_name,
      notification_data,
      activeTopicIds,
      loginDetails: loginDetails || {},
      profile,
      clientData,
      clientId,
      walletBalance,
      vasService, role
    });

  } catch (error) {
    console.error('Error fetching client list:', error);
    next(error);
  }
}
const deleteClientId = async (req, res) => {
  await mySqlQury('START TRANSACTION');

  try {
    const clientId = req.params.id;

    // First, get the admin ID associated with this client
    const [clientData] = await mySqlQury(
      'SELECT login_id FROM tbl_admin WHERE id = ?',
      [clientId]
    );

    if (!clientData || !clientData.login_id) {
      await mySqlQury('ROLLBACK');
      return res.status(404).json({
        success: false,
        message: 'Client not found'
      });
    }

    // Delete from tbl_admin (this will cascade to other tables)
    await mySqlQury(
      'DELETE FROM tbl_admin WHERE id = ?',
      [clientData.login_id]
    );

    await mySqlQury('COMMIT');
    res.json({
      success: true,
      message: 'Client deleted successfully'
    });

  } catch (error) {
    await mySqlQury('ROLLBACK');
    console.error('Error deleting client:', error);
    res.status(500).json({
      success: false,
      message: 'Error deleting client'
    });
  }
}
const apiClientId = async (req, res) => {
  try {
    const clientId = req.params.id;

    // Get client details
    const clientQuery = `
        SELECT c.*, a.email, a.phone_no, a.country_code
        FROM tbl_admin c
        LEFT JOIN tbl_admin a ON c.login_id = a.id
        WHERE c.id = ?
      `;
    const [clientDetails] = await mySqlQury(clientQuery, [clientId]);

    // Get contact details
    const contactsQuery = `
        SELECT * FROM tbl_admin_contacts
        WHERE client_new_id = ?
      `;
    const contacts = await mySqlQury(contactsQuery, [clientId]);

    res.json({
      success: true,
      client: clientDetails,
      contacts
    });

  } catch (error) {
    console.error('Error fetching client details:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch client details'
    });
  }
}
const deleteapiClientId = async (req, res) => {
  try {
    const clientId = req.params.id;

    await mySqlQury('START TRANSACTION');

    // Delete contacts
    await mySqlQury('DELETE FROM tbl_admin_contacts WHERE client_new_id = ?', [clientId]);

    // Get login_id before deleting client
    const [client] = await mySqlQury('SELECT login_id FROM tbl_admin WHERE id = ?', [clientId]);

    // Delete client
    await mySqlQury('DELETE FROM tbl_admin WHERE id = ?', [clientId]);

    // Delete from admin table
    if (client && client.login_id) {
      await mySqlQury('DELETE FROM tbl_admin WHERE id = ?', [client.login_id]);
    }

    await mySqlQury('COMMIT');

    res.json({
      success: true,
      message: 'Client deleted successfully'
    });

  } catch (error) {
    await mySqlQury('ROLLBACK');
    console.error('Error deleting client:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete client'
    });
  }
}
const apiClientIdParental = async (req, res) => {
  await mySqlQury('START TRANSACTION');
  try {
    const clientId = req.params.id;
    const formData = req.body;
    console.log("Form Data:", formData);
    console.log("Client ID:", clientId);
    console.log("Uploaded File:", req.file);

    let logoPath = null;

    // Fetch current logo path from DB before updating
    const existingClient = await mySqlQury('SELECT logo_path FROM tbl_admin WHERE id = ?', [clientId]);
    const oldLogoPath = existingClient[0]?.logo_path;

    if (req.file) {
      logoPath = `assets/images/${req.file.filename}`;
    }

    // Remove old logo if it exists and new file is uploaded
    if (oldLogoPath && req.file) {
      const oldPath = path.join(__dirname, '..', 'public', oldLogoPath);
      fs.unlink(oldPath, (err) => {
        if (err) console.error('Error deleting old logo:', err);
      });
    }

    // Update new logo path in the database
    await mySqlQury('UPDATE tbl_admin SET logo_path = ? WHERE id = ?', [logoPath, clientId]);

    // Update other client details
    const updateClientSql = `
        UPDATE tbl_admin SET
          first_name = ?, company_name = ?, mobile = ?, email = ?, website = ?,
          company_address = ?, company_country = ?, company_state = ?, company_city = ?,
          from_date = ?, from_to = ?, gst = ?, account_name = ?, billing_cycle = ?,
          account_number = ?, choose_bank = ?,payment_system = ?
        WHERE id = ?
      `;

    const clientValues = [
      formData.clientName, formData.companyName, formData.client_mobile, formData.client_Email,
      formData.website, formData.companyAddress, formData.companyCountry, formData.companyState,
      formData.companyDistrict, formData.fromDate, formData.fromTo, formData.gstNo,
      formData.Bank_account_name, formData.billingCycle, formData.accountNumber,
      formData.chooseBank, formData.paymentSystem, clientId
    ];

    await mySqlQury(updateClientSql, clientValues);

    // Update admin details
    const updateAdminSql = `
        UPDATE tbl_admin SET first_name = ?, company_name = ?, phone_no = ?, email = ?
        WHERE id = (SELECT login_id FROM tbl_admin WHERE id = ?)
      `;

    const adminValues = [
      formData.clientName, formData.companyName, formData.client_mobile, formData.client_Email, clientId
    ];

    await mySqlQury(updateAdminSql, adminValues);

    await mySqlQury('COMMIT');
    res.json({ success: true, message: 'Client details updated successfully' });

  } catch (error) {
    await mySqlQury('ROLLBACK');
    console.error('Error updating client:', error);
    res.status(500).json({ success: false, message: 'Failed to update client details' });
  }
}
const apiClientVas = async (req, res) => {
  const { client_id, vas } = req.body;

  if (typeof client_id === 'undefined' || typeof vas === 'undefined') {
    return res.status(400).json({ success: false, message: 'Missing client_id or vas value' });
  }

  try {
    await mySqlQury(
      'UPDATE tbl_admin SET vas = ? WHERE id = ?',
      [vas, client_id]
    );

    res.json({ success: true, message: 'VAS status updated successfully' });
  } catch (error) {
    console.error('DB Error:', error);
    res.status(500).json({ success: false, message: 'Database error' });
  }
}
const apiClientIdDepartmental = async (req, res) => {
  await mySqlQury('START TRANSACTION');
  try {
    const clientId = req.params.id;
    const contacts = JSON.parse(req.body.contacts || '[]');

    // Delete existing contacts
    await mySqlQury(
      'DELETE FROM tbl_admin_contacts WHERE client_new_id = ?',
      [clientId]
    );

    // Insert new contacts if any exist
    if (contacts.length > 0) {
      const contactValues = contacts.map(contact => [
        clientId,
        contact.name || null,
        contact.phone || null,
        contact.email || null,
        contact.designation || null,
        contact.department
      ]);

      const insertContactsSql = `
          INSERT INTO tbl_admin_contacts 
          (client_new_id, name, phone, email, designation, department)
          VALUES ?
        `;
      await mySqlQury(insertContactsSql, [contactValues]);
    }

    // Handle logo update


    await mySqlQury('COMMIT');
    res.json({
      success: true,
      message: 'Departmental information updated successfully'
    });

  } catch (error) {
    await mySqlQury('ROLLBACK');
    console.error('Error updating departmental info:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update departmental information'
    });
  }
}
const postUpdateReturnStatus = async (req, res, next) => {
  const { id, is_active } = req.body; // id of the return entry and the status to update
  console.log("in rteurn atatys status", id, is_active)

  try {
    // Ensure the user is authorized to update this entry (you can customize the logic here)
    if (!id || is_active === undefined) {
      return res.status(400).json({ error: 'Invalid input data' });
    }

    // Update the 'is_active' status in the warehouse_return_add table
    const query = 'UPDATE warehouse_return_add SET is_active = ? WHERE id = ?';
    const result = await mySqlQury(query, [is_active, id]);

    if (result.affectedRows > 0) {
      return res.status(200).json({ success: 'Return status updated successfully' });
    } else {
      return res.status(404).json({ error: 'Return entry not found' });
    }
  } catch (error) {
    console.error('Error updating return status:', error);
    return res.status(500).json({ error: 'Server error' });
  }
}
const updatePickupStatus = async (req, res, next) => {
  const { id, is_active } = req.body; // id of the pickup entry and the status to update

  console.log("in pickup status", id, is_active)
  try {
    // Ensure the user is authorized to update this entry (you can customize the logic here)
    if (!id || is_active === undefined) {
      return res.status(400).json({ error: 'Invalid input data' });
    }

    // Update the 'is_active' status in the warehouse_pickup_add table
    const query = 'UPDATE warehouse_pickup_add SET is_active = ? WHERE id = ?';
    const result = await mySqlQury(query, [is_active, id]);

    if (result.affectedRows > 0) {
      return res.status(200).json({ success: 'Pickup status updated successfully' });
    } else {
      return res.status(404).json({ error: 'Pickup entry not found' });
    }
  } catch (error) {
    console.error('Error updating pickup status:', error);
    return res.status(500).json({ error: 'Server error' });
  }
}
const getforwarderList = async (req, res, next) => {
  try {
    const accessdata = await access(req.user);
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    const relatedClientId = req.user.clientId || 1;
    const lang_data = req.language_data;
    const language_name = req.lang;
    let walletBalance = 0;
    let vasService = 0;

    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = ? ORDER BY id DESC LIMIT 3`,
      [role_data.id]
    );

    const result = await mySqlQury(
      `SELECT * FROM  tbl_courier_details ORDER BY id DESC;`
    );

    const states = await mySqlQury(
      `SELECT DISTINCT state FROM tbl_master_pincode`
    );

    const plans = await mySqlQury('SELECT * FROM plans');

    let loginDetails = null;
    let clientId = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,company_name,vas,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [req.user.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    let activeTopicIds = [];
    if (activeTopics && Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }
    console.log("result", result)

    return res.render('pages/forwarder-list', {
      role_data,
      bodyClass: 'profile-page',
      activePage: 'profile',
      accessdata,
      lang_data,
      language_name,
      notification_data,
      result,
      states: states.map(row => row.state),
      plans,
      layout: 'partials/layout-vertical',
      title: 'Forwarder List',
      activeTopicIds,
      loginDetails: loginDetails || {},
      profile,
      clientId,
      walletBalance,
      vasService, role
    });

  } catch (error) {
    console.error('Error fetching data for forwarder list:', error);
    next(error);
  }
}
const postpredispatchGetcitiesAndUpdateStatus = async (req, res) => {
  const selectedStates = req.body.selectedState || [];
  const excludedCities = req.body.excludedCities || [];

  // console.log("Fetching cities for states:", selectedStates, "excluding cities:", excludedCities);

  try {
    let citiesQuery;
    let queryParams;

    // If excludedCities is not empty, use the NOT IN clause
    if (excludedCities.length > 0) {
      citiesQuery = 'SELECT DISTINCT city FROM tbl_master_pincode WHERE state IN (?) AND city NOT IN (?)';
      queryParams = [selectedStates, excludedCities];
    } else {
      // If excludedCities is empty, do not use the NOT IN clause
      citiesQuery = 'SELECT DISTINCT city FROM tbl_master_pincode WHERE state IN (?)';
      queryParams = [selectedStates];
    }

    // Fetch cities for the selected states
    const cities = await mySqlQury(citiesQuery, queryParams);
    // console.log("Fetched cities:", cities); // Log the fetched cities

    // Respond with the list of cities for the selected states
    res.json({
      cities: cities.map(row => row.city)
    });
  } catch (error) {
    console.error('Error fetching cities:', error);
    res.status(500).send(`Error fetching cities: ${error.message}`);
  }
}
const postpreStateBasedOnClients = async (req, res) => {
  // Extract excludedStates from request body
  const excludedStates = Array.isArray(req.body.excludedStates) ? req.body.excludedStates : [];
  console.log("Fetching states, excluding:", excludedStates); // Log excludedStates for debugging

  try {
    let statesQuery;
    let queryParams = [];

    // Handle cases where excludedStates is an empty array
    if (excludedStates.length === 0) {
      // Fetch all distinct states
      statesQuery = 'SELECT DISTINCT state FROM tbl_master_pincode';
    } else {
      // Create placeholders for the excluded states
      const placeholders = excludedStates.map(() => '?').join(',');
      statesQuery = `SELECT DISTINCT state FROM tbl_master_pincode WHERE state NOT IN (${placeholders})`;
      queryParams = excludedStates;
    }

    // Log the query and parameters for debugging
    console.log("Query:", statesQuery);
    console.log("Parameters:", queryParams);

    // Fetch states from the database
    const states = await mySqlQury(statesQuery, queryParams);

    // Respond with the list of states
    res.json({
      states: states.map(row => row.state)  // Extract only the state names
    });
  } catch (error) {
    console.error('Error fetching states:', error);

    // Respond with a standardized error message
    res.status(500).json({
      success: false,
      message: 'please select state or Not.',
      error: error.message
    });
  }
}
const getCities = async (req, res) => {
  try {
    // Convert state(s) from query to an array
    const states = Array.isArray(req.query.states) ? req.query.states : [req.query.states];

    // Use SQL IN clause to handle multiple states
    const placeholders = states.map(() => '?').join(','); // Create placeholders like ?,?,?
    const query = `SELECT DISTINCT city FROM tbl_master_pincode WHERE state IN (${placeholders})`;

    // Execute the query with the array of states
    const result = await mySqlQury(query, states);

    // Respond with the cities
    res.json(result);
  } catch (error) {
    console.error('Error fetching cities:', error);
    res.status(500).send(`Error fetching cities: ${error.message}`);
  }
}
const apiIntegration = async (req, res, next) => {
  const [loginDetails] = await mySqlQury(
    'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?', [req.user.id]
  );

  // Fetch courier details from non_dispatch_dtdc table
  const courierDetails = await mySqlQury(
    'SELECT id, courier_name, api_status, category FROM non_dispatch_dtdc'
  );

  // Render the EJS template and pass courierDetails and loginDetails
  res.render('apps/api-integration-list', {
    title: 'Courier Settings',
    courierDetails,
    loginDetails
  });
}
const getWarehousebyClientEcom = async (req, res, next) => {
  try {
    const realclientID = req.user.selectedClientId;
    console.log("req user in add warehouse", req.user);

    if (!realclientID) {
      return res.status(400).json({ error: 'Client ID is required' });
    }

    let warehouses;
    let userIds = [];

    if (realclientID == 1) {
      // Admin: Get ALL user IDs from kyc_submissions where segment_type = 'ecom'
      const kycUsers = await mySqlQury(`
        SELECT DISTINCT user_id 
        FROM kyc_submissions 
        WHERE segment_type = 'ecom'`
      );
      userIds = kycUsers.map(user => user.user_id);
      
      // Admin: Get warehouses for ALL clients that have ecom segment
      if (userIds.length > 0) {
        const placeholders = userIds.map(() => '?').join(',');
        warehouses = await mySqlQury(`
          SELECT warehouse_id, serial, warehouse_name, warehouse_address 
          FROM tbl_add_warehouse 
          WHERE client_id IN (${placeholders})`, userIds
        );
      } else {
        warehouses = [];
      }
    } else {
      // Regular client: First check if this client has segment_type = 'ecom' in kyc_submissions
      const kycCheck = await mySqlQury(`
        SELECT user_id 
        FROM kyc_submissions 
        WHERE user_id = ? AND segment_type = 'ecom'`, [realclientID]
      );
      
      if (kycCheck.length > 0) {
        // Client has ecom segment, get their user_id
        userIds = [kycCheck[0].user_id];
        
        // Get warehouses for this specific client
        warehouses = await mySqlQury(`
          SELECT warehouse_id, serial, warehouse_name, warehouse_address 
          FROM tbl_add_warehouse 
          WHERE client_id = ?`, [realclientID]
        );
      } else {
        // Client doesn't have ecom segment
        warehouses = [];
        userIds = [];
      }
    }

    // Send the warehouse data and user IDs as a JSON response
    res.json({ 
      warehouses, 
      userIds,
      realclientID,
      hasEcomSegment: userIds.length > 0
    });
  } catch (error) {
    console.error("Error fetching warehouses:", error);
    next(error);
  }
}
const getWarehousebyClientExpress = async (req, res, next) => {
  try {
    const realclientID = req.user.selectedClientId;
    console.log("req user in add warehouse", req.user);

    if (!realclientID) {
      return res.status(400).json({ error: 'Client ID is required' });
    }

    let warehouses;
    let userIds = [];

    if (realclientID == 1) {
      // Admin: Get ALL user IDs from kyc_submissions where segment_type = 'express'
      const kycUsers = await mySqlQury(`
        SELECT DISTINCT user_id 
        FROM kyc_submissions 
        WHERE segment_type = 'express'`
      );
      userIds = kycUsers.map(user => user.user_id);
      
      // Admin: Get warehouses for ALL clients that have express segment
      if (userIds.length > 0) {
        const placeholders = userIds.map(() => '?').join(',');
        warehouses = await mySqlQury(`
          SELECT warehouse_id, serial, warehouse_name, warehouse_address 
          FROM tbl_add_warehouse 
          WHERE client_id IN (${placeholders})`, userIds
        );
      } else {
        warehouses = [];
      }
    } else {
      // Regular client: First check if this client has segment_type = 'express' in kyc_submissions
      const kycCheck = await mySqlQury(`
        SELECT user_id 
        FROM kyc_submissions 
        WHERE user_id = ? AND segment_type = 'express'`, [realclientID]
      );
      
      if (kycCheck.length > 0) {
        // Client has express segment, get their user_id
        userIds = [kycCheck[0].user_id];
        
        // Get warehouses for this specific client
        warehouses = await mySqlQury(`
          SELECT warehouse_id, serial, warehouse_name, warehouse_address 
          FROM tbl_add_warehouse 
          WHERE client_id = ?`, [realclientID]
        );
      } else {
        // Client doesn't have express segment
        warehouses = [];
        userIds = [];
      }
    }

    // Send the warehouse data and user IDs as a JSON response
    res.json({ 
      warehouses, 
      userIds,
      realclientID,
      hasExpressSegment: userIds.length > 0
    });
  } catch (error) {
    console.error("Error fetching warehouses:", error);
    next(error);
  }
}
const ltlCreateBulkOrder = async (req, res, next) => {
  try {
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;

    let loginDetails = null;
    let clientId = 0;
    let walletBalance = 0;
    // let vasService = 0;
    console.log("req.user", req.user)

    // Simplified logic - always set clientId
    clientId = selectedClientId === 1 ? role_data.id : selectedClientId;

    // Get login details based on selectedClientId
    if (selectedClientId === 1) {
      // For admin (selectedClientId = 1), get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      // vasService = 1;
    } else {
      // For specific client, get details from tbl_admin using selectedClientId
      const clientDetails = await mySqlQury(
        'SELECT id, first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [selectedClientId]
      );
      if (clientDetails && clientDetails.length > 0) {
        loginDetails = clientDetails[0];
      }
      
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [selectedClientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      // vasService = 1;
    }

    const lang_data = req.language_data;
    const language_name = req.lang;
    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = '${role_data.id}' ORDER BY id DESC LIMIT 3`
    );

    let clients;
    if (selectedClientId === 1) {
      clients = await mySqlQury('SELECT id, company_name FROM tbl_admin');
    } else {
      clients = [{ id: selectedClientId, company_name: 'Client Company' }];
    }

    // Get active topics
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Extract active topic IDs
    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    res.render('pages/ltl/create-bulk-order', {
      title: 'Bulk Order Creation',
      layout: 'partials/layout-vertical',
      bodyClass: 'profile-page',
      activePage: 'profile',
      role_data: role_data,
      lang_data: lang_data,
      language_name: language_name,
      notification_data: notification_data,
      clients,
      activeTopicIds,
      loginDetails: loginDetails || {}, // Provide empty object as fallback
      profile,
      clientId,
      walletBalance,
      // vasService
    });

  } catch (error) {
    console.error("Error:", error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
}
const ecomCreateBulkOrder = async (req, res, next) => {
  try {
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    

    let loginDetails = null;
    let clientId = 0;
    let walletBalance = 0;
    let vasService = 0;
    console.log("req.user", req.user)

    // Simplified logic - always set clientId
    clientId = selectedClientId === 1 ? role_data.id : selectedClientId;

    // Get login details based on selectedClientId
    if (selectedClientId === 1) {
      // For admin (selectedClientId = 1), get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    } else {
      // For specific client, get details from tbl_admin using selectedClientId
      const clientDetails = await mySqlQury(
        'SELECT id, first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [selectedClientId]
      );
      if (clientDetails && clientDetails.length > 0) {
        loginDetails = clientDetails[0];
      }
      
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [selectedClientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    const lang_data = req.language_data;
    const language_name = req.lang;
    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = '${role_data.id}' ORDER BY id DESC LIMIT 3`
    );

    let clients;
    if (selectedClientId === 1) {
      clients = await mySqlQury('SELECT id, company_name FROM tbl_admin');
    } else {
      clients = [{ id: selectedClientId, company_name: 'Client Company' }];
    }

    // Get active topics
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Extract active topic IDs
    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    res.render('pages/ecom/create-bulk-order', {
      title: 'Bulk Order Creation',
      layout: 'partials/layout-vertical',
      bodyClass: 'profile-page',
      activePage: 'profile',
      role_data: role_data,
      lang_data: lang_data,
      language_name: language_name,
      notification_data: notification_data,
      clients,
      activeTopicIds,
      loginDetails: loginDetails || {}, // Provide empty object as fallback
      profile,
      clientId,
      walletBalance,
      vasService, role
    });

  } catch (error) {
    console.error("Error:", error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
}
const expressCreateBulkOrder = async (req, res, next) => {
  try {
    const role_data = req.user;
    const role = req.user.role;
    const relatedClientId = req.user.clientId || 1;

    let loginDetails = null;
    let clientId = 0;
    let walletBalance = 0;
    let vasService = 0;

    // Simplified logic - just use the user's own client_id
    clientId = req.user.selectedClientId || req.user.id;
    
    // Get user details
    const userDetails = await mySqlQury(
      'SELECT id, first_name, company_name, logo_path, role_name FROM tbl_admin WHERE id = ?',
      [clientId]
    );

    if (userDetails && userDetails.length > 0) {
      loginDetails = userDetails[0];
      // vasService = userDetails[0].vas || 1;
    }

    // Get wallet balance
    const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
    walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

    const lang_data = req.language_data;
    const language_name = req.lang;
    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = '${role_data.id}' ORDER BY id DESC LIMIT 3`
    );

    // Simplified clients logic - just get the current user's company
    let clients = [];
    if (loginDetails?.id) {
      clients = await mySqlQury(
        'SELECT id, company_name FROM tbl_admin WHERE id = ?',
        [loginDetails.id]
      );
    }

    // Get active topics
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Extract active topic IDs
    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    res.render('pages/express/create-bulk-order', {
      title: 'Bulk Order Creation',
      layout: 'partials/layout-vertical',
      bodyClass: 'profile-page',
      activePage: 'profile',
      role_data: role_data,
      lang_data: lang_data,
      language_name: language_name,
      notification_data: notification_data,
      clients,
      activeTopicIds,
      loginDetails: loginDetails || {}, // Provide empty object as fallback
      profile,
      clientId,
      walletBalance,
      //    vasService,
      role
    });

  } catch (error) {
    console.error("Error:", error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
}
const productQuery = `
   INSERT INTO tbl_unprocessed_order (
              order_id, po_no, consignee_name, consignee_phone, consignee_email, consignee_address,
              order_date, payment_type, total_weight, total_boxes, origin, destination_state,
              destination_city, destination_pincode, Amount, Check_Favour_Of, Check_Amount,
              origin_city, origin_state, origin_pincode, warehouse_address, warehouse_contact_person,
              client_id, warehouse_email,order_type,Invoice_amount,invoice_no,weight_unit,warehouse_name
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?,?,?,?);
          `;


const productDetailsQuery = `
    INSERT INTO tbl_products (product_name, category, quantity, order_value, po_no) 
    VALUES (?, ?, ?, ?, ?);
  `;

const boxDimensionsQuery = `
    INSERT INTO tbl_boxes_dimension (po_no, boxes, DIMENSION, unit) 
    VALUES (?, ?, ?, ?);
  `;
const customerDetailsQuery = `
    INSERT INTO tbl_customer_details (
      name, email, phone, address, pincode, state, city, nearby, store_id
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?);
  `;
const dispatchLRInsertQuery = `
                        INSERT INTO tbl_dispatch_lr (
                            order_id, po_no, ds_docket_no
                        ) VALUES (?, ?, ?);
  `;
const postUploadExcelCreateOrder = async (req, res) => {
  console.log("In the upload bulk order route for E-commerce");
  console.log("request body", req.body);
  
  const warehouseId = req.body.choosenWarehouse;
  let clientid = req.body.clientID;
  console.log("warehouseId", warehouseId);
  console.log("clientid", clientid);

  if (!req.files || req.files.length === 0) {
    return res.status(400).json({ success: false, message: 'Please upload a valid Excel file.' });
  }

  // Path to the uploaded file
  const filePath = req.files[0].path;
  console.log("Uploaded file path:", filePath);

  try {
    await mySqlQury('START TRANSACTION');
    
    // Handle client ID logic (similar to single order creation)
    if (clientid == 1) {
      const [warehouseDetails] = await mySqlQury(`SELECT client_id FROM tbl_add_warehouse WHERE serial = ?`, [warehouseId]);
      clientid = warehouseDetails.client_id;
    }
    console.log("real client id is", clientid);

    // Load the Excel workbook
    const workbook = xlsx.readFile(filePath);
    const sheetNames = workbook.SheetNames;
    console.log("Sheet names:", sheetNames);

    // Process the main sheet (should be Sheet1 based on the structure)
    const mainSheet = sheetNames[0]; // First sheet
    const sheetData = xlsx.utils.sheet_to_json(workbook.Sheets[mainSheet]);
    console.log(`Processing sheet: ${mainSheet} with ${sheetData.length} rows`);

    if (sheetData.length === 0) {
      return res.status(400).json({ success: false, message: 'Excel sheet is empty.' });
    }

    // Group rows by orderID (in case multiple products per order)
    const groupedOrders = new Map();
    
    for (const row of sheetData) {
      if (!row.orderID) {
        console.log("Skipping row without orderID");
        continue;
      }

      const orderID = String(row.orderID).trim();
      
      if (!groupedOrders.has(orderID)) {
        groupedOrders.set(orderID, {
          orderData: {
            orderID: row.orderID,
            refid: row.refid,
            invoiceNumber: row.invoiceNumber,
            paymentMode: row.paymentMode,
            collectableAmount: row.collectableAmount || 0,
            warehouseID: warehouseId,
            total_Weight: row.total_Weight,
            grandTotal: row.grandTotal,
            totalQty: row.totalQty,
            totalTax: row.totalTax || 0,
            totalDiscount: row.totalDiscount || 0,
            channel: row.channel || 'bulk-upload'
          },
          consigneeDetails: {
            firstName: row.firstName,
            lastName: row.lastName,
            email: row.email,
            phone: row.phone,
            alternatePhone: row.alternatePhone || '',
            addressLine1: row.addressLine1,
            addressLine2: row.addressLine2 || '',
            landmark: row.landmark || '',
            country: row.country,
            state: row.state,
            city: row.city,
            pincode: row.pincode,
            billingSameAsShipping: row.billingSameAsShipping || 1
          },
          products: [],
          boxes: []
        });
      }

      const orderGroup = groupedOrders.get(orderID);

      // Add product if not already added
      if (row.name && row.category) {
        const existingProduct = orderGroup.products.find(p => p.sku === row.sku);
        if (!existingProduct) {
          orderGroup.products.push({
            category: row.category,
            name: row.name,
            price: row.price,
            sku: row.sku,
            quantity: row.quantity,
            discountValue: row.discountValue || 0,
            discountType: row.discountType || 'Flat',
            taxType: row.taxType || 'None'
          });
        }
      }

      // Add boxes (box1_, box2_, etc.)
      for (let i = 1; i <= 10; i++) { // Support up to 10 boxes
        const boxPrefix = `box${i}_`;
        if (row[`${boxPrefix}packageType`]) {
          const existingBox = orderGroup.boxes.find(b => 
            b.packageType === row[`${boxPrefix}packageType`] && 
            b.length === row[`${boxPrefix}length`] &&
            b.breadth === row[`${boxPrefix}breadth`] &&
            b.height === row[`${boxPrefix}height`]
          );
          
          if (!existingBox) {
            orderGroup.boxes.push({
              packageType: row[`${boxPrefix}packageType`],
              length: row[`${boxPrefix}length`],
              breadth: row[`${boxPrefix}breadth`],
              height: row[`${boxPrefix}height`],
              dimensionUnit: row[`${boxPrefix}dimensionUnit`],
              weight: row[`${boxPrefix}weight`],
              weightUnit: row[`${boxPrefix}weightUnit`]
            });
          }
        }
      }
    }

    console.log(`Grouped into ${groupedOrders.size} unique orders`);

    // Check for existing orders
    const orderIDs = Array.from(groupedOrders.keys());
    const existingOrdersQuery = `SELECT orderid FROM tbl_ecom_orders WHERE orderid IN (${orderIDs.map(() => '?').join(',')})`;
    const existingOrders = await mySqlQury(existingOrdersQuery, orderIDs);
    const existingOrderSet = new Set(existingOrders.map(row => row.orderid));

    let processedCount = 0;
    let skippedCount = 0;
    let failedCount = 0;

    // Process each grouped order
    for (const [orderID, orderGroup] of groupedOrders) {
      try {
        // Skip if order already exists
        if (existingOrderSet.has(orderID)) {
          console.log(`Skipping existing order: ${orderID}`);
          skippedCount++;
          continue;
        }

        const { orderData, consigneeDetails, products, boxes } = orderGroup;
        const totalBoxes = boxes.length;

        // Insert into tbl_ecom_orders
        const orderInsertQuery = `
          INSERT INTO tbl_ecom_orders 
            (channel, ref_number, orderid, payment_mode, collectable_amount, warehouse_id, total_weight, grand_total, total_qty, total_tax, total_discount, is_unprocessed, client_id, box_qty, invoice_no)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `;
        const orderParams = [
          orderData.channel,
          orderData.refid,
          orderData.orderID,
          orderData.paymentMode,
          orderData.collectableAmount,
          orderData.warehouseID,
          orderData.total_Weight,
          orderData.grandTotal,
          orderData.totalQty,
          orderData.totalTax,
          orderData.totalDiscount,
          1, // is_unprocessed
          clientid,
          totalBoxes,
          orderData.invoiceNumber
        ];
        const orderResult = await mySqlQury(orderInsertQuery, orderParams);
        const orderId = orderResult.insertId;

        // Prepare billing details
        let billingDetails = {};
        if (consigneeDetails.billingSameAsShipping) {
          billingDetails = {
            billing_first_name: consigneeDetails.firstName,
            billing_last_name: consigneeDetails.lastName,
            billing_email: consigneeDetails.email,
            billing_phone: consigneeDetails.phone,
            billing_alternate_phone: consigneeDetails.alternatePhone,
            billing_address_line1: consigneeDetails.addressLine1,
            billing_address_line2: consigneeDetails.addressLine2,
            billing_landmark: consigneeDetails.landmark,
            billing_country: consigneeDetails.country,
            billing_state: consigneeDetails.state,
            billing_city: consigneeDetails.city,
            billing_pincode: consigneeDetails.pincode
          };
        }

        // Insert into tbl_ecom_consignee_details
        const consigneeInsertQuery = `
          INSERT INTO tbl_ecom_consignee_details 
            (order_id, first_name, last_name, email, phone, alternate_phone, address_line1, address_line2, landmark, country, state, city, pincode, billing_same_as_shipping, billing_first_name, billing_last_name, billing_email, billing_phone, billing_alternate_phone, billing_address_line1, billing_address_line2, billing_landmark, billing_country, billing_state, billing_city, billing_pincode)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `;
        const consigneeParams = [
          orderId,
          consigneeDetails.firstName,
          consigneeDetails.lastName,
          consigneeDetails.email,
          consigneeDetails.phone,
          consigneeDetails.alternatePhone,
          consigneeDetails.addressLine1,
          consigneeDetails.addressLine2,
          consigneeDetails.landmark,
          consigneeDetails.country,
          consigneeDetails.state,
          consigneeDetails.city,
          consigneeDetails.pincode,
          consigneeDetails.billingSameAsShipping ? 1 : 0,
          billingDetails.billing_first_name || '',
          billingDetails.billing_last_name || '',
          billingDetails.billing_email || '',
          billingDetails.billing_phone || '',
          billingDetails.billing_alternate_phone || '',
          billingDetails.billing_address_line1 || '',
          billingDetails.billing_address_line2 || '',
          billingDetails.billing_landmark || '',
          billingDetails.billing_country || '',
          billingDetails.billing_state || '',
          billingDetails.billing_city || '',
          billingDetails.billing_pincode || ''
        ];
        await mySqlQury(consigneeInsertQuery, consigneeParams);

        // Insert boxes
        for (const box of boxes) {
          const boxInsertQuery = `
            INSERT INTO tbl_ecom_boxes_details 
              (order_id, package_type, length, breadth, height, dimension_unit, weight, weight_unit)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
          `;
          const boxParams = [
            orderId,
            box.packageType,
            box.length,
            box.breadth,
            box.height,
            box.dimensionUnit,
            box.weight,
            box.weightUnit
          ];
          await mySqlQury(boxInsertQuery, boxParams);
        }

        // Insert products
        for (const product of products) {
          const productInsertQuery = `
            INSERT INTO tbl_ecom_product_details 
              (order_id, category, name, price, sku, quantity, discount_value, discount_type, tax_type)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
          `;
          const productParams = [
            orderId,
            product.category,
            product.name,
            product.price,
            product.sku,
            product.quantity,
            product.discountValue,
            product.discountType,
            product.taxType
          ];
          await mySqlQury(productInsertQuery, productParams);
        }

        processedCount++;
        console.log(`Successfully processed order: ${orderID}`);

      } catch (orderError) {
        console.error(`Error processing order ${orderID}:`, orderError);
        failedCount++;
        // Continue with next order instead of stopping the whole process
      }
    }

    await mySqlQury('COMMIT');
    
    return res.status(200).json({ 
      success: true, 
      message: 'Excel file uploaded and processed successfully!',
      totalProcessed: processedCount,
      skipped: skippedCount,
      failed: failedCount,
      details: {
        processed: processedCount,
        skipped: skippedCount,
        failed: failedCount
      }
    });

  } catch (error) {
    await mySqlQury('ROLLBACK');
    console.error('Bulk upload error:', error);
    res.status(500).json({ 
      success: false, 
      message: 'An error occurred while processing the Excel file.',
      error: error.message 
    });
  } finally {
    // Clean up uploaded file
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    }
  }
}
const postUploadLrData = async (req, res) => {
  try {
    // Check if file was uploaded
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No file uploaded'
      });
    }

    const filePath = req.file.path;
    const workbook = xlsx.readFile(filePath);

    // Log sheet names
    console.log("Available sheets in workbook:", workbook.SheetNames);

    // Get data from all required sheets
    const lrData = xlsx.utils.sheet_to_json(workbook.Sheets['Sheet1']);
    console.log("Sheet1 data:", lrData);

    const unprocessedData = xlsx.utils.sheet_to_json(workbook.Sheets['tbl_unprocessed_order'] || []);
    // console.log("tbl_unprocessed_order data:", unprocessedData);

    const productsData = xlsx.utils.sheet_to_json(workbook.Sheets['tbl_products'] || []);
    // console.log("tbl_products data:", productsData);

    const boxesData = xlsx.utils.sheet_to_json(workbook.Sheets['tbl_boxes_dimension'] || []);
    // console.log("tbl_boxes_dimension data:", boxesData);

    // console.log(`Total LR records to be inserted: ${lrData.length}`);

    await mySqlQury('START TRANSACTION');

    try {
      // Insert LR data
      const lrQuery = `
      INSERT INTO tbl_create_lr (
        order_id, po_id, lr_No, order_date, Tagged_api, 
        aggrigator_id, aggrigator_type, client_id, lr_Type,
        consignee_Name, insurance_Type, pickup_Pincode,
        destination_Pincode, pickup_Add, destination_Add,
        total_Weight, total_Box, mode_Of_Payment, invoice_Value,
        invoice_No, eway_bill, shipper_Gst, consignee_Gst,
        volumetric_weight, chargable_weight, status, eta, weight_unit
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;
      let insertedCount = 0;
      for (const lr of lrData) {
        // Clean and validate order_id by removing spaces from property name
        const orderId = String(lr['order_id '] || lr.order_id || '').trim();
        const poId = String(lr.po_id || '').trim();
        const lrNo = String(lr.lr_No || '').trim();

        // Log order details for tracking
        console.log("Processing order details:", {
          orderId,
          poId,
          lrNo,
          originalOrderId: lr['order_id '] || lr.order_id,
          originalPoId: lr.po_id,
          originalLrNo: lr.lr_No
        });




        // Clean and validate other required fields




        const lrValues = [
          orderId,
          lr.po_id,
          lr.lr_No,
          moment().format('YYYY-MM-DD HH:mm:ss') || null,
          lr.Tagged_api || null,
          lr.aggrigator_id || null,
          lr.aggrigator_type || null,
          67, // Hardcoded client_id as 67
          lr.lr_Type || 'automaticLR',
          lr.consignee_Name || null,
          lr.insurance_Type || 'Owner Risk',
          lr.pickup_Pincode || null,
          lr.destination_Pincode || null,
          lr.pickup_Add || null,
          lr.destination_Add || null,
          parseFloat(lr.total_Weight) || 0,
          parseInt(lr.total_Box) || 1,
          lr.mode_Of_Payment || 'COD',
          parseFloat(lr.invoice_Value) || 0,
          lr.invoice_No || null,
          lr.eway_bill || null,
          lr.shipper_Gst || null,
          lr.consignee_Gst || null,
          parseFloat(lr.volumetric_weight) || 0,
          parseFloat(lr.chargable_weight) || parseFloat(lr.total_Weight) || 0,
          parseInt(lr.status) || 0,
          lr.eta || null,
          lr.weight_unit || 'gm'
        ];

        try {
          await mySqlQury(lrQuery, lrValues);
          insertedCount++;
        } catch (error) {
          console.error('Error inserting LR:', error, 'Values:', lrValues);
        }
      }

      // Insert unprocessed order data if exists
      if (unprocessedData.length > 0) {
        for (const order of unprocessedData) {
          await mySqlQury(productQuery, [
            order.order_id,
            order.po_no,
            order.consignee_name,
            order.consignee_phone,
            order.consignee_email,
            order.consignee_address,
            moment().format('YYYY-MM-DD HH:mm:ss') || null,
            order.payment_type,
            order.total_boxes_weight,
            1,
            'Haryana',
            order.destination_state,
            order.destination_city,
            order.destination_pincode,
            order.Invoice_amount,
            order.Check_Favour_Of,
            order.cheque_amount,
            'Gurgaon',
            'Haryana',
            122001,
            'House No 70, Satguru Enclave, Opposite Hanuman Mandir, Old Delhi Rd,MarutiGateNo.1,Sector 22,GURGAON',
            '9667968342',
            67, // Hardcoded client_id as 67
            'anurag@curelytes.in',
            order.order_type,
            order.Invoice_amount,
            order.invoice_no,
            order.weight_unit,
            'Curelytes health'
          ]);
        }
      }

      // // Insert products data if exists
      // if (productsData.length > 0) {
      //   for (const product of productsData) {
      //     // Map product data fields with default values if null
      //     await mySqlQury(productDetailsQuery, [
      //       product.product_name || '',
      //       product.product_category || 'General', // Default category if null
      //       product.product_quantity || 0, // Default quantity if null  
      //       product.product_value || 0, // Default value if null
      //       product.po_no
      //     ]);
      //   }
      // }

      // Insert boxes dimension data if exists  
      // if (boxesData.length > 0) {
      //   for (const box of boxesData) {
      //     await mySqlQury(boxDimensionsQuery, [
      //       box.po_no, box.boxes, box.DIMENSION, box.unit
      //     ]);
      //   }
      // }

      await mySqlQury('COMMIT');

      res.json({
        success: true,
        message: `Successfully inserted ${insertedCount} LR records and related data`
      });

    } catch (error) {
      await mySqlQury('ROLLBACK');
      throw error;
    }

  } catch (error) {
    console.error('Error processing data:', error);
    res.status(500).json({
      success: false,
      message: 'Error processing file',
      error: error.message
    });
  } finally {
    // Clean up uploaded file
    if (req.file) {
      fs.unlink(req.file.path, (err) => {
        if (err) console.error('Error deleting temp file:', err);
      });
    }
  }
}


async function generateUniqueValue(column, generatorFunction) {
  let uniqueValue;
  let isUnique = false;

  while (!isUnique) {
    // Generate a random value
    uniqueValue = generatorFunction();

    // Query the database to check if the value exists
    const result = await mySqlQury(
      `SELECT COUNT(*) AS count FROM tbl_unprocessed_order WHERE ${column} = ?`,
      [uniqueValue]
    );

    // If the value doesn't exist, mark it as unique
    if (result[0].count === 0) {
      isUnique = true;
    }
  }

  return uniqueValue;
}
const getCodDashboard = async (req, res, next) => {
  try {
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    let walletBalance = 0;
    let loginDetails = null;
    let clientId = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id, first_name, company_name, logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
      }

      // Get wallet balance for the client
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
    }

    // Get user's active topic permissions
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );
    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Get COD order counts and amounts
    const ordersQuery = `SELECT 
      COUNT(DISTINCT lr.po_id) AS po_no_count,
      SUM(uo.amount) AS payment_cod_count          
    FROM tbl_create_lr lr 
    LEFT JOIN tbl_unprocessed_order uo ON lr.po_id = uo.po_no
    LEFT JOIN tbl_admin nc ON uo.client_id = nc.id
    WHERE lr.status IN (0, 4, 5)
    AND lr.mode_of_payment = 'cod'`;

    const unprocessedOrder = await mySqlQury(ordersQuery);
    let unprocessedOrderCount = unprocessedOrder[0]?.po_no_count || 0;
    let codCountInUnprocessedOrder = unprocessedOrder[0]?.payment_cod_count || 0;

    // Get forwarder remittance amount
    const bankCOD = `SELECT SUM(Amt_Bank_Recv_Forwarder) as Amt_Bank_Recv_Forwarder FROM tbl_bank_remitence`;
    const remittedAmountForwarder = await mySqlQury(bankCOD);
    const Amt_Bank_Recv_Forwarder = remittedAmountForwarder[0]?.Amt_Bank_Recv_Forwarder || 0;

    // Get aggregator remittance amount  
    const aggregatorCOD = `SELECT SUM(total_remittance_amount) as total_remittance_amount FROM tbl_agg_client_remittance`;
    const remittedAmountAggregator = await mySqlQury(aggregatorCOD);
    const Amt_Bank_Recv_Client = remittedAmountAggregator[0]?.total_remittance_amount || 0;

    // Get unremitted amount
    const unremitted_amount_query = `SELECT 
      SUM(discrepency_amount) + SUM(CASE WHEN amount_from_forwarder = 0 THEN remitted_amount ELSE 0 END) AS grand_total
    FROM tbl_cod_remitence`;

    const unremitted_amount_forwarder = await mySqlQury(unremitted_amount_query);
    const unremitted_amount_forwarder_cod = unremitted_amount_forwarder[0]?.grand_total || 0;

    // Format active topic IDs
    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    // Render view with data
    res.render('apps/cod-dashboard', {
      title: 'Dashboard',
      activeTopicIds,
      loginDetails,
      clientId,
      walletBalance,
      loginDetails,
      profile, // Added profile object for topbar template
      Amt_Bank_Recv_Forwarder,
      unprocessedOrderCount,
      codCountInUnprocessedOrder,
      Amt_Bank_Recv_Client,
      unremitted_amount_forwarder_cod,
      role_data
    });

  } catch (error) {
    console.error("Error fetching data:", error);
    next(error);
  }
}
const getOrderStats = async (req, res) => {
  try {

    const query = `SELECT 
    DATE_FORMAT(lr.order_date, '%Y-%m') AS month,
    COUNT(lr.po_id) AS total_orders,
    COALESCE(SUM(uo.amount), 0) AS total_amount,
    COUNT(CASE WHEN lr.status = 4 THEN 1 END) AS delivered_orders,
    COUNT(CASE WHEN lr.status = 5 THEN 1 END) AS rto_orders,
    
    COUNT(CASE WHEN acr.utr_number IS NOT NULL THEN 1 END) AS remitted_order_count,
    COALESCE(SUM(acr.remitted_cod), 0) AS remitted_amount,

    COUNT(CASE WHEN bpo.utr_number IS NULL THEN 1 END) AS to_be_remitted_order_count,
    COALESCE(SUM(bpo.remitted_amount), 0) AS to_be_remitted_amount  -- **Fixed the syntax error**

FROM tbl_create_lr lr
LEFT JOIN tbl_unprocessed_order uo ON lr.po_id = uo.po_no
LEFT JOIN tbl_bankrecovspoid bpo ON lr.lr_no = bpo.lr_awb
LEFT JOIN tbl_bank_remitence br ON bpo.utr_number = br.utr_number
LEFT JOIN tbl_agg_client_remittance acr ON lr.lr_no = acr.lr_no
WHERE lr.status IN (0, 4, 5) 
AND lr.mode_Of_Payment = 'cod'
GROUP BY month
ORDER BY month
LIMIT 25;
`
    const rows = await mySqlQury(query);

    // Check if rows are being returned correctly
    console.log(rows);

    res.json(rows || []);  // Always return an array, even if it's empty
  } catch (err) {
    console.error("Error fetching order stats:", err);
    res.status(500).json({ error: "Internal Server Error" });
  }
}
const getCodSummary = async (req, res, next) => {
  try {
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    let walletBalance = 0;
    let vasService = 0;
    let loginDetails = null;
    let clientId = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id, first_name, vas,company_name, logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }

      // Get wallet balance for the related client
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    // Get active topic IDs
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );
    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );
    let activeTopicIds = [];
    if (activeTopics && Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    // Query to fetch COD summary data
    const selectQuery = `
      SELECT
          lr.po_id,
          uo.client_id,
          nc.company_name AS client_name,
          lr.lr_no,
          lr.total_box AS qnty,
          lr.tagged_api AS forwarder,  
          'Standard-Air' AS dispatch_mode,
          lr.order_date AS delivery_date,
          lr.status,
          lr.mode_of_payment AS payment_mode,
          uo.amount AS cod_amount
      FROM tbl_create_lr lr
      LEFT JOIN tbl_unprocessed_order uo ON lr.po_id = uo.po_no
      LEFT JOIN tbl_admin nc ON uo.client_id = nc.id
      WHERE lr.status IN (0, 4, 5, 7)
      AND lr.mode_of_payment = 'cod'
    `;

    // Fetch data from database
    const result = await mySqlQury(selectQuery);

    if (result.length > 0) {
      // Get existing lr_no values from tbl_cod_summary
      const existingLrNosQuery = `SELECT lr_no FROM tbl_cod_summary`;
      const existingLrNosResult = await mySqlQury(existingLrNosQuery);

      const existingLrNos = new Set(existingLrNosResult.map(row => row.lr_no));

      // Filter out records that already exist
      const filteredResult = result.filter(row => !existingLrNos.has(row.lr_no));
      console.log(filteredResult);

      if (filteredResult.length > 0) {
        const insertQuery = `INSERT INTO tbl_cod_summary (
          po_id,
          client_id,
          client_name,
          lr_no,
          total_box,
          tagged_api,
          dispatch_mode,
          delivery_date,
          status,
          payment_mode,
          cod_amount
        ) VALUES ?`;

        const insertValues = filteredResult.map(row => {
          // Handle null/empty total_box values
          const totalBox = row.qnty === '' || row.qnty === null || isNaN(row.qnty) ? 0 : parseInt(row.qnty, 10);

          return [
            row.po_id,
            row.client_id || 0,  // Default to 0 if null
            row.client_name || '',  // Default to empty string if null
            row.lr_no,
            totalBox,
            row.forwarder || '',
            row.dispatch_mode || 'Standard-Air',
            row.delivery_date || new Date(),  // Default to current date if null
            row.status || 0,  // Default to 0 if null
            row.payment_mode || 'cod',
            row.cod_amount || 0  // Default to 0 if null
          ];
        });

        // Log any potential problematic rows before insert
        filteredResult.forEach((row, index) => {
          if (row.qnty === '' || row.qnty === null || isNaN(row.qnty)) {
            console.log(`Warning: Invalid total_box value for LR: ${row.lr_no}, PO: ${row.po_id}, Original Value: ${row.qnty}`);
          }
        });

        try {
          // Execute bulk insert
          await mySqlQury(insertQuery, [insertValues]);
          console.log("Data inserted into tbl_cod_summary");
        } catch (insertError) {
          console.error("Error during insert:", insertError);
          console.error("Problematic data:", JSON.stringify(filteredResult, null, 2));
          throw insertError;
        }
      }
    }


    // Get role data for the user

    // Pass data to EJS template
    res.render('pages/cod-summary', {
      title: 'Cod Summary',
      bodyClass: 'profile-page',
      activePage: 'profile',
      activeTopicIds,
      loginDetails,
      result,
      role_data, // Add role_data to template variables
      profile,
      walletBalance,
      clientId,
      vasService, role
    });

  } catch (error) {
    console.error("Error fetching COD summary:", error);
    next(error);
  }
}
// Ensure upload directory exists
const uploadDir = path.join(__dirname, "../assets/bankreco");
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}

async function getEcomCodSummaryv2(req, res) {
  try {
    const {
      page = 1,
      limit = 10,
      client_id,
      client_name,
      company_name,
      channel,
      search,
      status,
      from_date,
      to_date,
      lr_from_date,
      lr_to_date,
      min_quantity,
      max_quantity,
      min_cod_amount,
      max_cod_amount,
      shipment_carrier
    } = req.body;

    const offset = (page - 1) * limit;

    // =============================
    // Build orderWhere filters
    // =============================
    let orderWhere = { payment_mode: "COD" };
    if (client_id) orderWhere.client_id = client_id;
    if (channel) orderWhere.channel = channel;

    // Date filters (order created_at)
    if (from_date && to_date) {
      orderWhere.created_at = {
        [Op.between]: [
          new Date(from_date + "T00:00:00.000Z"),
          new Date(to_date + "T23:59:59.999Z")
        ]
      };
    } else if (from_date) {
      orderWhere.created_at = { [Op.gte]: new Date(from_date + "T00:00:00.000Z") };
    } else if (to_date) {
      orderWhere.created_at = { [Op.lte]: new Date(to_date + "T23:59:59.999Z") };
    }

    // Quantity filter
    if (min_quantity && max_quantity) {
      orderWhere.total_qty = { [Op.between]: [min_quantity, max_quantity] };
    } else if (min_quantity) {
      orderWhere.total_qty = { [Op.gte]: min_quantity };
    } else if (max_quantity) {
      orderWhere.total_qty = { [Op.lte]: max_quantity };
    }

    // COD amount filter
    if (min_cod_amount && max_cod_amount) {
      orderWhere.collectable_amount = { [Op.between]: [min_cod_amount, max_cod_amount] };
    } else if (min_cod_amount) {
      orderWhere.collectable_amount = { [Op.gte]: min_cod_amount };
    } else if (max_cod_amount) {
      orderWhere.collectable_amount = { [Op.lte]: max_cod_amount };
    }

    // Search filter (orders table only, skip LR check)
    if (search) {
      const isLikelyLrNumber = /^\d{8,}$/.test(search);
      if (!isLikelyLrNumber) {
        const searchConditions = [
          { orderid: { [Op.like]: `%${search}%` } },
          { ref_number: { [Op.like]: `%${search}%` } },
          { invoice_no: { [Op.like]: `%${search}%` } },
          { collectable_amount: { [Op.like]: `%${search}%` } },
          { grand_total: { [Op.like]: `%${search}%` } },
          { total_qty: { [Op.like]: `%${search}%` } },
          { box_qty: { [Op.like]: `%${search}%` } },
          { channel: { [Op.like]: `%${search}%` } }
        ];
        orderWhere = { [Op.and]: [{ ...orderWhere }, { [Op.or]: searchConditions }] };
      }
    }

    // =============================
    // Query Options
    // =============================
    let queryOptions = {
      where: orderWhere,
      include: [
        {
          model: EcomLR,
          as: "ecom_lrs",
          required: false,
          attributes: ["id", "lr_no", "tagged_api", "status", "created_at"]
        },
        {
          model: Admin,
          as: "orderClient",
          required: false,
          attributes: ["id", "first_name", "last_name", "company_name"]
        }
      ],
      offset: parseInt(offset),
      limit: parseInt(limit),
      order: [["created_at", "DESC"]]
    };

    // Company name filter
    if (company_name) {
      queryOptions.include[1].where = {
        company_name: { [Op.like]: `%${company_name}%` }
      };
      queryOptions.include[1].required = true;
    }

    // LR/AWB date filters
    if (lr_from_date || lr_to_date) {
      if (!queryOptions.include[0].where) queryOptions.include[0].where = {};
      
      if (lr_from_date && lr_to_date) {
        queryOptions.include[0].where.created_at = {
          [Op.between]: [
            new Date(lr_from_date + "T00:00:00.000Z"),
            new Date(lr_to_date + "T23:59:59.999Z")
          ]
        };
      } else if (lr_from_date) {
        queryOptions.include[0].where.created_at = { [Op.gte]: new Date(lr_from_date + "T00:00:00.000Z") };
      } else if (lr_to_date) {
        queryOptions.include[0].where.created_at = { [Op.lte]: new Date(lr_to_date + "T23:59:59.999Z") };
      }
      
      queryOptions.include[0].required = true;
    }

    // Shipment carrier filter
    if (shipment_carrier) {
      if (!queryOptions.include[0].where) queryOptions.include[0].where = {};
      queryOptions.include[0].where.tagged_api = shipment_carrier;
      queryOptions.include[0].required = true;
    }

    // Status filter
    const statusStr = String(status);
    if (statusStr && statusStr !== "undefined" && statusStr !== "null") {
      if (!queryOptions.include[0].where) queryOptions.include[0].where = {};
      if (statusStr === "others") {
        queryOptions.include[0].where.status = { [Op.notIn]: [0, 1, 2, 3, 4, 5, 7, 8, 9, 10] };
      } else {
        queryOptions.include[0].where.status = parseInt(statusStr);
      }
      queryOptions.include[0].required = true;
    }

    // =============================
    // Count & fetch with pagination
    // =============================
    // For count, we need to include the same filters as the main query
    let countOptions = { where: orderWhere, distinct: true, col: "id" };
    if (company_name || shipment_carrier || statusStr || lr_from_date || lr_to_date) {
      countOptions.include = queryOptions.include;
    }
    const count = await EcomOrders.count(countOptions);
    const rows = await EcomOrders.findAll(queryOptions);

    // =============================
    // Insert into tbl_cod_summary (only on first run)
    // =============================
  // Insert into tbl_cod_summary (only on first run)
const existingCount = await TblCodSummary.count(); // check table
if (existingCount === 0) {
  // Fetch ALL orders (ignore pagination) to insert once
  const allOrders = await EcomOrders.findAll({
    where: orderWhere,
    include: queryOptions.include,
    order: [["created_at", "DESC"]]
  });

  const summaryData = allOrders.map(order => {
    const lr = order.ecom_lrs && order.ecom_lrs.length > 0 ? order.ecom_lrs[0] : {};
    const client = order.orderClient || {};

    return {
      order_id: order.orderid || order.id || null,
      client_id: order.client_id || null,
       client_name:
      client.first_name || client.last_name
        ? `${client.first_name || ""} ${client.last_name || ""}`.trim()
        : null,
    company_name: client.company_name || null,   
      lr_no: lr.lr_no || null,
      total_box: order.box_qty || order.total_qty || 0,
      tagged_api: lr.tagged_api || null,
      dispatch_mode: lr.tagged_api ? lr.tagged_api.split("/")[1] : null,
      delivery_date: lr.created_at || null,
      status: lr.status || 0,
      payment_mode: order.payment_mode,
      cod_amount: order.collectable_amount
    };
  });

  await TblCodSummary.bulkCreate(summaryData, {
    updateOnDuplicate: [
      "client_name",
      "company_name",
      "order_id",
      "total_box",
      "tagged_api",
      "dispatch_mode",
      "delivery_date",
      "status",
      "payment_mode",
      "cod_amount"
    ]
  });

  console.log(`âœ… Inserted ${summaryData.length} records into tbl_cod_summary`);
}


    // =============================
    // Response
    // =============================
    return res.status(200).json({
      success: true,
      pagination: {
        totalRecords: count,
        currentPage: parseInt(page),
        totalPages: Math.ceil(count / limit),
        pageSize: parseInt(limit)
      },
      data: rows
    });
  } catch (err) {
    console.error("âŒ Error in getEcomCodSummaryv2:", err);
    return res.status(500).json({ success: false, error: "Internal Server Error" });
  }
}




async function getCodSummaryv1(req, res) {
  try {
    const {
      page = 1,
      limit = 10,
      client_id,
      po_id,
      status,
      from_date,
      to_date,
      min_quantity,
      max_quantity,
      min_cod_amount,
      max_cod_amount
    } = req.body;

    const offset = (page - 1) * limit;
    const where = {};

    if (client_id) where.client_id = client_id;
    if (po_id) where.po_id = po_id;
    if (status) where.status = status;

    if (from_date && to_date) {
      where.delivery_date = { [Op.between]: [new Date(from_date), new Date(to_date)] };
    } else if (from_date) {
      where.delivery_date = { [Op.gte]: new Date(from_date) };
    } else if (to_date) {
      where.delivery_date = { [Op.lte]: new Date(to_date) };
    }

    if (min_quantity && max_quantity) {
      where.total_box = { [Op.between]: [min_quantity, max_quantity] };
    } else if (min_quantity) {
      where.total_box = { [Op.gte]: min_quantity };
    } else if (max_quantity) {
      where.total_box = { [Op.lte]: max_quantity };
    }

    if (min_cod_amount && max_cod_amount) {
      where.cod_amount = { [Op.between]: [min_cod_amount, max_cod_amount] };
    } else if (min_cod_amount) {
      where.cod_amount = { [Op.gte]: min_cod_amount };
    } else if (max_cod_amount) {
      where.cod_amount = { [Op.lte]: max_cod_amount };
    }

    const { count, rows } = await CodSummary.findAndCountAll({
      where,
      include: [
        {
          model: EcomLR,
          required: false
        }
      ],
      offset: parseInt(offset),
      limit: parseInt(limit),
      order: [["delivery_date", "DESC"]]
    });

    return res.status(200).json({
      success: true,
      pagination: {
        totalRecords: count,
        currentPage: parseInt(page),
        totalPages: Math.ceil(count / limit),
        pageSize: parseInt(limit)
      },
      data: rows
    });
  } catch (err) {
    console.error("âŒ Error fetching COD summary:", err);
    return res.status(500).json({ success: false, error: "Internal Server Error" });
  }
}

const postUploadRemittance = async (req, res) => {
  try {
    // Check if a file was uploaded
    if (!req.file) {
      return res.status(400).json({ success: false, message: "No file uploaded!" });
    }

    const filePath = req.file.path;
    const fileName = req.file.filename;
    const downloadUrl = `/assets/bankreco/${fileName}`; // URL for downloading

    // Read Excel file
    const workbook = xlsx.readFile(filePath);

    // Get data from the first sheet (tbl_bank_remitence)
    const sheetName1 = workbook.SheetNames[0]; // First sheet
    const sheetData1 = xlsx.utils.sheet_to_json(workbook.Sheets[sheetName1]);

    // Get data from the second sheet (tbl_bankrecovspoid)
    const sheetName2 = workbook.SheetNames[1]; // Second sheet
    const sheetData2 = xlsx.utils.sheet_to_json(workbook.Sheets[sheetName2]);

    // Debugging: Check data from both sheets
    console.log("Sheet 1 (bankreco) Data: ", sheetData1);
    console.log("Sheet 2 (bankrecoVspoid) Data: ", sheetData2);

    // Check if any of the sheets are empty
    if (sheetData1.length === 0 || sheetData2.length === 0) {
      return res.status(400).json({ success: false, message: "One or more sheets are empty!" });
    }

    // Check for duplicate UTR numbers in tbl_bank_remitence
    const existingUtrQuery = "SELECT utr_number FROM tbl_bank_remitence WHERE utr_number IN (?)";
    const utrNumbers = sheetData1.map(row => row.utr_number);
    console.log("UTR Numbers from Sheet 1: ", utrNumbers);

    // Query database for existing UTR numbers
    const existingUtrResult = await mySqlQury(existingUtrQuery, [utrNumbers]);
    const existingUtrs = existingUtrResult.map(row => row.utr_number);

    // Debugging: Log existing UTR numbers
    console.log("Existing UTR Numbers in tbl_bank_remitence: ", existingUtrs);

    // Filter out rows from sheetData1 that already exist in tbl_bank_remitence
    const filteredSheetData1 = sheetData1.filter(row => !existingUtrs.includes(row.utr_number));
    const duplicateUtrs = sheetData1.filter(row => existingUtrs.includes(row.utr_number));

    // Debugging: Check if there are duplicates
    console.log("Duplicate UTR Numbers: ", duplicateUtrs);

    if (duplicateUtrs.length > 0) {
      return res.status(400).json({
        success: false,
        message: `Duplicate UTR numbers found in tbl_bank_remitence: ${duplicateUtrs.map(row => row.utr_number).join(", ")}`
      });
    }


    // Insert data into tbl_bank_remitence
    const insertQuery1 = `INSERT INTO tbl_bank_remitence
          (utr_deposited_on, utr_number, Amt_Bank_Recv_Forwarder,
          file_uploaded_on, download_utr_data, bank_name, shipment_mode) VALUES ?`;

    const values1 = filteredSheetData1.map(row => [
      formatDate(row.utr_deposited_on), // Format the date properly
      row.utr_number,
      row.Amt_Bank_Recv_Forwarder,
      new Date(), // Real-time timestamp for file upload
      downloadUrl, // File download URL
      row.bank_name,
      row.shipment_mode
    ]);

    // Debugging: Log the values being inserted into tbl_bank_remitence
    console.log("Values to Insert into tbl_bank_remitence: ", values1);
    await mySqlQury(insertQuery1, [values1]);

    // Now, check if UTR numbers from the second sheet exist in tbl_bank_remitence
    const sheet2WithValidUtrs = sheetData2.filter(row =>
      sheetData1.some(item => item.utr_number === row.utr_number)
    );

    // Debugging: Log valid rows from Sheet 2
    console.log("Valid Rows from Sheet 2 (bankrecoVspoid) with matching UTRs: ", sheet2WithValidUtrs);

    // Check if there are any valid rows to insert
    if (sheet2WithValidUtrs.length === 0) {
      return res.status(400).json({
        success: false,
        message: "No matching UTR numbers found in bankreco for bankrecoVspoid!"
      });
    }

    // Insert matching data into tbl_bankrecovspoid
    const insertQuery2 = `INSERT INTO tbl_bankrecovspoid
      (utr_number, client_name,  qty, lr_awb,  status,
      remitted_amount, forwarder) VALUES ?`;

    const values2 = sheet2WithValidUtrs.map(row => [
      row.utr_number,
      row.client_name,
      row.qty,
      row.lr_awb,
      row.status,
      row.remitted_amount,
      row.forwarder
    ]);

    // Debugging: Log the values to be inserted into tbl_bankrecovspoid
    console.log("Values to Insert into tbl_bankrecovspoid: ", values2);

    // If values2 has valid rows, perform the insert
    if (values2.length > 0) {
      await mySqlQury(insertQuery2, [values2]);
      console.log("Insert Result for tbl_bankrecovspoid: ", values2.length);
    } else {
      console.log("No valid rows to insert into tbl_bankrecovspoid.");
    }

    // Final Response
    res.status(201).json({
      success: true,
      message: "Excel file processed and data inserted successfully!",
      insertedRows: values1.length + values2.length,
      downloadUrl: downloadUrl
    });

  } catch (error) {
    console.error("Error processing file:", error);
    res.status(500).json({ success: false, message: "Server error" });
  }
}

function formatDate(excelDate) {
  if (typeof excelDate === "number") {
    return new Date((excelDate - 25569) * 86400 * 1000).toISOString().split('T')[0];
  }
  return null;
}
const getUtrData = async (req, res) => {
  try {
    // Extract query parameters for filtering and pagination
    const { utr_number, page = 1, limit = 10 } = req.query;

    // Basic query to fetch data
    let query = "SELECT * FROM tbl_bank_remitence";
    let queryParams = [];

    // Apply filter if utr_number is provided
    if (utr_number) {
      query += " WHERE utr_number = ?";
      queryParams.push(utr_number);
    }

    // Pagination logic: OFFSET and LIMIT
    query += " LIMIT ? OFFSET ?";
    queryParams.push(Number(limit), (Number(page) - 1) * Number(limit));

    // Run the query with the parameters
    const result = await mySqlQury(query, queryParams);

    // Count total rows for pagination
    const countQuery = "SELECT COUNT(*) as total FROM tbl_bank_remitence";
    const countResult = await mySqlQury(countQuery);
    const totalRows = countResult[0].total;
    const totalPages = Math.ceil(totalRows / Number(limit));

    // Return the result as JSON with pagination metadata
    res.json({
      success: true,
      data: result,
      pagination: {
        currentPage: Number(page),
        totalRows,
        totalPages,
        limit: Number(limit),
      }
    });

  } catch (error) {
    console.error("Error fetching data:", error);
    res.status(500).json({ success: false, message: "Error fetching data" });
  }
}
const getBankReconsilation = async (req, res, next) => {
  try {
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    let walletBalance = 0;
    let loginDetails = null;
    let vasService = 0;

    let clientId = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id, first_name, company_name,vas, logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }

      // Get wallet balance for the related client
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    // Get active topic IDs
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    let activeTopicIds = activeTopics?.map(topic => Number(topic.topic_id)) || [];
    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Fetch bank reconciliation data
    const selectQuery = `
    SELECT
        br.utr_deposited_on,
        br.utr_number,
        br.file_uploaded_on,
        br.download_utr_data,
        br.bank_name,
        br.shipment_mode,
        br.Amt_Bank_Recv_Forwarder
    FROM tbl_bank_remitence br
  `;

    const result = await mySqlQury(selectQuery);
    console.log("Fetched Bank Reconciliation Data: ", result);

    const query = `
  SELECT
  id, utr_number, client_name, qty, lr_awb, status, remitted_amount, forwarder
  FROM tbl_bankrecovspoid
 `;

    // Execute the query
    const users = await mySqlQury(query);

    // If no users found, return a message
    // if (users.length === 0) {
    //   return res.status(404).json({ message: 'No data found for the provided UTR number' });
    // }

    // Render the page with necessary data
    res.render('pages/bank-reconsilation', {
      title: 'bank-reconsilation',
      bodyClass: 'profile-page',
      activePage: 'profile',
      loginDetails,
      result,
      users,
      activeTopicIds,
      walletBalance, // Send wallet balance
      role_data, // Pass role_data to match template
      profile,
      clientId,
      vasService, role
    });
  } catch (error) {
    console.error("Error fetching bank reconciliation data:", error);
    next(error);
  }
}
const getToBeRemitted = async (req, res, next) => {
  try {
    // Get active topic IDs
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    let walletBalance = 0;
    let vasService = 0;
    let loginDetails = null;
    let clientId = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id, first_name, vas,company_name, logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }

      // Get wallet balance for the related client
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    let activeTopicIds = [];
    if (activeTopics && Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }
    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );




    // Get role data

    const query = `SELECT
    br.utr_number,
    cs.lr_no,
    cs.delivery_date,
    cs.cod_amount,
    COALESCE(cs.cod_amount - MAX(bpo.remitted_amount), 0) AS discrepency_amount, -- Use MAX() here
    cs.client_name,
    COALESCE(MAX(br.Amt_Bank_Recv_Forwarder), 0) AS amount_from_forwarder, -- Use MAX()
    lr.consignee_Name AS customer_name,
    lr.destination_Add AS customer_address,
    lr.po_id,
    lr.order_date,
    lr.destination_Pincode AS pincode
FROM tbl_cod_summary cs
LEFT JOIN tbl_bankrecovspoid bpo ON cs.lr_no = bpo.lr_awb
LEFT JOIN tbl_bank_remitence br ON bpo.utr_number = br.utr_number
LEFT JOIN tbl_unprocessed_order uo ON cs.po_id = uo.po_no
LEFT JOIN tbl_create_lr lr ON cs.lr_no = lr.lr_No
WHERE cs.status = 4  
GROUP BY 
    br.utr_number, cs.lr_no, cs.delivery_date, cs.cod_amount, cs.client_name, 
    lr.consignee_Name, lr.destination_Add, lr.po_id, lr.order_date, lr.destination_Pincode;

`;

    const resultQuery = await mySqlQury(query);

    if (resultQuery.length === 0) {
      return res.status(404).send('No data found for insertion');
    }

    const insertQuery = `
    INSERT INTO tbl_cod_remitence (
      po_id, order_date, lr_no, customer_name, client_name,
      customer_address, pincode, collectable_cod,
      delivery_date, amount_from_forwarder, remitted_amount, discrepency_amount, utr_number
    )
    VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ON DUPLICATE KEY UPDATE
      po_id = VALUES(po_id),
      order_date = VALUES(order_date),
      customer_name = VALUES(customer_name),
      client_name = VALUES(client_name),
      customer_address = VALUES(customer_address),
      pincode = VALUES(pincode),
      collectable_cod = VALUES(collectable_cod),
      delivery_date = VALUES(delivery_date),
      amount_from_forwarder = VALUES(amount_from_forwarder),
      remitted_amount = VALUES(remitted_amount),
      discrepency_amount = VALUES(discrepency_amount),
      utr_number = VALUES(utr_number);
  `;

    for (const row of resultQuery) {
      if (!row.po_id) {
        console.error("Skipping row due to null po_id:", row);
        continue; // Skip rows with null po_id
      }
      const values = [
        row.po_id,
        row.order_date,
        row.lr_no,
        row.customer_name,
        row.client_name,
        row.customer_address,
        row.pincode,
        row.cod_amount,
        row.delivery_date,
        row.amount_from_forwarder,
        row.cod_amount,
        row.discrepency_amount,
        row.utr_number
      ];

      await mySqlQury(insertQuery, values);
    }

    const cod_query = `SELECT
    po_id as po_id,
    order_date as order_date,
    lr_no as lr_no,
    customer_name as customer_name,
    client_name as client_name,
    customer_address as customer_address,
    pincode as pincode,
    collectable_cod as cod_amount,
    delivery_date as delivery_date,
    amount_from_forwarder as amount_from_forwarder,
    remitted_amount as cod_amount,
    discrepency_amount as discrepency_amount,
    utr_number as utr_number,
    status as status
  FROM tbl_cod_remitence;`

    const result = await mySqlQury(cod_query);

    res.render('pages/to-be-remitted', {
      title: 'to-be-remitted',
      bodyClass: 'profile-page',
      activePage: 'profile',
      loginDetails,
      role_data,
      result,
      activeTopicIds,
      profile,
      walletBalance,
      clientId,
      vasService, role
    });

  } catch (error) {
    console.error(error);
    next(error);
  }
}

const postSaveAggToClient = async (req, res, next) => {
  try {
    const {
      // clientName,
      utrNumber,
      bankName,
      ifscCode,
      branchName,
      transactionDate,
      remittanceAmount,
      orderSummary
    } = req.body;

    if (!Array.isArray(orderSummary) || orderSummary.length === 0) {
      return res.status(400).json({ message: "Order summary is required" });
    }

    for (let i = 0; i < orderSummary.length; i++) {

      if (orderSummary[i].status == "1") {
        const cod_query = `UPDATE tbl_cod_remitence
SET
    status = '1'
WHERE
    lr_no = ?`

        await mySqlQury(cod_query, [orderSummary[i].lrNos])
      }
    }

    const queries = [];

    for (const order of orderSummary) {
      const { poId, lrNos, orderDate, status, clientName } = order;


      const query = `
        INSERT INTO tbl_agg_client_remittance (
          transaction_date,
          utr_number,
          total_remittance_amount,
          lr_no,
          bank_name,
          ifsc_code,
          branch_name,
          po_id,
          client_name,
          order_date,
          status
        )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ON DUPLICATE KEY UPDATE
          transaction_date = VALUES(transaction_date),
          utr_number = VALUES(utr_number),
          total_remittance_amount = VALUES(total_remittance_amount),
          bank_name = VALUES(bank_name),
          ifsc_code = VALUES(ifsc_code),
          branch_name = VALUES(branch_name),
          client_name = VALUES(client_name),
          order_date = VALUES(order_date),
          status = VALUES(status);
      `;

      const values = [
        transactionDate,
        utrNumber,
        remittanceAmount,
        lrNos,
        bankName,
        ifscCode,
        branchName,
        poId,
        clientName,
        orderDate,
        status
      ];

      queries.push(mySqlQury(query, values));
    }

    // Execute all queries
    await Promise.all(queries);

    res.status(200).json({ message: "Data inserted/updated successfully" });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "Failed to save data", error: err.message });
  }
}
const getRemitted = async (req, res, next) => {
  try {
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    let walletBalance = 0;
    let vasService = 0;
    let loginDetails = null;
    let clientId = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id, first_name, company_name, logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }

      // Get wallet balance for the related client
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }
    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Get active topic permissions
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    // Get remittance data
    // Get remittance data
    const query = `SELECT  
      transaction_date,
      utr_number,
      total_remittance_amount,
      lr_no,
      bank_name,
      ifsc_code,
      branch_name,
      po_id,
      client_name,  
      Order_Date,
      Delivery_Date,
      collectable_cod,
      remitted_cod
    FROM
      tbl_agg_client_remittance;`;

    const result = await mySqlQury(query);

    // Pass profile data to avoid "profile is not defined" error
    res.render('pages/remitted', {
      title: 'remitted',
      bodyClass: 'profile-page',
      activePage: 'profile',
      loginDetails,
      role_data,
      result,
      activeTopicIds,
      profile,
      walletBalance,
      clientId,
      vasService, role
    });

  } catch (error) {
    console.error(error);
    next(error);
  }
}


async function getBankRemitence(req, res) {
  try {
    console.log('=== getBankRemitence function called ===');
    console.log('Request body:', req.body);
    
    const {
      page = 1,
      limit = 10,
      utr_number,
      bank_name,
      shipment_mode,
      file_uploaded_on
    } = req.body;

    const offset = (page - 1) * limit;

    // Base filter
    let where = {};

    if (utr_number) where.utr_number = { [Op.like]: `%${utr_number}%` };
    if (bank_name) where.bank_name = { [Op.like]: `%${bank_name}%` };
    if (shipment_mode) where.shipment_mode = { [Op.like]: `%${shipment_mode}%` };

    // Date filter (on file_uploaded_on)
    if (file_uploaded_on) {
      where.file_uploaded_on = {
          [Op.between]: [
          new Date(file_uploaded_on + "T00:00:00.000Z"),
          new Date(file_uploaded_on + "T23:59:59.999Z")
        ]
      };
    }


    // Count query
    const totalRecords = await TblBankRemitence.count({ where });

    // Fetch all data first (we'll group and paginate after)
    const allRows = await TblBankRemitence.findAll({
      where,
      order: [["id", "DESC"]]
    });



    // Group by UTR number and combine amounts
    const groupedData = {};
    allRows.forEach(row => {
      const utr = row.utr_number;
      if (groupedData[utr]) {
        // If UTR already exists, add to the existing record
        // console.log(`Combining duplicate UTR ${utr}: adding ${row.remitted_amount} to existing ${groupedData[utr].remitted_amount}`);
        groupedData[utr].remitted_amount += parseFloat(row.remitted_amount || 0);
        groupedData[utr].Amt_Bank_Recv_Forwarder += parseFloat(row.Amt_Bank_Recv_Forwarder || 0);
        // Keep the most recent values for other fields
        groupedData[utr].utr_deposited_on = row.utr_deposited_on;
        groupedData[utr].file_uploaded_on = row.file_uploaded_on;
        groupedData[utr].bank_name = row.bank_name;
        groupedData[utr].shipment_mode = row.shipment_mode;
        groupedData[utr].id = row.id; // Keep the most recent ID
      } else {
        // Create new grouped record
        groupedData[utr] = {
          id: row.id,
          utr_deposited_on: row.utr_deposited_on,
          utr_number: row.utr_number,
          remitted_amount: parseFloat(row.remitted_amount || 0),
          file_uploaded_on: row.file_uploaded_on,
          download_utr_data: row.download_utr_data,
          bank_name: row.bank_name,
          shipment_mode: row.shipment_mode,
          Amt_Bank_Recv_Forwarder: parseFloat(row.Amt_Bank_Recv_Forwarder || 0)
        };
      }
    });

    // Convert grouped data back to array
    const groupedRows = Object.values(groupedData);
    console.log('Grouped rows:', groupedRows.length);

    // Apply pagination to grouped data
    const startIndex = parseInt(offset);
    const endIndex = startIndex + parseInt(limit);
    const rows = groupedRows.slice(startIndex, endIndex);

    // Update total records count to reflect grouped data
    const totalGroupedRecords = groupedRows.length;

    const response = {
      success: true,
      pagination: {
        totalRecords: totalGroupedRecords,
        currentPage: parseInt(page),
        totalPages: Math.ceil(totalGroupedRecords / limit),
        pageSize: parseInt(limit)
      },
      data: rows
    };

    console.log('Sending response:', response);
    return res.status(200).json(response);
  } catch (err) {
    console.error(err);
    return res
      .status(500)
      .json({ success: false, error: "Internal Server Error" });
  }
}



async function getBankRecovSpoid(req, res) {
  try {
    const {
      page = 1,
      limit = 10,
      utr_number,
      client_name,
      status,
      forwarder,
      lr_awb
    } = req.body;

    const offset = (page - 1) * limit;

    // Base filter
    let where = {};

    if (utr_number) where.utr_number = { [Op.like]: `%${utr_number}%` };
    if (client_name) where.client_name = { [Op.like]: `%${client_name}%` };
    if (status) where.status = status;
    if (forwarder) where.forwarder = { [Op.like]: `%${forwarder}%` };
    if (lr_awb) where.lr_awb = { [Op.like]: `%${lr_awb}%` };

    // Count query
    const totalRecords = await TblBankRecovSpoid.count({ where });

    // Fetch data
    const rows = await TblBankRecovSpoid.findAll({
      where,
      offset: parseInt(offset),
      limit: parseInt(limit),
      order: [["id", "DESC"]]
    });


    return res.status(200).json({
      success: true,
      pagination: {
        totalRecords,
        currentPage: parseInt(page),
        totalPages: Math.ceil(totalRecords / limit),
        pageSize: parseInt(limit)
      },
      data: rows
    });
  } catch (err) {
    console.error(err);
    return res
      .status(500)
      .json({ success: false, error: "Internal Server Error" });
  }
}




async function addBankRecoveryRecord(req, res) {
  try {
        const {
      utr_number,
      client_name,
      qty,
      lr_awb,
      status,
      remitted_amount,
      forwarder,
      bank_name
    } = req.body;


    // Validate required fields
    if (!utr_number || !client_name || !qty || !lr_awb || !status || !remitted_amount || !forwarder || !bank_name) {
      console.log('Validation failed - missing required fields');
      return res.status(400).json({
        success: false,
        message: 'All fields are required'
      });
    }

    // Create new record in tbl_bankrecovspoid
    const newRecord = await TblBankRecovSpoid.create({
      utr_number,
      client_name,
      qty: parseInt(qty),
      lr_awb,
      status,
      remitted_amount: parseFloat(remitted_amount),
      forwarder
    });


    // Also create record in tbl_bank_remitence
    console.log('Creating corresponding record in tbl_bank_remitence...');
    const remitenceRecord = await TblBankRemitence.create({
      utr_deposited_on: new Date(), // Current date as deposit date
      utr_number: utr_number,
      remitted_amount: parseFloat(remitted_amount),
      file_uploaded_on: new Date(), // Current date as file upload date
      download_utr_data: '', // Empty string for now
      bank_name: bank_name, // Use the provided bank name
      shipment_mode: 'Express', // Default shipment mode
      Amt_Bank_Recv_Forwarder: parseFloat(remitted_amount) // Same as remitted_amount
    });


    res.json({
      success: true,
      message: 'Record added successfully to both tables',
      data: {
        bankRecovSpoid: newRecord,
        bankRemitence: remitenceRecord
      }
    });

  } catch (error) {
    console.error('Error adding bank recovery record:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to add record',
      error: error.message
    });
  }
}



async function uploadBankRecoveryExcel(req, res) {
  try {
    console.log('=== UPLOAD BANK RECOVERY EXCEL START ===');
    console.log('Request body:', req.body);
    console.log('Request file:', req.file);
    
    const { forwarder, bank_name } = req.body;
    
    // Validate forwarder name and bank name
    if (!forwarder || !bank_name) {
      console.log('âŒ Missing forwarder or bank_name');
      return res.status(400).json({
        success: false,
        message: 'Both forwarder name and bank name are required'
      });
    }

    // Check if file is uploaded
    if (!req.file) {
      console.log('âŒ No file uploaded');
      return res.status(400).json({
        success: false,
        message: 'No file uploaded'
      });
    }
    
    console.log('âœ… File uploaded successfully:', req.file.originalname);

    const XLSX = require('xlsx');
    const fs = require('fs');
    const path = require('path');
    
    let data = [];
    const fileExtension = path.extname(req.file.originalname).toLowerCase();
    
    console.log('File extension:', fileExtension);
    console.log('File path:', req.file.path);
    
    try {
    if (fileExtension === '.csv') {
      // Handle CSV file
      const csvContent = fs.readFileSync(req.file.path, 'utf8');
      const lines = csvContent.split('\n').filter(line => line.trim());
      
      if (lines.length < 2) {
        return res.status(400).json({
          success: false,
          message: 'CSV file must have at least a header row and one data row'
        });
      }
      
      // Parse CSV headers
      const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
      
      // Parse CSV data rows
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
        const row = {};
        
        headers.forEach((header, index) => {
          row[header] = values[index] || '';
        });
        
        data.push(row);
      }
    } else {
      // Handle Excel file - process ALL sheets
      const workbook = XLSX.readFile(req.file.path);
      console.log('Available sheets in Excel file:', workbook.SheetNames);
      
      // Process all sheets and combine data
      for (const sheetName of workbook.SheetNames) {
        console.log(`Processing sheet: ${sheetName}`);
      const worksheet = workbook.Sheets[sheetName];
        const sheetData = XLSX.utils.sheet_to_json(worksheet);
        console.log(`Found ${sheetData.length} rows in sheet: ${sheetName}`);
        
        // Add sheet name as a field to identify source
        const sheetDataWithSource = sheetData.map(row => ({
          ...row,
          _sourceSheet: sheetName
        }));
        
        data = data.concat(sheetDataWithSource);
      }
      
      console.log(`Total rows from all sheets: ${data.length}`);
    }
    
    console.log('âœ… File processing completed successfully');
    } catch (fileError) {
      console.error('âŒ Error processing file:', fileError);
      return res.status(400).json({
        success: false,
        message: 'Error processing file: ' + fileError.message
      });
    }

    if (data.length === 0) {
      console.log('âŒ No data found in uploaded file');
      return res.status(400).json({
        success: false,
        message: 'No data found in the uploaded file'
      });
    }

    console.log(`Processing ${data.length} rows from uploaded file`);
    console.log('Sample row structure:', data[0]);
    console.log('Available columns in first row:', Object.keys(data[0] || {}));
    console.log('First few rows of data:', data.slice(0, 3));
    
    // Test column mapping with sample data structure
    if (data.length > 0) {
      const testRow = {
        'S.no': '1',
        'Booking date': '4/14/2025',
        'Client Code': 'C186',
        'Client Name': 'JEWELLERY 4 ALL',
        'DAILY/ REVERSE': 'DAILY PICKUP',
        'Consignee Name': 'SATISH KURI',
        'Origin': 'DELHI',
        'Destination': 'GOKAK',
        'PIN CODE': '591307',
        'STATE': 'Karnataka',
        'Awb': '34508810025336',
        'VENDOR NAME': 'DELHIVERY ONE',
        'Remarks': '',
        'MODE': 'COD',
        'AMOUNT': '550',
        'STATUS': '2-May'
      };
      
      console.log('=== TESTING COLUMN MAPPING ===');
      const testClientName = testRow['Client Name'] || testRow['client_name'] || testRow['Client'] || testRow['client'] || 
                            testRow['Client_Name'] || testRow['ClientName'] || testRow['clientname'] || '';
      const testCodAmount = parseFloat(testRow['COD AMOUNT'] || testRow['cod_amount'] || testRow['COD Amount'] || 
                         testRow['Cod Amount'] || testRow['Amount'] || testRow['amount'] || testRow['COD_AMOUNT'] || 
                         testRow['codamount'] || testRow['COD'] || testRow['AMOUNT'] || testRow['AMT'] || 0) || 0;
      const testOrderType = testRow['ORDER TYPE PREPAID/COD'] || testRow['order_type'] || testRow['Order Type'] || 
                           testRow['ORDER_TYPE'] || testRow['OrderType'] || testRow['ordertype'] || 
                           testRow['MODE PRE/COD'] || testRow['MODE'] || testRow['ORDER TYPE'] || testRow['mode'] || '';
      
      console.log('Test mapping results:');
      console.log('- Client Name:', testClientName);
      console.log('- COD Amount:', testCodAmount);
      console.log('- Order Type:', testOrderType);
      console.log('- Is COD Order:', testOrderType && testOrderType.toLowerCase().includes('cod'));
      console.log('- Has COD Amount:', testCodAmount > 0);
    }
    
    // Debug: Check if we can find the expected columns
    if (data.length > 0) {
      const firstRow = data[0];
      console.log('=== COLUMN MAPPING DEBUG ===');
      console.log('All available columns:', Object.keys(firstRow));
      console.log('Client Name found:', !!firstRow['Client Name']);
      console.log('Awb found:', !!firstRow['Awb']);
      console.log('AMOUNT found:', !!firstRow['AMOUNT']);
      console.log('MODE found:', !!firstRow['MODE']);
      console.log('Client Code found:', !!firstRow['Client Code']);
      console.log('Client Co found:', !!firstRow['Client Co']);
      console.log('Booking date found:', !!firstRow['Booking date']);
      console.log('Consignee Name found:', !!firstRow['Consignee Name']);
      console.log('DAILY/ REVERSE found:', !!firstRow['DAILY/ REVERSE']);
      console.log('First row sample values:');
      console.log('- Client Name:', firstRow['Client Name']);
      console.log('- Awb:', firstRow['Awb']);
      console.log('- AMOUNT:', firstRow['AMOUNT']);
      console.log('- MODE:', firstRow['MODE']);
      console.log('- Client Code:', firstRow['Client Code']);
    }

    // Process and insert data
    const records = [];
    let insertedRows = 0;
    let skippedRows = 0;
    const skippedReasons = [];

    console.log('=== STARTING ROW PROCESSING ===');
    for (const row of data) {
      try {
        // Handle the new Excel format with different column names
        // Map the new format columns to our expected fields - try multiple variations
        // Also handle trailing spaces in column names
        const awbNumber = row['Awb'] || row['Awb '] || row['AWB'] || row['AWB '] || row['awb'] || row['AWB Number'] || row['awb_number'] || 
                         row['LR/AWB'] || row['lr_awb'] || row['LR'] || row['AWB'] || row['lr'] || row['awb'] || 
                         row['LRN'] || row['lrn'] || row['Lr'] || '';
        const clientName = row['Client Name'] || row['Client Name '] || row['client_name'] || row['Client'] || row['client'] || 
                          row['Client_Name'] || row['ClientName'] || row['clientname'] || '';
        const codAmount = parseFloat(row['COD AMOUNT'] || row['COD AMOUNT '] || row['cod_amount'] || row['COD Amount'] || 
                       row['Cod Amount'] || row['Amount'] || row['Amount '] || row['amount'] || row['COD_AMOUNT'] || 
                       row['codamount'] || row['COD'] || row['AMOUNT'] || row['AMOUNT '] || row['AMT'] || 0) || 0;
        const quantity = parseInt(row['Qnty'] || row['Qnty '] || row['qnty'] || row['Quantity'] || row['quantity'] || 
                        row['Qty'] || row['qty'] || row['QTY'] || row['QNTY'] || 
                        row['No. Of Boxes'] || row['No Of Boxes'] || row['Boxes'] || 1) || 1;
        const orderType = row['ORDER TYPE PREPAID/COD'] || row['order_type'] || row['Order Type'] || 
                         row['ORDER_TYPE'] || row['OrderType'] || row['ordertype'] || 
                         row['MODE PRE/COD'] || row['MODE'] || row['MODE '] || row['ORDER TYPE'] || row['mode'] || '';
        const bookingDate = row['Booking date'] || row['Booking date '] || row['booking_date'] || row['Booking Date'] || 
                           row['BOOKING_DATE'] || row['BookingDate'] || row['bookingdate'] || '';
        const clientCode = row['Client Code'] || row['Client Code '] || row['Client Co'] || row['client_code'] || row['Client_Code'] || 
                          row['CLIENT_CODE'] || row['ClientCode'] || row['clientcode'] || '';
        const consigneeName = row['Consignee Name'] || row['Consignee Name '] || row['DAILY/REV Consignee Name'] || row['DAILY/ REVERSE'] || 
                             row['consignee_name'] || row['Consignee_Name'] || row['CONSIGNEE_NAME'] || 
                             row['ConsigneeName'] || row['consigneename'] || '';
        const origin = row['Origin'] || row['Origin '] || row['origin'] || row['ORIGIN'] || '';
        const destination = row['Destination'] || row['Destination '] || row['destination'] || row['DESTINATION'] || '';
        const dispatchMode = row['DISPATCH MODE'] || row['dispatch_mode'] || row['Dispatch Mode'] || 
                            row['DISPATCH_MODE'] || row['DispatchMode'] || row['dispatchmode'] || '';
        const vendorName = row['VENDOR NAME'] || row['VENDOR NAME '] || row['vendor_name'] || row['Vendor Name'] || 
                          row['VENDOR_NAME'] || row['VendorName'] || row['vendorname'] || '';
        const remark = row['REMARK'] || row['REMARK '] || row['remark'] || row['Remark'] || row['REMARKS'] || '';
        const acc = row['ACC'] || row['ACC '] || row['acc'] || row['ACCOUNT'] || '';

        // Generate UTR number if not present - use AWB number as base
        let utrNumber = '';
        if (awbNumber) {
          // Generate UTR using AWB number + microsecond timestamp for uniqueness
          const timestamp = Date.now().toString();
          const randomSuffix = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
          utrNumber = `UTR${awbNumber}${timestamp.slice(-8)}${randomSuffix}`;
        } else if (clientCode) {
          // If no AWB, generate using client code and timestamp
          const timestamp = Date.now().toString();
          const randomSuffix = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
          utrNumber = `UTR${clientCode}${timestamp.slice(-8)}${randomSuffix}`;
        } else {
          // Fallback: use timestamp and random number
          const timestamp = Date.now().toString();
          const randomSuffix = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
          utrNumber = `UTR${timestamp}${randomSuffix}`;
        }

        // Filter to only include COD orders
        const isCodOrder = orderType && (
          orderType.toLowerCase().includes('cash') || 
          orderType.toLowerCase().includes('to pay') || 
          orderType.toLowerCase().includes('cod') ||
          orderType.toLowerCase().includes('cheque')
        );
        
        // Also check if amount is greater than 0 (indicating COD)
        const hasCodAmount = codAmount > 0;
        
        console.log(`Row processing - OrderType: "${orderType}", IsCOD: ${isCodOrder}, HasCodAmount: ${hasCodAmount}, Client: "${clientName}", AWB: "${awbNumber}", Amount: ${codAmount}`);
        
        // Skip non-COD orders (unless they have COD amount)
        if (!isCodOrder && !hasCodAmount && orderType) {
          console.log('Skipping non-COD order:', {
            orderType: orderType,
            clientName: clientName,
            awbNumber: awbNumber,
            codAmount: codAmount
          });
          skippedRows++;
          skippedReasons.push(`Non-COD order skipped - Order Type: "${orderType}", Amount: ${codAmount}`);
          continue; // Skip this row
        }
        
        // Determine status based on order type and other factors
        let status = 'Pending';
        if (orderType && orderType.toLowerCase().includes('prepaid')) {
          status = 'Completed';
        } else if (isCodOrder || hasCodAmount) {
          status = codAmount > 0 ? 'Pending' : 'Completed';
        } else if (orderType && orderType.toLowerCase().includes('cod')) {
          status = codAmount > 0 ? 'Pending' : 'Completed';
        }

        // Create the record with mapped fields (now including all the new columns)
        const record = {
          utr_number: utrNumber,
          client_name: clientName,
          qty: isNaN(quantity) ? 0 : quantity,
          lr_awb: awbNumber,
          status: status,
          remitted_amount: isNaN(codAmount) ? 0 : codAmount,
          forwarder: forwarder, // Use the provided forwarder name for all records
          bank_name: bank_name, // Use the provided bank name for all records
          cod_amount: isNaN(codAmount) ? 0 : codAmount,
          client_code: clientCode,
          consignee_name: consigneeName,
          origin: origin,
          destination: destination,
          dispatch_mode: dispatchMode,
          vendor_name: vendorName,
          remark: remark,
          acc: acc,
          booking_date: bookingDate ? new Date(bookingDate) : null,
          order_type: orderType
        };

        // More lenient validation - only require client name OR AWB OR client code
        if (record.client_name || record.lr_awb || clientCode) {
          // Additional validation to ensure no NaN values
          if (isNaN(record.qty) || isNaN(record.remitted_amount)) {
            console.log('Skipping row due to NaN values:', record);
            skippedRows++;
            skippedReasons.push(`Invalid numeric values - Qty: ${record.qty}, Amount: ${record.remitted_amount}`);
          } else {
          records.push(record);
            console.log('âœ… Added record:', {
              client_name: record.client_name,
              lr_awb: record.lr_awb,
              qty: record.qty,
              remitted_amount: record.remitted_amount,
              status: record.status,
              utr_number: record.utr_number
            });
          }
        } else {
          skippedRows++;
          const reason = `Missing all identifying fields - Client: "${record.client_name}", AWB: "${record.lr_awb}", ClientCode: "${clientCode}"`;
          skippedReasons.push(reason);
          console.log('Skipping row due to missing all identifying fields:', {
            client_name: record.client_name,
            lr_awb: record.lr_awb,
            client_code: clientCode,
            original_row: row
          });
        }
      } catch (error) {
        console.error('Error processing row:', error, 'Row data:', row);
        continue;
      }
    }

    
    console.log(`=== UPLOAD SUMMARY ===`);
    console.log(`Total rows processed: ${data.length}`);
    console.log(`Valid COD records found: ${records.length}`);
    console.log(`Skipped rows: ${skippedRows}`);
    console.log(`Skipped reasons:`, skippedReasons.slice(0, 5));
    console.log(`Sample records:`, records.slice(0, 3));
    
    if (records.length === 0) {
      console.log('âŒ NO RECORDS TO INSERT - This will cause the error message');
      console.log('First few rows for debugging:', data.slice(0, 2));
    } else {
      console.log('âœ… Records ready for insertion');
    }
    
    if (records.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'No valid records found in the uploaded file. Please ensure your file has columns like: Client Name, Awb, AMOUNT, MODE, etc.'
      });
    }

    // Insert records in batches
    const batchSize = 100;
    
    console.log('=== STARTING DATABASE INSERTION ===');
    try {
    // Insert into tbl_bankrecovspoid (Bank Forwarder Reconciliation)
    for (let i = 0; i < records.length; i += batchSize) {
      const batch = records.slice(i, i + batchSize);
        console.log(`Inserting batch ${Math.floor(i/batchSize) + 1} with ${batch.length} records`);
      await TblBankRecovSpoid.bulkCreate(batch);
      insertedRows += batch.length;
    }
    
    // Insert into tbl_bank_remitence (Bank Remittance)
    const remitenceRecords = records.map(record => ({
      utr_deposited_on: new Date(), // Current date as deposit date
      utr_number: record.utr_number,
      remitted_amount: record.remitted_amount,
      file_uploaded_on: new Date(), // Current date as file upload date
      download_utr_data: '', // Empty string for now
      bank_name: bank_name, // Use the provided bank name
      shipment_mode: 'Ecom', // Default shipment mode
      Amt_Bank_Recv_Forwarder: record.remitted_amount // Same as remitted_amount
    }));
    
    for (let i = 0; i < remitenceRecords.length; i += batchSize) {
      const batch = remitenceRecords.slice(i, i + batchSize);
      console.log(`Inserting remittance batch ${Math.floor(i/batchSize) + 1} with ${batch.length} records`);
      await TblBankRemitence.bulkCreate(batch);
    }
    
    console.log('âœ… Database insertion completed successfully');
    console.log(`Total records inserted: ${insertedRows}`);
    console.log(`Total records skipped: ${skippedRows}`);

    res.json({
      success: true,
      message: `Successfully uploaded ${insertedRows} COD records from all sheets to both tables${skippedRows > 0 ? ` (${skippedRows} rows skipped - includes non-COD orders and missing required fields)` : ''}`,
      insertedRows: insertedRows,
      skippedRows: skippedRows,
      skippedReasons: skippedReasons.slice(0, 5) // Show first 5 reasons for debugging
    });
    
    } catch (dbError) {
      console.error('âŒ Database insertion error:', dbError);
      return res.status(500).json({
        success: false,
        message: 'Database insertion failed: ' + dbError.message
      });
    }

  } catch (error) {
    console.error('Error uploading bank recovery Excel:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to upload file',
      error: error.message
    });
  }
}



const getCourierSettings = async (req, res, next) => {
  try {
    const accessdata = await access(req.user);
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    const lang_data = req.language_data;
    const language_name = req.lang;
    let walletBalance = 0;
    let vasService = 0;

    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = ? ORDER BY id DESC LIMIT 3`,
      [role_data.id]
    );

    let loginDetails = null;
    let clientId = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,company_name,vas,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    let activeTopicIds = [];
    if (activeTopics && Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    res.render('pages/courier-settings', {
      role_data,
      accessdata,
      bodyClass: 'profile-page',
      activePage: 'profile',
      title: 'Courier Settings',
      layout: 'partials/layout-vertical',
      lang_data,
      language_name,
      notification_data,
      activeTopicIds,
      loginDetails,
      profile,
      clientId,
      walletBalance,
      vasService, role
    });

  } catch (error) {
    console.error('Error fetching courier settings:', error);
    next(error);
  }
}
const getMasterDocket = async (req, res, next) => {
  const [loginDetails] = await mySqlQury(
    'SELECT first_name, role_name,company_name,logo_path FROM tbl_admin WHERE id = ?', [req.user.id]
  );
  let activeTopicIds = [];
  res.render('apps/awb-report', { title: 'Courier Settings', activeTopicIds, loginDetails })
}
const getCustomReport = async (req, res, next) => {
  const [loginDetails] = await mySqlQury(
    'SELECT first_name, role_name,company_name,logo_path FROM tbl_admin WHERE id = ?', [req.user.id]
  );
  let activeTopicIds = [];
  res.render('apps/custom-report', { title: 'Courier Settings', activeTopicIds, loginDetails })
}
const getMasterDocket2 = async (req, res, next) => {
  try {
    const accessdata = await access(req.user);
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    const lang_data = req.language_data;
    const language_name = req.lang;
    let walletBalance = 0;
    let vasService = 0;
    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = ? ORDER BY id DESC LIMIT 3`,
      [role_data.id]
    );

    let loginDetails = null;
    let clientId = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,company_name,vas,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Fetch data from tbl_manuallrs with client name join
    const manualLrsData = await mySqlQury(`
      SELECT m.id, m.mlr_date, m.Client_id, m.aggrigator_id, m.agg_type, 
             m.Lr_Awb_no, m.lr_forwarder, m.product_type, m.status,
             c.company_name as client_name
      FROM tbl_manuallrs m
      LEFT JOIN tbl_admin c ON m.Client_id = c.id
    `);

    const clientsData = await mySqlQury(
      'SELECT id, company_name FROM tbl_admin'
    );

    const aggregatorsData = await mySqlQury(
      'SELECT id, Aggrigator_company_name FROM tbl_aggrigator'
    );

    // Map aggregators data to easily find Aggrigator_company_name by aggrigator_id
    const aggregators = aggregatorsData.reduce((acc, aggregator) => {
      acc[aggregator.id] = aggregator.Aggrigator_company_name;
      return acc;
    }, {});

    // Aggregate data by lr_forwarder, Client_id, and aggrigator_id
    const groupedData = manualLrsData.reduce((acc, entry) => {
      const aggregatorName = aggregators[entry.aggrigator_id] || 'Unknown Aggregator';
      const clientName = entry.client_name || 'Unknown Client';

      const key = `${entry.Client_id}-${entry.lr_forwarder}-${aggregatorName}`;

      if (!acc[key]) {
        acc[key] = {
          Client_id: entry.Client_id,
          client_name: clientName,
          lr_forwarder: entry.lr_forwarder,
          aggrigator_company_name: aggregatorName,
          total: 0,
          nonConsumed: 0,
          consumed: 0,
          agg_type: entry.agg_type,
          product_type: entry.product_type,
        };
      }

      acc[key].total++;
      if (entry.status === 1) {
        acc[key].nonConsumed++;
      } else {
        acc[key].consumed++;
      }

      return acc;
    }, {});

    const groupedDataArray = Object.values(groupedData);

    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    let activeTopicIds = [];
    if (activeTopics && Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    res.render('pages/master-docket', {
      title: 'Master Docket',
      bodyClass: 'profile-page',
      activePage: 'profile',
      role_data,
      accessdata,
      layout: 'partials/layout-vertical',
      lang_data,
      language_name,
      notification_data,
      loginDetails,
      manualLrsData: groupedDataArray,
      clients: clientsData,
      activeTopicIds,
      profile,
      clientId,
      walletBalance,
      vasService, role
    });

  } catch (error) {
    console.error('Error in /master-docket:', error);
    next(error);
  }
}
const getchatUi = async (req, res, next) => {
  try {
    const accessdata = await access(req.user);
    const role_data = req.user;
    const role = req.user.role;
    console.log("req user", req.user)
    const relatedClientId = req.user.clientId;
    const lang_data = req.language_data;
    const language_name = req.lang;
    let walletBalance = 0;
    let vasService = 0;
    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = ? ORDER BY id DESC LIMIT 3`,
      [role_data.id]
    );

    let loginDetails = null;
    let clientId = 0;
    let whatsAppSubscriber = false;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,company_name,logo_path ,vas FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

    } else {
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Fetch WhatsApp subscribers (clients)
    let whatsappClients = [];
    let whatsAppWalletBalance = 0;
    if (role === 1) {
      whatsappClients = await mySqlQury(
        `SELECT * FROM whatsapp_subscribers ORDER BY subscribed_at DESC`
      );
      whatsAppSubscriber = true;
      whatsAppWalletBalance = 1;
    } else {
      whatsappClients = await mySqlQury(
        `SELECT * FROM whatsapp_subscribers WHERE client_id = ? ORDER BY subscribed_at DESC`,
        [clientId]

      );
      let [whatsappwallet] = await mySqlQury(`SELECT balance FROM whatsapp_wallet WHERE client_id =?`, [clientId]);
      console.log("whatsappwallet", whatsappwallet)
      whatsAppWalletBalance = whatsappwallet ? whatsappwallet.balance : 0;
      console.log("whatsAppWalletBalance", whatsAppWalletBalance)
      whatsAppSubscriber = whatsappClients.some(client => client.client_id === clientId);
    }

    // Fetch orders for these clients
    const clientIds = whatsappClients.map(client => client.client_id);
    let whatsappOrders = [];

    if (clientIds.length > 0) {
      if (role === 1) {
        whatsappOrders = await mySqlQury(
          `SELECT * FROM whatsapp_orders ORDER BY created_at DESC`
        );
      } else {
        whatsappOrders = await mySqlQury(
          `SELECT * FROM whatsapp_orders WHERE client_id = ? ORDER BY created_at DESC`,
          [clientId]
        );
      }
    }

    // Fetch messages for these orders
    let whatsappMessages = [];

    if (role === 1) {
      whatsappMessages = await mySqlQury(
        `SELECT * FROM whatsapp_messages ORDER BY created_at ASC`
      );
    } else {
      const orderIds = whatsappOrders.map(order => order.id);

      if (orderIds.length > 0) {
        const placeholders = orderIds.map(() => '?').join(',');
        whatsappMessages = await mySqlQury(
          `SELECT * FROM whatsapp_messages WHERE order_id IN (${placeholders}) ORDER BY created_at ASC`,
          orderIds
        );
      }
    }
    console.log("whats app message", whatsappMessages)

    // Organize the data
    const organizedData = whatsappOrders.map(order => {
      console.log("order", order)
      const client = whatsappClients.find(client => client.client_id === order.client_id);
      const messages = whatsappMessages.filter(message => message.order_id == order.order_number);
      console.log("message", messages)

      return {
        id: order.id,
        client_id: order.client_id,
        order_number: order.order_number,
        customer_name: client ? order.customer_name : 'Unknown', // Use client.name for customer name
        customer_phone: client ? order.customer_phone : 'Unknown', // Use client.phone_number for customer phone
        created_at: order.created_at,
        messages: messages.map(message => ({
          id: message.id,
          sender_type: message.sender_type,
          message_text: message.message_text,
          attachment_url: message.attachment_url,
          direction: message.direction,
          created_at: message.created_at
        }))
      };
    });

    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    let activeTopicIds = [];
    if (activeTopics && Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }
    console.log("whatsappsubscriber", whatsAppSubscriber)

    console.log("Organized Data:", organizedData);
    whatsAppWalletBalance,
      // console.log("what krishna",walletBalance,whatsAppWalletBalance,)
      res.render('pages/chat-ui', {
        title: 'chat',
        bodyClass: 'profile-page',
        activePage: 'profile',
        role_data,
        accessdata,
        lang_data,
        language_name,
        notification_data,
        loginDetails,
        activeTopicIds,
        profile,
        clientId,
        walletBalance,
        whatsAppSubscriber,
        whatsAppWalletBalance,
        organizedData, // Pass organized data to the template
        vasService, role
      });

  } catch (error) {
    console.error('Error in /chat-ui:', error);
    next(error);
  }
}
const getChatUiSetting = async (req, res, next) => {
  try {
    const accessdata = await access(req.user);
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    const lang_data = req.language_data;
    const language_name = req.lang;
    let walletBalance = 0;
    let vasService = 0;

    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = ? ORDER BY id DESC LIMIT 3`,
      [role_data.id]
    );

    let loginDetails = null;
    let clientId = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id, first_name, company_name, logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    let activeTopicIds = [];
    if (activeTopics && Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    // Fetch WhatsApp subscriber data for the clientId
    const subscriberData = await mySqlQury(
      `SELECT * FROM whatsapp_subscribers WHERE client_id = ?`,
      [clientId]
    );
    console.log("subscriberData", subscriberData)

    res.render('pages/chat-ui-setting', {
      role_data,
      accessdata,
      title: 'Tracking Master',
      layout: 'partials/layout-vertical',
      lang_data,
      bodyClass: 'profile-page',
      activePage: 'profile',
      language_name,
      notification_data,
      activeTopicIds,
      loginDetails: loginDetails || {},
      profile,
      clientId,
      walletBalance,
      subscriberData, // Pass subscriber data to the template
      vasService, role
    });

  } catch (error) {
    console.error(error);
    next(error);
  }
}
const postapiWhatsappSubs = async (req, res) => {
  try {
    console.log("req user", req.user); // Authenticated user info
    // console.log("kdsdhsdf",dhdhusdfuf)
    const userId = req.user.id;
    const clientId = req.user.clientId;

    // Fetch email, first_name, last_name, mobile from tbl_admin for the given clientId
    const clientData = await mySqlQury(
      `SELECT email,id, first_name, last_name, mobile FROM tbl_admin WHERE login_id = ?`,
      [clientId]
    );

    if (!clientData || clientData.length === 0) {
      return res.status(404).json({ success: false, message: 'Client data not found' });
    }
    console.log("client id", clientData[0])
    console.log("client id", clientData)

    const { email, first_name, last_name, mobile, id } = clientData[0];
    const name = `${first_name || ''} ${last_name || ''}`.trim() || 'Unknown';

    // Check if already subscribed
    const existing = await mySqlQury(
      `SELECT id FROM whatsapp_subscribers WHERE phone_number = ? AND client_id = ?`,
      [mobile, id]
    );

    if (existing.length > 0) {
      return res.json({ success: true, message: 'Already subscribed' });
    }

    // Insert new subscription with fetched details
    await mySqlQury(
      `INSERT INTO whatsapp_subscribers (client_id, name, phone_number, email, subscribed_at) VALUES (?, ?, ?, ?, NOW())`,
      [id, name, mobile, email || null]
    );

    return res.json({ success: true, message: 'Subscribed successfully' });
  } catch (error) {
    console.error("Error subscribing to WhatsApp:", error);
    return res.status(500).json({ success: false, message: 'Internal server error' });
  }
}
const postapiUpdateStatus = async (req, res) => {
  try {
    const { client_id, status_type, value } = req.body;
    // Validate input
    if (!client_id || !status_type || (value !== 0 && value !== 1)) {
      return res.status(400).json({ success: false, message: 'Invalid input' });
    }
    // Update the corresponding status in the whatsapp_subscribers table
    const result = await mySqlQury(
      `UPDATE whatsapp_subscribers SET ${status_type} = ? WHERE client_id = ?`,
      [value, client_id]
    );
    if (result.affectedRows > 0) {
      return res.json({ success: true, message: 'Status updated successfully' });
    } else {
      return res.status(404).json({ success: false, message: 'Subscriber not found' });
    }
  } catch (error) {
    console.error("Error updating status:", error);
    return res.status(500).json({ success: false, message: 'Internal server error' });
  }
}
const postapiWhatsappToggleActvation = async (req, res) => {
  try {
    const { client_id } = req.body;

    // Validate input
    if (!client_id) {
      return res.status(400).json({ success: false, message: 'Invalid input' });
    }

    // Fetch current status
    const [subscriber] = await mySqlQury(
      `SELECT isactive FROM whatsapp_subscribers WHERE client_id = ?`,
      [client_id]
    );

    if (!subscriber) {
      return res.status(404).json({ success: false, message: 'Subscriber not found' });
    }

    // Toggle the isactive status
    const newStatus = subscriber.isactive === 1 ? 0 : 1;

    // Update the status in the database
    await mySqlQury(
      `UPDATE whatsapp_subscribers SET isactive = ? WHERE client_id = ?`,
      [newStatus, client_id]
    );

    return res.json({ success: true, isactive: newStatus });
  } catch (error) {
    console.error("Error toggling activation:", error);
    return res.status(500).json({ success: false, message: 'Internal server error' });
  }
}
const getapiCustomerPhoneOrders = async (req, res) => {
  try {
    console.log("req params", req.params)
    const customer_phone = Number(req.params.customer_phone);
    const clientId = Number(req.params.clientId);
    if (isNaN(customer_phone)) return res.status(400).json({ error: 'Invalid customer ID' });
    const orders = await mySqlQury(
      `SELECT * FROM whatsapp_orders WHERE client_id = ? AND customer_phone = ? ORDER BY created_at DESC`,
      [clientId, customer_phone]
    );
    res.json(orders);
  } catch (error) {
    console.error('Error fetching orders:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
const apiOrdersClientMassage = async (req, res) => {
  try {
    const orderId = Number(req.params.orderId);
    const clientId = Number(req.params.clientId);
    if (isNaN(orderId)) return res.status(400).json({ error: 'Invalid order ID' });
    const messages = await mySqlQury(
      `SELECT * FROM whatsapp_messages WHERE order_id = ? AND client_id = ? ORDER BY created_at ASC`,
      [orderId, clientId]
    );
    res.json(messages);
  } catch (error) {
    console.error('Error fetching messages:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
const postapiMassages = async (req, res) => {
  try {
    console.log("req body", req.body);
    const whatsApi = process.env.WHATS_APP_API;
    // console.log("error",jhsgahgdh)
    const io = socket.getIO(); // Get initialized io instance
    const { order_id, client_id, sender_type, message_text, attachment_url, direction, customer_phone } = req.body;
    if (!order_id || !client_id || !sender_type || !message_text) {
      return res.status(400).json({ error: 'Missing required fields' });
    }
    let modifiednumber = `91${customer_phone}`;
    // modifiednumber = "917011516727"
    // Save message to database
    const saveResult = await mySqlQury(
      `INSERT INTO whatsapp_messages (order_id, client_id, sender_type, message_text, attachment_url, direction, created_at)
       VALUES (?, ?, ?, ?, ?, ?, NOW())`,
      [order_id, client_id, sender_type, message_text, attachment_url || null, direction || 'sent']
    );
    // Find the newly inserted message (assuming auto_increment ID)
    const [newMessage] = await mySqlQury(
      `SELECT * FROM whatsapp_messages WHERE id = ?`,
      [saveResult.insertId]
    );
    // Emit socket event to relevant clients
    io.to(`order_${order_id}`).emit('newMessage', newMessage);
    // Send message via Interakt API
    // const whatsappResponse = await axios.post('https://api.interakt.ai/v1/public/message/', {
    //   userId: "", // Optional: Include userId if needed
    //   fullPhoneNumber: modifiednumber, // The recipient's phone number
    //   callbackData: "some_callback_data", // Optional: Include any callback data if needed
    //   type: "Text", // Message type
    //   data: {
    //     message: message_text // The message text
    //   }
    // }, {
    //   headers: {
    //     'Authorization': `Basic ${whatsApi}`, // Replace with your actual token
    //     'Content-Type': 'application/json'
    //   }
    // });
    // // Check the response from the WhatsApp API
    // if (whatsappResponse.status === 200) {
    //   console.log('Message sent to WhatsApp successfully:', whatsappResponse.data);
    // } else {
    //   console.error('Failed to send message to WhatsApp:', whatsappResponse.data);
    // }
    // Respond to the client
    res.json(newMessage);
  } catch (error) {
    console.error('Error saving message:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
const postUploadExcel = async (req, res) => {
  const { client_id, aggregator_id } = req.body;
  const files = req.files; // The uploaded files array
  console.log("Response Data", req.body, req.files);

  // Check if a file was uploaded
  if (!files || files.length === 0) {
    return res.json({ success: false, message: 'No file uploaded.' });
  }

  try {
    // Start the transaction
    await mySqlQury('START TRANSACTION');

    const file = files[0];
    console.log("Uploading file:", file);

    const filePath = file.path;
    const fileExtension = path.extname(file.originalname).toLowerCase();

    // Validate the file type
    if (fileExtension !== '.xlsx' && fileExtension !== '.xls') {
      // Rollback in case of error
      await mySqlQury('ROLLBACK');
      return res.json({ success: false, message: 'Unsupported file format. Please upload an Excel file (.xlsx or .xls).' });
    }

    // Read the Excel file
    const workbook = xlsx.readFile(filePath);
    const sheetName = 'tbl_manuallrs';

    // Check if the expected sheet name exists
    if (!workbook.SheetNames.includes(sheetName)) {
      // Rollback in case of error
      await mySqlQury('ROLLBACK');
      return res.json({ success: false, message: `Sheet "${sheetName}" not found in the uploaded file.` });
    }

    // Parse the required sheet's data into JSON
    const data = xlsx.utils.sheet_to_json(workbook.Sheets[sheetName]);
    console.log('Excel Data:', data);

    // Ensure data contains required fields
    if (!data.length || !data[0].agg_type || !data[0].Lr_Awb_no) {
      // Rollback in case of error
      await mySqlQury('ROLLBACK');
      return res.json({ success: false, message: 'Invalid file structure or empty data.' });
    }

    // Insert each row from the Excel file into the tbl_manuallrs table
    const insertPromises = data.map(async (row) => {
      const {
        agg_type,
        Lr_Awb_no,
        lr_forwarder,
        product_type,
        status,
      } = row;

      const mlr_date = new Date(); // Set the current date as mlr_date
      const client_id_int = parseInt(client_id);
      const aggregator_id_int = parseInt(aggregator_id);
      const checkQuery = 'SELECT COUNT(*) AS count FROM tbl_manuallrs WHERE Lr_Awb_no = ?';
      const result = await mySqlQury(checkQuery, [Lr_Awb_no]);

      console.log(`Checking Lr_Awb_no ${Lr_Awb_no}:`, result[0].count);

      if (result[0].count > 0) {
        console.log(`Lr_Awb_no ${Lr_Awb_no} already exists. Skipping insert.`);
        return; // Skip the insertion if Lr_Awb_no exists
      }

      try {
        console.log(`Inserting Lr_Awb_no ${Lr_Awb_no}`);
        // Insert data into the tbl_manuallrs table using the mySqlQury function
        const query = `
          INSERT INTO tbl_manuallrs (mlr_date, client_id, aggrigator_id, agg_type, Lr_Awb_no, lr_forwarder, product_type, status)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `;
        const insertResult = await mySqlQury(query, [mlr_date, client_id_int, aggregator_id_int, agg_type, Lr_Awb_no, lr_forwarder, product_type, status]);

        console.log('Insert result:', insertResult); // Log the result of the insert query

      } catch (error) {
        console.error('Error inserting row:', error);
        throw new Error('Error inserting row into the database.');
      }
    });

    // Wait for all insertions to complete
    await Promise.all(insertPromises);

    // Commit the transaction after successful insertions
    await mySqlQury('COMMIT');

    // Respond with success
    res.json({ success: true, message: 'File uploaded and data inserted successfully!' });

  } catch (error) {
    console.error('Error processing file:', error);

    // Rollback the transaction in case of any error
    await mySqlQury('ROLLBACK');

    // Respond with failure message
    res.json({ success: false, message: 'Error processing file.' });
  }
}
const getFilterLrs = async (req, res, next) => {
  const { forwarder, series } = req.query;

  // Fetch filtered data from the database based on forwarder and series
  const query = `
    SELECT id, mlr_date, Client_id, aggrigator_id, agg_type, Lr_Awb_no, lr_forwarder, product_type, status
    FROM tbl_manuallrs
    WHERE (lr_forwarder = ? OR ? IS NULL) AND (agg_type = ? OR ? IS NULL)
  `;
  const manualLrsData = await mySqlQury(query, [forwarder, forwarder, series, series]);

  // Fetch aggregators data to map aggrigator_id to Aggrigator_company_name
  const aggregatorsData = await mySqlQury(
    'SELECT id, Aggrigator_company_name FROM tbl_aggrigator'
  );

  // Map aggregators data to easily find Aggrigator_company_name by aggrigator_id
  const aggregators = aggregatorsData.reduce((acc, aggregator) => {
    acc[aggregator.id] = aggregator.Aggrigator_company_name;
    return acc;
  }, {});

  // Initialize an object to store aggregated counts
  const aggregatedData = {};

  // Group data by Client_id and lr_forwarder, and calculate total, nonConsumed, and balance docket counts
  manualLrsData.forEach(entry => {
    const { Client_id, lr_forwarder, status, aggrigator_id, agg_type, product_type } = entry;

    // Use aggrigator_id to get the Aggrigator_company_name
    const aggregatorName = aggregators[aggrigator_id] || 'Unknown Aggregator';

    // Initialize the object if it's the first occurrence of the group
    const key = `${Client_id}-${lr_forwarder}`;
    if (!aggregatedData[key]) {
      aggregatedData[key] = {
        Client_id,
        lr_forwarder,
        aggrigator_company_name: aggregatorName,  // Include Aggrigator_company_name
        agg_type,
        product_type,
        total: 0,
        nonConsumed: 0,
      };
    }

    // Increment the total docket count
    aggregatedData[key].total++;

    // Increment the non-consumed docket count if status is 1
    if (status === 1) {
      aggregatedData[key].nonConsumed++;
    }
  });

  // Convert aggregated data into an array
  const result = Object.values(aggregatedData).map(entry => {
    // Calculate the balance docket count (total - nonConsumed)
    entry.balance = entry.total - entry.nonConsumed;
    return entry;
  });

  // Return the aggregated data as JSON
  res.json(result);
}
const getMasterPincode = async (req, res, next) => {
  try {
    const accessdata = await access(req.user);
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    const lang_data = req.language_data;
    const language_name = req.lang;
    let walletBalance = 0;
    let vasService = 0;

    let loginDetails = null;
    let clientId = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,company_name,vas,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Pagination parameters
    const page = parseInt(req.query.page) || 1; // Current page
    const limit = parseInt(req.query.limit) || 10; // Records per page
    const offset = (page - 1) * limit; // Calculate offset

    // Fetch total count of records
    const totalRecords = await mySqlQury('SELECT COUNT(*) as count FROM tbl_master_pincode');
    const totalCount = totalRecords[0].count;

    // Fetch paginated data
    const pincodeData = await mySqlQury('SELECT * FROM tbl_master_pincode LIMIT ? OFFSET ?', [limit, offset]);

    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    let activeTopicIds = [];
    if (activeTopics && Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }

    // Calculate total pages
    const totalPages = Math.ceil(totalCount / limit);

    res.render('pages/master-pincode', {
      title: 'Master Pincode',
      bodyClass: 'profile-page',
      activePage: 'profile',
      activeTopicIds,
      loginDetails,
      profile,
      role_data,
      accessdata,
      pincodeData, // Send the paginated pincode data to the view
      currentPage: page,
      totalPages: totalPages,
      totalCount: totalCount,
      clientId,
      walletBalance,
      vasService, role
    });
  } catch (error) {
    console.error('Error fetching master pincode:', error);
    next(error);
  }
}
const getAggrigatorList = async (req, res, next) => {
  try {
    const accessdata = await access(req.user);
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId; // Use selected_client_id for all logic
    const lang_data = req.language_data;
    const language_name = req.lang;
    let walletBalance = 0;
    let vasService = 0;
    let loginDetails = null;
    let clientId = 0;

  
    // Aggregator List logic
    let aggrigatorList = [];
    let firstLogisticsId = null;

    if (selectedClientId == 1) {
      // Superadmin or "all" - show all aggregators
      aggrigatorList = await mySqlQury(`
        SELECT 
          lp.id AS Aggrigator_id,
          lp.tagged_api,
          lp.courier_id,
          lp.name AS aggrigator_name,
          lp.volumetric_factor,
          lp.business_volume,
          lp.created_at,
          lp.updated_at,
          lp.status,
          lp.aggrigator_type,
          cd.courier_type,
          cd.service_type,
          cd.company_name,
          cd.logo_path,
          cd.delhivery_api_variant,
          cd.packet_shipment
        FROM 
          tbl_logistics_partner lp
        LEFT JOIN 
          tbl_courier_details cd ON lp.courier_id = cd.id
        WHERE lp.aggrigator_type = 1
        ORDER BY lp.id DESC
      `);
    } else {
      // For a specific client, show only aggregators linked in tbl_client_lp
      aggrigatorList = await mySqlQury(`
        SELECT 
          lp.id AS Aggrigator_id,
          lp.tagged_api,
          lp.courier_id,
          lp.name AS aggrigator_name,
          lp.volumetric_factor,
          lp.business_volume,
          lp.created_at,
          lp.updated_at,
          lp.status,
          lp.aggrigator_type,
          cd.courier_type,
          cd.service_type,
          cd.company_name,
          cd.logo_path,
          cd.delhivery_api_variant,
          cd.packet_shipment
        FROM 
          tbl_client_lp clp
        INNER JOIN tbl_logistics_partner lp ON clp.logictics_partner_id = lp.id
        LEFT JOIN tbl_courier_details cd ON lp.courier_id = cd.id
        WHERE clp.client_id = ? AND lp.aggrigator_type = 1
        ORDER BY lp.id DESC
      `, [selectedClientId]);

      // Get the first logistics partner id for this client (if any)
      const firstLp = await mySqlQury(
        `SELECT logictics_partner_id FROM tbl_client_lp WHERE client_id = ? ORDER BY id ASC LIMIT 1`,
        [selectedClientId]
      );
      if (firstLp && firstLp.length > 0) {
        firstLogisticsId = firstLp[0].logictics_partner_id;
      }
    }

   

    // Optionally log for debug
    console.log("aggrigator list", aggrigatorList);

    res.render('pages/aggrigator-list', {
      role_data: selectedClientId,
      accessdata,
      bodyClass: 'profile-page',
      activePage: 'profile',
      lang_data,
      language_name,
      // notification_data, // Uncomment if you want to use notification_data
      title: 'Aggregator List',
      layout: 'partials/layout-vertical',
     
      loginDetails: loginDetails || {},
      
      aggrigatorList,
      clientId,
      walletBalance,
      
      role,
      firstLogisticsId // Pass the first logistics partner id (for client)
    });

  } catch (error) {
    console.error('Error fetching data for aggregator list:', error);
    next(error);
  }
}
const getaggritorList = async (req, res, next) => {
  try {
    const accessdata = await access(req.user);
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;
    const lang_data = req.language_data;
    const language_name = req.lang;
    let walletBalance = 0;
    let vasService = 0;

    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = ? ORDER BY id DESC LIMIT 3`,
      [role_data.id]
    );

    let loginDetails = null;
    let clientId = 0;

    // Handle different roles
    if ((role === 2 || [3, 4, 5, 6, 7].includes(role)) && relatedClientId !== 1) {
      const loginDetailsResult = await mySqlQury(
        'SELECT id,first_name,company_name,vas,logo_path FROM tbl_admin WHERE login_id = ?',
        [relatedClientId]
      );

      if (loginDetailsResult && loginDetailsResult.length > 0) {
        loginDetails = loginDetailsResult[0];
        clientId = loginDetails.id;
        vasService = loginDetails.vas;
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [clientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;

    } else {
      // For role 1 or when relatedClientId is 1, get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [req.user.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;
    }

    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const aggrigatorList = await mySqlQury(`
      SELECT 
        a.id AS Aggrigator_id,
        a.binded_with_forwarder,
        a.service_type AS aggrigator_type,
        a.Aggrigator_company_name AS aggrigator_name, 
        a.Status AS status,
        a.logo_path,
        COUNT(DISTINCT ca.client_id) AS client_count,
        c.company_name,
        c.id AS client_id,
        c.logo_path AS client_logo_path,
        ca.recommended
      FROM 
        tbl_aggrigator a
      LEFT JOIN 
        tbl_aggrigator_servisibility s ON a.id = s.Aggrigator_id
      LEFT JOIN 
        tbl_client_aggrigator ca ON a.id = ca.Aggrigator_id
      LEFT JOIN 
        tbl_admin c ON ca.client_id = c.id
      GROUP BY 
        a.id, a.Status, a.binded_with_forwarder, a.service_type, 
        a.Aggrigator_company_name, a.logo_path, c.company_name, 
        c.id, c.logo_path, ca.recommended
    `);

    const clientList = await mySqlQury(`
      SELECT 
        id, 
        company_name 
      FROM 
        tbl_admin
    `);

    let activeTopicIds = [];
    if (activeTopics && Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    } else if (activeTopics && activeTopics.topic_id) {
      activeTopicIds = [Number(activeTopics.topic_id)];
    }
    // console.log("aggrigator list", aggrigatorList)


    res.render('pages/aggrigator-list', {
      role_data,
      accessdata,
      bodyClass: 'profile-page',
      activePage: 'profile',
      lang_data,
      language_name,
      notification_data,
      title: 'Aggregator List',
      layout: 'partials/layout-vertical',
      activeTopicIds,
      loginDetails: loginDetails || {},
      profile,
      aggrigatorList,
      clientList,
      clientId,
      walletBalance,
      vasService
    });

  } catch (error) {
    console.error('Error fetching data for aggregator list:', error);
    next(error);
  }
}
const getAggByClientId = async (req, res, next) => {
  try {
    const clientId = req.params.clientId;

    // Fetch the aggregators bound to the selected client, including client details
    const aggrigatorList = await mySqlQury(`
      SELECT 
        a.id AS Aggrigator_id, 
        a.Aggrigator_company_name AS aggrigator_name, 
        a.Status AS status,
        a.logo_path,
        COUNT(DISTINCT ca.client_id) AS client_count, -- Count unique clients bound to the aggregator
        c.company_name, -- Include client company name
        c.logo_path AS client_logo_path -- Include client logo path
      FROM 
        tbl_aggrigator a
      LEFT JOIN 
        tbl_aggrigator_servisibility s ON a.id = s.Aggrigator_id
      LEFT JOIN 
        tbl_client_aggrigator ca ON a.id = ca.Aggrigator_id
      LEFT JOIN 
        tbl_admin c ON ca.client_id = c.id -- Join to get client details
      WHERE 
        ca.client_id = ?
      GROUP BY 
        a.id, a.Status, c.company_name, c.logo_path
    `, [clientId]);

    // Fetch client details (optional, if you need to return client details)
    const clientDetails = await mySqlQury(`
      SELECT 
        id, 
        company_name, 
        logo_path 
      FROM 
        tbl_admin 
      WHERE 
        id = ?
    `, [clientId]);

    // Log the fetched aggregator details
    console.log("Aggregator Details by Client:", aggrigatorList);
    console.log("Client Details:", clientDetails);

    // Send the response as JSON
    res.json({
      title: 'Aggregators for Client',
      clientId,
      clientDetails: clientDetails[0], // Assuming you want to send the first client detail
      aggrigatorList // Send the updated aggregator list
    });
  } catch (error) {
    console.error('Error fetching aggregators by client:', error);
    next(error); // Pass error to middleware
  }
}
const postAggToggleRecommendation = async (req, res) => {
  try {
    const { aggregatorId, clientId, isRecommended } = req.body;

    // Start transaction
    await mySqlQury('START TRANSACTION');

    // If new recommendation is being set to 1, first reset all recommendations to 0 for this client
    if (isRecommended === 1) {
      await mySqlQury(
        'UPDATE tbl_client_aggrigator SET recommended = 0 WHERE client_id = ?',
        [clientId]
      );
    }

    // Update recommendation for specific aggregator
    const updateResult = await mySqlQury(
      'UPDATE tbl_client_aggrigator SET recommended = ? WHERE Aggrigator_id = ? AND client_id = ?',
      [isRecommended, aggregatorId, clientId]
    );

    // Commit transaction
    await mySqlQury('COMMIT');

    if (updateResult.affectedRows > 0) {
      res.status(200).json({
        success: true,
        message: 'Recommendation updated successfully'
      });
    } else {
      res.status(404).json({
        success: false,
        message: 'No matching record found to update'
      });
    }

  } catch (error) {
    // Rollback transaction on error
    await mySqlQury('ROLLBACK');

    console.error('Error updating recommendation:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update recommendation',
      error: error.message
    });
  }
}
const apiPackageExpressRateList = async (req, res) => {
  try {
    const courierId = req.params.courierId;
    console.log("courier id",req.params)
    // const courierId = 35;

    const [courierDetails] = await mySqlQury(
      `SELECT volumetric_factor FROM tbl_courier_details WHERE id = ?`,
      [courierId]
    );
    console.log("skdhsjkdhs",courierDetails)
    const volumetric_factor = courierDetails ? courierDetails.volumetric_factor : null;

    // 1. Get all weight slabs for this courier
    const slabs = await mySqlQury(`
      SELECT slab_id, min_weight, max_weight, unit
      FROM tbl_exp_weightslabs
      WHERE courier_id = ?
    `, [courierId]);

    const formattedSlabs = [];

    for (const slab of slabs) {
      const { slab_id: slabId, min_weight, max_weight, unit } = slab;

      // 2. Get zone rates for this weight slab
      const zoneRates = await mySqlQury(`
        SELECT zone_name, zone_value
        FROM tbl_exp_zones_rates
        WHERE courier_id = ? AND weight_slab_id = ?
      `, [courierId, slabId]);

      const zones = {};
      zoneRates.forEach(rate => {
        zones[rate.zone_name] = parseFloat(rate.zone_value);
      });

      // 3. Get slab additional charges
      const slabAdditionalChargesRaw = await mySqlQury(`
        SELECT charge_id, description, weight, unit
        FROM tbl_exp_slab_additional_charges
        WHERE courier_id = ? AND weight_slab_id = ?
      `, [courierId, slabId]);

      const slab_additional_charges = [];

      for (const charge of slabAdditionalChargesRaw) {
        const amountsRaw = await mySqlQury(`
          SELECT zone_name, amount
          FROM tbl_exp_slab_additionalamounts
          WHERE additional_charge_id = ?
        `, [charge.charge_id]);

        const amounts = {};
        amountsRaw.forEach(item => {
          amounts[item.zone_name] = parseFloat(item.amount);
        });

        slab_additional_charges.push({
          desc: charge.description,
          weight: charge.weight,
          unit: charge.unit,
          amounts
        });
      }

      // 4. Push formatted slab
      formattedSlabs.push({
        min_weight,
        max_weight,
        unit,
        zones,
        slab_additional_charges
      });
    }

    // 5. Get global express additional charges
    const expressAdditionalCharges = await mySqlQury(`
      SELECT charge_id, charge_name, calculation_based_on_min, calculation_based_on_max, min_value, max_value, condition_based, chargable_value_type
      FROM tbl_courier_exp_additional_charges
      WHERE courier_id = ?
    `, [courierId]);

    res.json({
      slabs: formattedSlabs,
      express_additional_charges: expressAdditionalCharges,
      volumetric_factor

    });

  } catch (error) {
    console.error('Error fetching express rate list:', error);
    res.status(500).json({ error: 'Failed to fetch express rate list' });
  }
}
const apiPackageEcomRateList = async (req, res) => {
  try {
    const courierId = req.params.courierId;
    console.log("courier id",req.params)
    // const courierId = 35;

    const [courierDetails] = await mySqlQury(
      `SELECT volumetric_factor FROM tbl_courier_details WHERE id = ?`,
      [courierId]
    );
    console.log("skdhsjkdhs",courierDetails)
    const volumetric_factor = courierDetails ? courierDetails.volumetric_factor : null;

    // 1. Get all weight slabs for this courier
    const slabs = await mySqlQury(`
      SELECT slab_id, min_weight, max_weight, unit
      FROM tbl_ecom_weightslabs
      WHERE courier_id = ?
    `, [courierId]);

    const formattedSlabs = [];

    for (const slab of slabs) {
      const { slab_id: slabId, min_weight, max_weight, unit } = slab;

      // 2. Get zone rates for this weight slab
      const zoneRates = await mySqlQury(`
        SELECT zone_name, zone_value
        FROM tbl_ecom_zones_rates
        WHERE courier_id = ? AND weight_slab_id = ?
      `, [courierId, slabId]);

      const zones = {};
      zoneRates.forEach(rate => {
        zones[rate.zone_name] = parseFloat(rate.zone_value);
      });

      // 3. Get slab additional charges
      const slabAdditionalChargesRaw = await mySqlQury(`
        SELECT charge_id, description, weight, unit
        FROM tbl_ecom_slab_additional_charges
        WHERE courier_id = ? AND weight_slab_id = ?
      `, [courierId, slabId]);

      const slab_additional_charges = [];

      for (const charge of slabAdditionalChargesRaw) {
        const amountsRaw = await mySqlQury(`
          SELECT zone_name, amount
          FROM tbl_ecom_slab_additionalamounts
          WHERE additional_charge_id = ?
        `, [charge.charge_id]);

        const amounts = {};
        amountsRaw.forEach(item => {
          amounts[item.zone_name] = parseFloat(item.amount);
        });

        slab_additional_charges.push({
          desc: charge.description,
          weight: charge.weight,
          unit: charge.unit,
          amounts
        });
      }

      // 4. Push formatted slab
      formattedSlabs.push({
        min_weight,
        max_weight,
        unit,
        zones,
        slab_additional_charges
      });
    }

    // 5. Get global express additional charges
    const expressAdditionalCharges = await mySqlQury(`
      SELECT charge_id, charge_name, calculation_based_on_min, calculation_based_on_max, min_value, max_value, condition_based, chargable_value_type
      FROM tbl_courier_ecom_additional_charges
      WHERE courier_id = ?
    `, [courierId]);

    res.json({
      slabs: formattedSlabs,
      express_additional_charges: expressAdditionalCharges,
      volumetric_factor

    });

  } catch (error) {
    console.error('Error fetching express rate list:', error);
    res.status(500).json({ error: 'Failed to fetch express rate list' });
  }
}

const postAggUpdateStatus = async (req, res) => {
  const { aggrigator_id } = req.body; // Only need aggrigator_id to toggle status
  console.log("Request body in aggregator update:", aggrigator_id);

  try {
    // Fetch the current status of the aggregator
    const currentStatusResult = await mySqlQury(`
      SELECT status 
      FROM tbl_aggrigator 
      WHERE id = ?
    `, [aggrigator_id]);

    if (currentStatusResult.length === 0) {
      return res.status(404).json({ success: false, message: 'Aggregator not found.' });
    }

    const currentStatus = currentStatusResult[0].status;
    const newStatus = currentStatus === 1 ? 0 : 1; // Toggle status

    // Update the status in the tbl_aggrigator table
    const queryAggrigator = 'UPDATE tbl_aggrigator SET status = ? WHERE id = ?';
    await mySqlQury(queryAggrigator, [newStatus, aggrigator_id]);

    // Check if the aggregator exists in the tbl_client_aggrigator table
    const checkAggrigatorExists = await mySqlQury(`
      SELECT COUNT(*) AS count 
      FROM tbl_client_aggrigator 
      WHERE Aggrigator_id = ?
    `, [aggrigator_id]);

    // If the aggregator exists in tbl_client_aggrigator, update its status
    if (checkAggrigatorExists[0].count > 0) {
      const queryClientAggrigator = 'UPDATE tbl_client_aggrigator SET status = ? WHERE Aggrigator_id = ?';
      await mySqlQury(queryClientAggrigator, [newStatus, aggrigator_id]);
    }

    // Send success response
    res.status(200).json({ success: true, message: 'Status updated successfully.', newStatus });
  } catch (error) {
    console.error('Error updating status:', error);
    res.status(500).json({ success: false, message: 'Failed to update status.' });
  }
}
const postAggUploadPincode = async (req, res) => {
  const { aggrigator_id } = req.body;
  const filePath = req.files[0].path;
  console.log("shabbar swwew", req.path)
  console.log("shabba checking upload csv file ", sdgsjdgsj, aggrigator_id)// Get uploaded file path

  try {
    // Step 1: Get Aggrigator_company_name and aggrigator_type from tbl_aggrigator
    const aggrigatorResult = await mySqlQury(
      'SELECT Aggrigator_company_name, aggrigator_type FROM tbl_aggrigator WHERE Aggrigator_id = ?',
      [aggrigator_id]
    );

    if (!aggrigatorResult.length) {
      return res.json({ success: false, message: 'Aggrigator not found.' });
    }

    const { Aggrigator_company_name, aggrigator_type } = aggrigatorResult[0];

    // Step 2: Dynamically create a new table based on Aggrigator_company_name and aggrigator_type
    const tableName = `tbl_aggrigator_serv_${aggrigator_id}`;

    await mySqlQury(`
      CREATE TABLE IF NOT EXISTS ${tableName} (
        id INT AUTO_INCREMENT PRIMARY KEY,
        pincode VARCHAR(10) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Step 3: Update servisibility_table in tbl_aggrigator
    await mySqlQury(
      'UPDATE tbl_aggrigator SET servisibility_table = ? WHERE Aggrigator_id = ?',
      [tableName, aggrigator_id]
    );

    // Step 4: Read CSV file and insert data into the new table
    const csvData = fs.readFileSync(filePath, 'utf8').split('\n');
    for (const line of csvData) {
      const pincode = line.trim();
      if (pincode) {
        await mySqlQury(`INSERT INTO ${tableName} (pincode) VALUES (?)`, [pincode]);
      }
    }

    // Step 5: Clean up uploaded file
    fs.unlinkSync(filePath);

    res.json({ success: true, message: 'Pincode CSV uploaded and table created successfully.' });
  } catch (error) {
    console.error(error);
    res.json({ success: false, message: 'Failed to upload and process CSV.' });
  }
}
const postWoocommereData = async (req, res) => {
  try {
    console.log('Webhook Received:', JSON.stringify(req.body, null, 2));

    const eventType = req.headers['x-wc-webhook-topic']; // Get webhook type from WooCommerce
    console.log('Event Type:', eventType);

    if (eventType === 'order.created' || eventType === 'order.updated') {
      console.log('New order created:', req.body);

      const finalResponse = req.body;

      const insertQuery = `INSERT INTO tbl_unprocessed_order (
        client_id,
        order_id, 
        po_no,
        Invoice_amount,
        destination_city,
        destination_state,
        destination_pincode,
        consignee_phone,
        consignee_name,
        origin_city,
        origin_state,
        origin_pincode,
        payment_type,
        quantity
      ) VALUES ? ON DUPLICATE KEY UPDATE po_no = po_no`;

      const values = [];

      for (let i = 0; i < finalResponse.length; i++) {
        const order = finalResponse[i];
        for (let j = 0; j < order.line_items.length; j++) {
          values.push([
            clientId,
            String(order.id),
            String(order.id),
            Number(order.total),
            order.billing.city,
            order.billing.state,
            order.billing.postcode,
            order.shipping.phone,
            `${order.shipping.first_name} ${order.shipping.last_name}`,
            order.shipping.city,
            order.shipping.state,
            order.shipping.postcode,
            order.payment_method,
            Number(order.line_items[j].quantity)
          ]);
        }
      }

      await mySqlQury(insertQuery, [values]);

      const query = `INSERT INTO tbl_woocommerce_integration 
        (client_id, store_url, store_consumer_key, store_consumer_secret)
        VALUES (?, ?, ?, ?)
        ON DUPLICATE KEY UPDATE
          client_id = VALUES(client_id),
          store_consumer_key = VALUES(store_consumer_key), 
          store_consumer_secret = VALUES(store_consumer_secret)`;

      const queryValue = await mySqlQury(query, [clientId, storeUrl, consumerKey, consumerSecret]);
      console.log(queryValue);
    }

    // Send a success response to WooCommerce
    res.status(200).json({ success: true, message: 'Webhook processed successfully' });

  } catch (error) {
    console.error('Error processing webhook:', error.message);
    res.status(500).json({ success: false, message: 'Error processing webhook' });
  }
}
const getLtl = async (req, res) => {
  try {
    // Get user info for permission and role-based data
    const role_data = req.user;
    const role = req.user?.role;
    const relatedClientId = req.user?.clientId;

    let loginDetails = null;
    let clientId = 0;
    let walletBalance = 0;
    let vasService = 0;

    // Fetch both count and the actual unprocessed orders with client info
    const countResult = await mySqlQury(`SELECT COUNT(*) as total FROM tbl_unprocessed_order WHERE is_unprocessesd = 1`);
    const unprocessedCount = countResult[0].total;

    // Fetch the actual data needed for the table in ltl.ejs
    const data = await mySqlQury(
      `SELECT o.*, c.company_name
       FROM tbl_unprocessed_order o
       LEFT JOIN tbl_admin c ON o.client_id = c.id
       WHERE o.is_unprocessesd = 1
       ORDER BY o.id DESC`
    );

    // Get active topics for the current user's role
    let activeTopicIds = [];
    if (req.user && req.user.role) {
      const activeTopics = await mySqlQury(
        'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
        [req.user.role]
      );
      if (Array.isArray(activeTopics)) {
        activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
      }
    }

    // Optionally, get profile info for the user (for header, etc.)
    let profile = {};
    if (req.user && req.user.id) {
      const [profileResult] = await mySqlQury(
        `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
        [req.user.id]
      );
      profile = profileResult || {};
    }

    res.render('pages/ltl', {
      title: 'app-ltl',
      bodyClass: 'profile-page',
      activePage: 'profile',
      unprocessedCount,
      data,
      activeTopicIds,
      profile,
      role_data
    });

  } catch (err) {
    console.error("LTL Error:", err);
    res.status(500).send("Something went wrong");
  }
}
const getExpress =  async (req, res) => {
  const { tenant, type } = req.query;
  const role = req.user.role;
  const clientId = req.user.selectedClientId;
  const role_data = req.user;

  // Fetch lightweight info for page load
  const loginDetails = await dashboardService.getLoginDetails(role, clientId, role_data);
  const profile = await dashboardService.getProfile(role_data.id);
  const walletBalance = await dashboardService.getWalletBalance(clientId || role_data.id);
  const activeTopicIds = await dashboardService.getActiveTopics(role);

  res.render('pages/order-summary', {
    title: 'Dashboard',
    loginDetails,
    tenant,
    type,
    profile,
    clientId,
    role,
    walletBalance,
    vasService: loginDetails?.vas || 1,
    activeTopicIds,
    courierType:'express'
  });
}
const getEcom =  async (req, res) => {
  const { tenant, type } = req.query;
  const role = req.user.role;
  const clientId = req.user.selectedClientId;
  const role_data = req.user;

  // Fetch lightweight info for page load
  const loginDetails = await dashboardService.getLoginDetails(role, clientId, role_data);
  const profile = await dashboardService.getProfile(role_data.id);
  const walletBalance = await dashboardService.getWalletBalance(clientId || role_data.id);
  const activeTopicIds = await dashboardService.getActiveTopics(role);

  res.render('pages/order-summary', {
    title: 'Dashboard',
    loginDetails,
    tenant,
    type,
    profile,
    clientId,
    role,
    walletBalance,
    vasService: loginDetails?.vas || 1,
    activeTopicIds,
    courierType:'ecom'
  });
}
const getSignup = (req, res) => {
  let message = req.query.message || null;
  res.render('pages/signup', {
    title: 'Sign Up',
    bodyClass: 'auth-page',
    activePage: 'signup',
    message: req.query.message || '',
    query: req.query // âœ… FIXED
  });
}
const postSignup = async (req, res) => {
  const { name, organization, email,phone, password, monthly_parcels=null, company_type,segment_type,business_volume=null} = req.body;
  console.log("req body",req.body)
  // console.log("dkfdkf",dksdksd)
    console.log(business_volume,monthly_parcels )

  try {
    // 1. Check if user already verified
    await mySqlQury('START TRANSACTION');
    const existingUser = await mySqlQury(`SELECT * FROM tbl_admin WHERE email = ?`, [email]);
    if (existingUser.length > 0) {
      return res.status(400).json({ message: "You already signed up. Please login.", status: 1 });
    }

    // 2. Check if user is pending verification
    const pendingUser = await mySqlQury(`SELECT * FROM users_pending WHERE email = ?`, [email]);
    if (pendingUser.length > 0) {
      return res.status(400).json({ message: "You already signed up. Please check your email to verify.", status: 2 });
    }

    // 3. Save new user to pending table
    const hashedPassword = await bcrypt.hash(password, 10);
    const token = uuid.v4();
    const monthlyParcelsValue = monthly_parcels ? monthly_parcels : 0;
    const expVolumeValue = business_volume ? business_volume : 0;
    const insertInto = await mySqlQury(`
      INSERT INTO users_pending
      (name, organization, email, password, monthly_parcels, company_type, business_volume, verify_token, phone_no, segment_type)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        name,
        organization,
        email,
        hashedPassword,
        monthlyParcelsValue,
        company_type,
        expVolumeValue,
        token,
        phone,
        segment_type
      ]
    );
    console.log("insert into",insertInto)

    // 4. Prepare verification email
    const verifyLink = `${process.env.BASE_URL}/verify/${token}`;
    const mailOptions = {
      from: `"CRM Support" <${process.env.EMAIL_FROM}>`,
      to: email,
      subject: "Activate Your Dispatch Solutions Account",
      html: `
        <div style="font-family:sans-serif;padding:20px;">
          <h2 style="color:#0d6efd;">Welcome to Dispatch CRM!</h2>
          <p>Please verify your email by clicking the button below:</p>
          <p><a href="${verifyLink}" style="padding:12px 24px;background:#0d6efd;color:#fff;text-decoration:none;border-radius:6px;">âœ… Verify My Email</a></p>
          <p>If the button doesn't work, copy this link:</p>
          <p>${verifyLink}</p>
        </div>
      `
    };

    // 5. Send email
    const transporter = nodemailer.createTransport({
      host: process.env.EMAIL_HOST,
      port: process.env.EMAIL_PORT,
      secure: true,
      auth: {
        user: process.env.EMAIL_FROM,
        pass: process.env.EMAIL_PASS
      }
    });

    transporter.sendMail(mailOptions, (error, info) => {
      if (error) {
        console.error("Email failed:", error);
        return res.status(200).json({ message: "Signup saved, but email could not be sent." });
      }
      return res.status(200).json({ message: "Signup successful. Check your email to verify." });
    });
    await mySqlQury('COMMIT');

  } catch (err) {
    console.error("Signup error:", err);
    await mySqlQury('ROLLBACK');
    return res.status(500).json({ message: "Something went wrong." });
  }
}
const getVerifyToken = async (req, res) => {
  const token = req.params.token;
  try {
    await mySqlQury('START TRANSACTION');

    const pendingUser = await mySqlQury(
      `SELECT * FROM users_pending WHERE verify_token = ? FOR UPDATE`,
      [token]
    );

    if (pendingUser.length === 0) {
      await mySqlQury('ROLLBACK');
      return res
        .status(400)
        .send(`<h2>âŒ Invalid or expired token.</h2><a href="/signup">Try Again</a>`);
    }

    const {
      name,
      email,
      password,
      phone_no,
      monthly_parcels = 0,
      business_volume = 0,
      company_type = null,
      segment_type = null,
      organization = null
    } = pendingUser[0];
console.log("pending user",pendingUser)
// console.log("dsdhsjdhsjdh",dsjdsjd)
    // âœ… Check for existing email or phone in tbl_admin
    const existingUser = await mySqlQury(
      `SELECT id FROM tbl_admin WHERE email = ? OR phone_no = ? LIMIT 1`,
      [email, phone_no]
    );

    if (existingUser.length > 0) {
      await mySqlQury('ROLLBACK');
      return res
        .status(400)
        .send(`<h2>âš ï¸ Email or phone already exists.</h2><a href="/signup">Try Again</a>`);
    }
        const [roleRow] = await mySqlQury(
          `SELECT id FROM roles WHERE client_id = 1 AND name = 'client' LIMIT 1`);
        const role_id = roleRow?.id;
    // Step 1: Insert into tbl_admin
    const adminInsert = await mySqlQury(
      `INSERT INTO tbl_admin (first_name, email, password, phone_no, organization, company_name, is_verified, is_active, level, parent_id, role_id)
       VALUES (?, ?, ?, ?, ?, ?, 1, 1, 2, 1, ?)`,
      [name, email, password, phone_no, organization, organization, role_id]
    );

    const insertedUserId = adminInsert.insertId;

    // Step 2: Insert into kyc_submissions
    await mySqlQury(
      `INSERT INTO kyc_submissions (user_id, organization, monthly_parcels, business_volume, company_type, segment_type)
       VALUES (?, ?, ?, ?, ?, ?)`,
      [
        insertedUserId,  
        organization,
        monthly_parcels,
        business_volume,
        company_type,
        segment_type
      ]
    );

    // Step 3: Remove from pending
    await mySqlQury(`DELETE FROM users_pending WHERE email = ?`, [email]);

    await mySqlQury('COMMIT');

    return res.send(`
      <html><head><title>Verifying...</title></head>
      <body style="font-family:sans-serif;text-align:center;margin-top:100px;">
        <h3>âœ… Email Verified</h3>
        <p>This window will close. Please return to the signup page.</p>
        <script>setTimeout(() => window.close(), 2000);</script>
      </body></html>
    `);
  } catch (err) {
    console.error("Verification error:", err);
    await mySqlQury('ROLLBACK');
    res.status(500).send(`Server Error`);
  }
};
const postCheckVerificationStatus = async (req, res) => {
  const email = req.query.email;
  if (!email) return res.json({ verified: false });

  try {
    const result = await mySqlQury(`SELECT is_verified FROM tbl_admin WHERE email = ?`, [email]);
    const isVerified = result[0]?.is_verified === 1;
    res.json({ verified: isVerified });
  } catch (err) {
    console.error("Status check failed:", err);
    res.status(500).json({ verified: false });
  }
}
const postResendVerification = async (req, res) => {
  const { email } = req.body;

  if (!email) {
    return res.status(400).json({ message: "Email is required." });
  }

  try {
    // 1. Check if user exists in users_pending
    const pending = await mySqlQury(`SELECT * FROM users_pending WHERE email = ?`, [email]);
    if (pending.length === 0) {
      return res.status(400).json({ message: "No pending verification found for this email." });
    }

    const newToken = uuid.v4();

    // 2. Update new token in DB
    await mySqlQury(`UPDATE users_pending SET verify_token = ? WHERE email = ?`, [newToken, email]);

    // 3. Prepare verification link
    const verifyLink = `${process.env.BASE_URL}/verify/${newToken}`;

    // 4. Send email
    const mailOptions = {
      from: `"CRM Support" <${process.env.EMAIL_FROM}>`,
      to: email,
      subject: "Resend: Activate Your Dispatch Solutions Account",
      html: `
        <h2>Welcome To Dispatch Email Verification !</h2>
        <p>Click below to verify your email:</p>
        <a href="${verifyLink}" style="padding:10px 20px;background:#0d6efd;color:#fff;text-decoration:none;border-radius:5px;">Verify Email</a>
      `
    };

    const transporter = nodemailer.createTransport({
      host: process.env.EMAIL_HOST,
      port: process.env.EMAIL_PORT,
      secure: true,
      auth: {
        user: process.env.EMAIL_FROM,
        pass: process.env.EMAIL_PASS
      }
    });

    await transporter.sendMail(mailOptions);

    return res.status(200).json({ message: "Verification email resent successfully." });
  } catch (err) {
    console.error("Resend verification error:", err);
    return res.status(500).json({ message: "Failed to resend email. Try again." });
  }
}

 
const getLtlCreateOrder = (req, res) => {
  res.render('pages/ltl/create-order', {
    title: 'Create New B2B Order',
    bodyClass: 'profile-page',
    activePage: 'create-orderb2b'
  });
}
const getExpressCreateOrder = async (req, res, next) => {
  try {
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;

    let loginDetails = null;
    let clientId = 0;
    let walletBalance = 0;
    let vasService = 0;
    console.log("req user", req.user);
    let warehouseData = null;
    let productsData = null;

    // Get login details based on selectedClientId
    if (selectedClientId === 1) {
      // For admin (selectedClientId = 1), get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [selectedClientId ]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;

      // Fetch all warehouse data for admin
      warehouseData = await mySqlQury('SELECT serial,warehouse_name FROM tbl_add_warehouse');
      productsData = await mySqlQury('SELECT category,name,price,sku FROM client_products');
    } else {
      // For specific client, use selectedClientId directly
      loginDetails = {
        id: selectedClientId,
        first_name: 'Client',
        company_name: 'Client Company',
        logo_path: null,
        vas: 1
      };
      clientId = selectedClientId;
      vasService = 1;
      
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [selectedClientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      console.log("login details", selectedClientId, loginDetails);

      // Fetch warehouse data for this specific client
      warehouseData = await mySqlQury(
        'SELECT serial,warehouse_name FROM tbl_add_warehouse WHERE client_id = ?',
        [selectedClientId]
      );
      productsData = await mySqlQury(
        'SELECT category,name,price,sku FROM client_products WHERE client_id = ?',
        [selectedClientId]
      );
    }

    const lang_data = req.language_data;
    const language_name = req.lang;
    const clients = await mySqlQury(`SELECT id, company_name FROM tbl_admin`);

    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = '${role_data.id}' ORDER BY id DESC LIMIT 3`
    );

    // Get active topics
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const commodities = await mySqlQury(`SELECT COMMODITY_NAME FROM commodities`);
    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Extract active topic IDs
    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    }
    console.log("client id in express create order", clientId);
    console.log("product data",productsData)
    console.log("warehosue data",warehouseData)

    // Render the express/create-order template and pass all the data
    res.render('pages/express/create-order', {
      title: 'Create New B2B Order',
      bodyClass: 'profile-page',
      activePage: 'create-orderb2b',
      role_data: role_data,
      lang_data: lang_data,
      language_name: language_name,
      notification_data: notification_data,
      clients,
      commodities,
      activeTopicIds,
      loginDetails,
      profile,
      clientId,
      walletBalance,
      vasService,
      warehouseData, // Pass warehouse data to the template
      productsData,
      role
    });

  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  }
}
const postapiClientOrder = async (req, res,next) => {
  const { name, sku, category, price } = req.body;
  if (!name || !sku || !category || !price) {
    return res.json({ success: false, message: 'Missing fields' });
  }
  console.log("djkshds",req.user.selectedClientId)
  console.log("rew",req.user)
  try {
    // Insert the new product
    const addProduct = await mySqlQury('INSERT INTO client_products (name, sku, category, price,client_id) VALUES (?, ?, ?, ?,?)', [name, sku, category, price,req.user.selectedClientId]);
    // Get all products
    const [product] = await mySqlQury(
      'SELECT category, name, price, sku FROM client_products WHERE id = ?',
      [addProduct.insertId]
    );
    
    res.json({ success: true, product });
  } catch (err) {
    console.error(err);
    res.json({ success: false, message: 'Database error' });
  }
}
const   createOrderEcom = async (req, res) => {
  // console.log("pickupseial", req.body.warehouseID)
  // console.log("req body client id",req.user.clientOnboardedID)
  // console.log("saljdkshd",djshdjsgdj)
 
  const validation = validateExpressCreateOrderData(req.body);
  if (!validation.valid) {
    return res.status(400).json({ success: false, message: validation.message });
  }
  if (!req.body.channel || req.body.channel.trim() === "") {
     return res.status(400).json({ success: false, message: "Please select channel." });
  }
 
  // console.log("dskjdksd",sdsd)
  

  const {
    orderID,
    refid,
    invoiceNumber,
    paymentMode,
    collectableAmount,
    consigneeDetails,
    
    boxes,
    total_Weight,
    productsDetails,
    grandTotal,
    totalQty,
    totalTax,
    totalDiscount,
      warehouseID,
    channel
  } = req.body;
 let clientid = req.user.selectedClientId
 if(clientid==1){
  const [warehosueDetails] = await mySqlQury(`SELECT client_id from tbl_add_warehouse WHERE serial =?`,[req.body.warehouseID])
  clientid = warehosueDetails.client_id
 }
 console.log("real client id is ",clientid)
 const totalBox = boxes.length
//  console.log("dskdjksdjs",sdjkdhjsdhs)
//  console.log("total boxes",totalBox)


  try {
    // ðŸ”„ Start transaction
    await mySqlQury('START TRANSACTION');

   
    

    // âœ… 1. Insert into tbl_exp_orders
    const orderInsertQuery = `
      INSERT INTO tbl_ecom_orders 
        (channel,ref_number, orderid, payment_mode, collectable_amount, warehouse_id, total_weight, grand_total, total_qty, total_tax, total_discount, is_unprocessed,client_id,box_qty,invoice_no)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?,?,?)
    `;
    const orderParams = [
      channel,
      refid,
      orderID,
      paymentMode,
      collectableAmount,
      warehouseID,
      total_Weight,
      grandTotal,
      totalQty,
      totalTax,
      totalDiscount,
      1,
      clientid,
      totalBox,
      invoiceNumber

    ];
    const orderResult = await mySqlQury(orderInsertQuery, orderParams);
    const orderId = orderResult.insertId;

    // âœ… 2. Prepare billingDetails logic
    let billingDetails = {};

    if (consigneeDetails.billingSameAsShipping) {
      billingDetails = {
        billing_first_name: consigneeDetails.firstName,
        billing_last_name: consigneeDetails.lastName,
        billing_email: consigneeDetails.email,
        billing_phone: consigneeDetails.phone,
        billing_alternate_phone: consigneeDetails.alternatePhone,
        billing_address_line1: consigneeDetails.addressLine1,
        billing_address_line2: consigneeDetails.addressLine2,
        billing_landmark: consigneeDetails.landmark,
        billing_country: consigneeDetails.country,
        billing_state: consigneeDetails.state,
        billing_city: consigneeDetails.city,
        billing_pincode: consigneeDetails.pincode
      };
    } else {
      billingDetails = {
        billing_first_name: billingFromClient?.billing_first_name || '',
        billing_last_name: billingFromClient?.billing_last_name || '',
        billing_email: billingFromClient?.billing_email || '',
        billing_phone: billingFromClient?.billing_phone || '',
        billing_alternate_phone: billingFromClient?.billing_alternate_phone || '',
        billing_address_line1: billingFromClient?.billing_address_line1 || '',
        billing_address_line2: billingFromClient?.billing_address_line2 || '',
        billing_landmark: billingFromClient?.billing_landmark || '',
        billing_country: billingFromClient?.billing_country || '',
        billing_state: billingFromClient?.billing_state || '',
        billing_city: billingFromClient?.billing_city || '',
        billing_pincode: billingFromClient?.billing_pincode || ''
      };
    }

    // âœ… 3. Insert into tbl_ecom_consignee_details
    const consigneeInsertQuery = `
      INSERT INTO tbl_ecom_consignee_details 
        (
          order_id,
          first_name, last_name, email, phone, alternate_phone,
          address_line1, address_line2, landmark, country, state, city, pincode,
          billing_same_as_shipping,
          billing_first_name, billing_last_name, billing_email, billing_phone, billing_alternate_phone,
          billing_address_line1, billing_address_line2, billing_landmark, billing_country, billing_state, billing_city, billing_pincode
        )
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;

    const consigneeParams = [
      orderId,
      consigneeDetails.firstName,
      consigneeDetails.lastName,
      consigneeDetails.email,
      consigneeDetails.phone,
      consigneeDetails.alternatePhone,
      consigneeDetails.addressLine1,
      consigneeDetails.addressLine2,
      consigneeDetails.landmark,
      consigneeDetails.country,
      consigneeDetails.state,
      consigneeDetails.city,
      consigneeDetails.pincode,
      consigneeDetails.billingSameAsShipping ? 1 : 0,

      billingDetails.billing_first_name,
      billingDetails.billing_last_name,
      billingDetails.billing_email,
      billingDetails.billing_phone,
      billingDetails.billing_alternate_phone,
      billingDetails.billing_address_line1,
      billingDetails.billing_address_line2,
      billingDetails.billing_landmark,
      billingDetails.billing_country,
      billingDetails.billing_state,
      billingDetails.billing_city,
      billingDetails.billing_pincode
    ];
    await mySqlQury(consigneeInsertQuery, consigneeParams);

    // âœ… 3. Insert boxes
    for (const box of boxes) {
      const boxInsertQuery = `
        INSERT INTO tbl_ecom_boxes_details 
          (order_id, package_type, length, breadth, height, dimension_unit, weight, weight_unit)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `;
      const boxParams = [
        orderId,
        box.packageType,
        box.length,
        box.breadth,
        box.height,
        box.dimensionUnit,
        box.weight,
        box.weightUnit
      ];
      await mySqlQury(boxInsertQuery, boxParams);
    }

    // âœ… 4. Insert products
    for (const product of productsDetails) {
      const productInsertQuery = `
        INSERT INTO tbl_ecom_product_details 
          (order_id, category, name, price, sku, quantity, discount_value, discount_type, tax_type)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `;
      const productParams = [
        orderId,
        product.category,
        product.name,
        product.price,
        product.sku,
        product.quantity,
        product.discountValue || 0,
        product.discountType || 'Flat',
        product.taxType || 'None'
      ];
      await mySqlQury(productInsertQuery, productParams);
    }

    // âœ… Commit transaction
    await mySqlQury('COMMIT');

    res.json({ success: true, message: 'Order created successfully!', orderId });

  } catch (error) {
    // âŒ Rollback on error
    await mySqlQury('ROLLBACK');
    console.error('Order creation error:', error);
    res.status(500).json({ success: false, message: 'Failed to create order', error: error.message });
  }
}


const createOrderEcomBulk= async (req, res, next) => {
  console.log("req body", req.body);
  console.log("req files", req.files);

  const selectedId = req.user.selectedClientId;
  const warehouseId = req.body.choosenWarehouse;
  let clientid = selectedId;

  if (selectedId == 1) {
    const [warehosueDetails] = await mySqlQury(
      `SELECT client_id FROM tbl_add_warehouse WHERE serial = ?`,
      [warehouseId]
    );
    clientid = warehosueDetails?.client_id || selectedId;
  }
  console.log("real client id is ", clientid);

  // file presence
  if (!req.files || req.files.length === 0) {
    return res.status(400).json({ success: false, message: 'Please upload an Excel file' });
  }

  const excelFile = req.files[0];

  console.log("Excel file details:", {
    fieldname: excelFile.fieldname,
    originalname: excelFile.originalname,
    encoding: excelFile.encoding,
    mimetype: excelFile.mimetype,
    size: excelFile.size,
    buffer: excelFile.buffer ? 'Buffer exists' : 'No buffer',
    path: excelFile.path || 'No path'
  });

  // type check
  if (!excelFile.originalname.endsWith('.xlsx') && !excelFile.originalname.endsWith('.xls')) {
    return res.status(400).json({ success: false, message: 'Please upload a valid Excel file (.xlsx or .xls)' });
  }

  try {
    const XLSX = require('xlsx');

    let workbook;
    if (excelFile.buffer) {
      console.log("Reading from buffer...");
      workbook = XLSX.read(excelFile.buffer, { type: 'buffer' });
    } else if (excelFile.path) {
      console.log("Reading from file path...");
      workbook = XLSX.readFile(excelFile.path);
    } else {
      throw new Error('No file buffer or path available');
    }

    const sheetName = workbook.SheetNames[0];
    console.log("Sheet names:", workbook.SheetNames);
    console.log("Selected sheet:", sheetName);

    const worksheet = workbook.Sheets[sheetName];
    if (!worksheet) {
      throw new Error(`Worksheet '${sheetName}' not found. Available sheets: ${workbook.SheetNames.join(', ')}`);
    }

    const orders = XLSX.utils.sheet_to_json(worksheet);
    console.log("Parsed orders from Excel:", orders);
    console.log("Orders length:", orders ? orders.length : 'undefined');
    console.log("Orders type:", Array.isArray(orders) ? 'Array' : typeof orders);

    if (!orders || !Array.isArray(orders) || orders.length === 0) {
      return res.status(400).json({ success: false, message: 'No valid orders found in the Excel file' });
    }

    // Express: no channel validation
    const results = [];
    let successCount = 0;
    let errorCount = 0;
    let skippedCount = 0;
    let validationErrorCount = 0;

    for (let i = 0; i < orders.length; i++) {
      const order = orders[i];
      const orderIndex = i + 1;

      try {
        // Validate row
        const validationResult = validateExpressBulkOrderData(order, orderIndex);
        if (!validationResult.valid) {
          validationErrorCount++;
          results.push({
            orderIndex,
            orderId: getAny(order, 'orderID', 'orderid', 'Order ID') || 'N/A',
            status: 'validation_error',
            message: validationResult.message,
            errors: validationResult.errors
          });
          continue;
        }

        const orderId = getAny(order, 'orderID', 'orderid', 'Order ID') || '';
        if (!orderId) {
          results.push({
            orderIndex,
            status: 'error',
            message: 'Order ID is missing'
          });
          errorCount++;
          continue;
        }

        // duplicate check
        const [existingOrder] = await mySqlQury(
          'SELECT id FROM tbl_ecom_orders WHERE orderid = ? AND client_id = ?',
          [orderId, clientid]
        );

        if (existingOrder) {
          results.push({
            orderIndex,
            orderId,
            status: 'skipped',
            message: 'Order already exists in database'
          });
          skippedCount++;
          continue;
        }

        // transaction
        await mySqlQury('START TRANSACTION');

        // ----- 1) tbl_exp_orders -----
        const orderInsertQuery = `
          INSERT INTO tbl_ecom_orders
            (ref_number, orderid, payment_mode, collectable_amount, warehouse_id, total_weight, grand_total, total_qty, total_tax, total_discount, is_unprocessed, client_id, box_qty, invoice_no)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `;
        const orderParams = [
          getAny(order, 'refid', 'ref_number', 'Ref ID', 'Ref Number') || '',
          orderId,
          (getAny(order, 'paymentMode', 'payment_mode', 'Payment Mode') || 'COD').toLowerCase(),
          getAny(order, 'collectableAmount', 'collectable_amount', 'Collectable Amount') || 0,
          warehouseId,
          getAny(order, 'total_Weight', 'totalWeight', 'total_weight', 'Total Weight') || 0,
          getAny(order, 'grandTotal', 'grand_total', 'Grand Total') || 0,
          getAny(order, 'totalQty', 'total_qty', 'Total Qty', 'Total Quantity') || 0,
          getAny(order, 'totalTax', 'total_tax', 'Total Tax') || 0,
          getAny(order, 'totalDiscount', 'total_discount', 'Total Discount') || 0,
          1, // is_unprocessed
          clientid,
          0, // will update with box count
          getAny(order, 'invoiceNumber', 'invoice_no', 'Invoice Number', 'Invoice No') || ''
        ];
        const orderResult = await mySqlQury(orderInsertQuery, orderParams);
        const newOrderId = orderResult.insertId;

        // ----- 2) Consignee (shipping + billing) -----
        const billingSameAsShipping =
          order.billingSameAsShipping !== undefined
            ? order.billingSameAsShipping
            : (order.billing_same_as_shipping !== undefined ? order.billing_same_as_shipping : true);

        const billingDetails = billingSameAsShipping
          ? {
              billing_first_name: getAny(order, 'billing_first_name', 'Billing First Name', 'firstName', 'First Name') || '',
              billing_last_name: getAny(order, 'billing_last_name', 'Billing Last Name', 'lastName', 'Last Name') || '',
              billing_email: getAny(order, 'billing_email', 'Billing Email', 'email') || '',
              billing_phone: getAny(order, 'billing_phone', 'Billing Phone', 'phone') || '',
              billing_alternate_phone: getAny(order, 'billing_alternate_phone', 'Billing Alternate Phone', 'alternatePhone', 'Alternate Phone') || '',
              billing_address_line1: getAny(order, 'billing_address_line1', 'Billing Address Line1', 'addressLine1', 'Address Line1') || '',
              billing_address_line2: getAny(order, 'billing_address_line2', 'Billing Address Line2', 'addressLine2', 'Address Line2') || '',
              billing_landmark: getAny(order, 'billing_landmark', 'Billing Landmark', 'landmark') || '',
              billing_country: getAny(order, 'billing_country', 'Billing Country', 'country') || '',
              billing_state: getAny(order, 'billing_state', 'Billing State', 'state') || '',
              billing_city: getAny(order, 'billing_city', 'Billing City', 'city') || '',
              billing_pincode: getAny(order, 'billing_pincode', 'Billing Pincode', 'pincode') || ''
            }
          : {
              billing_first_name: getAny(order, 'billing_first_name', 'Billing First Name') || '',
              billing_last_name: getAny(order, 'billing_last_name', 'Billing Last Name') || '',
              billing_email: getAny(order, 'billing_email', 'Billing Email') || '',
              billing_phone: getAny(order, 'billing_phone', 'Billing Phone') || '',
              billing_alternate_phone: getAny(order, 'billing_alternate_phone', 'Billing Alternate Phone') || '',
              billing_address_line1: getAny(order, 'billing_address_line1', 'Billing Address Line1') || '',
              billing_address_line2: getAny(order, 'billing_address_line2', 'Billing Address Line2') || '',
              billing_landmark: getAny(order, 'billing_landmark', 'Billing Landmark') || '',
              billing_country: getAny(order, 'billing_country', 'Billing Country') || '',
              billing_state: getAny(order, 'billing_state', 'Billing State') || '',
              billing_city: getAny(order, 'billing_city', 'Billing City') || '',
              billing_pincode: getAny(order, 'billing_pincode', 'Billing Pincode') || ''
            };

        const consigneeInsertQuery = `
          INSERT INTO tbl_ecom_consignee_details
            (
              order_id,
              first_name, last_name, email, phone, alternate_phone,
              address_line1, address_line2, landmark, country, state, city, pincode,
              billing_same_as_shipping,
              billing_first_name, billing_last_name, billing_email, billing_phone, billing_alternate_phone,
              billing_address_line1, billing_address_line2, billing_landmark, billing_country, billing_state, billing_city, billing_pincode
            )
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `;
        const consigneeParams = [
          newOrderId,
          getAny(order, 'firstName', 'First Name', 'first_name') || '',
          getAny(order, 'lastName', 'Last Name', 'last_name') || '',
          getAny(order, 'email', 'Email') || '',
          getAny(order, 'phone', 'Phone') || '',
          getAny(order, 'alternatePhone', 'Alternate Phone', 'alternate_phone') || '',
          getAny(order, 'addressLine1', 'Address Line1', 'Address Line 1', 'address_line1') || '',
          getAny(order, 'addressLine2', 'Address Line2', 'Address Line 2', 'address_line2') || '',
          getAny(order, 'landmark', 'Landmark') || '',
          getAny(order, 'country', 'Country') || '',
          getAny(order, 'state', 'State') || '',
          getAny(order, 'city', 'City') || '',
          getAny(order, 'pincode', 'Pincode', 'PIN Code', 'Pin') || '',
          billingSameAsShipping ? 1 : 0,

          billingDetails.billing_first_name,
          billingDetails.billing_last_name,
          billingDetails.billing_email,
          billingDetails.billing_phone,
          billingDetails.billing_alternate_phone,
          billingDetails.billing_address_line1,
          billingDetails.billing_address_line2,
          billingDetails.billing_landmark,
          billingDetails.billing_country,
          billingDetails.billing_state,
          billingDetails.billing_city,
          billingDetails.billing_pincode
        ];
        await mySqlQury(consigneeInsertQuery, consigneeParams);

        // ----- 3) Boxes (dynamic) -----
        let boxCount = 0;
        const dynamicBoxes = extractBoxesFromRow(order);
        if (dynamicBoxes.length > 0) {
          const insertBoxSql = `
            INSERT INTO tbl_ecom_boxes_details
              (order_id, package_type, length, breadth, height, dimension_unit, weight, weight_unit)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
          `;
          for (const b of dynamicBoxes) {
            await mySqlQury(insertBoxSql, [
              newOrderId,
              b.package_type || 'BOX',
              b.length,
              b.breadth,
              b.height,
              b.dimension_unit || 'cm',
              b.weight,
              b.weight_unit || 'kg'
            ]);
            boxCount++;
          }
        }
        if (boxCount > 0) {
          await mySqlQury('UPDATE tbl_ecom_orders SET box_qty = ? WHERE id = ?', [boxCount, newOrderId]);
        }

        // ----- 4) Product (optional) -----
        if (getAny(order, 'name', 'Product Name', 'productName', 'product_name')) {
          const productInsertQuery = `
            INSERT INTO tbl_ecom_product_details
              (order_id, category, name, price, sku, quantity, discount_value, discount_type, tax_type)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
          `;
          const productParams = [
            newOrderId,
            getAny(order, 'category', 'category', 'Product Category', 'productCategory') || '',
            getAny(order, 'name', 'Product Name', 'productName', 'product_name') || '',
            getAny(order, 'price', 'Product Price', 'productPrice') || 0,
            getAny(order, 'sku', 'Product SKU', 'productSku') || '',
            getAny(order, 'quantity', 'Product Quantity', 'productQuantity', 'totalQty', 'total_qty') || 1,
            getAny(order, 'discountValue', 'Discount Value', 'discount_value') || 0,
            getAny(order, 'discountType', 'Discount Type', 'discount_type') || 'Flat',
            getAny(order, 'taxType', 'Tax Type', 'tax_type') || 'None'
          ];
          await mySqlQury(productInsertQuery, productParams);
        }

        // commit
        await mySqlQury('COMMIT');

        successCount++;
        results.push({
          orderIndex,
          orderId,
          newOrderId,
          status: 'success',
          message: 'Order created successfully'
        });
      } catch (orderError) {
        await mySqlQury('ROLLBACK');
        errorCount++;
        results.push({
          orderIndex,
          status: 'error',
          message: orderError.message
        });
        console.error(`Error creating order ${orderIndex}:`, orderError);
      }
    }

    console.log("summary", successCount, skippedCount, errorCount);

    return res.json({
      success: true,
      message: `Bulk order processing completed. Success: ${successCount}, Skipped: ${skippedCount}, Errors: ${errorCount}`,
      summary: {
        totalOrders: orders.length,
        successCount,
        skippedCount,
        errorCount
      },
      results
    });

  } catch (error) {
    console.error('Bulk order creation error:', error);
    return res.status(500).json({
      success: false,
      message: 'Failed to process Excel file',
      error: error.message
    });
  }
};
// Validation function for express bulk orders (no channel required)
const validateExpressBulkOrderData = (order, orderIndex) => {
  const errors = [];
  let isValid = true;

  // Required fields (flexible headers)
  const required = [
    { name: 'Order ID', value: getAny(order, 'orderID', 'orderId', 'orderid', 'Order ID') },
    { name: 'First Name', value: getAny(order, 'firstName', 'First Name', 'first_name') },
    { name: 'Phone', value: getAny(order, 'phone', 'Phone') },
    { name: 'Address Line 1', value: getAny(order, 'addressLine1', 'Address Line1', 'Address Line 1', 'address_line1') },
    { name: 'City', value: getAny(order, 'city', 'City') },
    { name: 'State', value: getAny(order, 'state', 'State') },
    { name: 'Pincode', value: getAny(order, 'pincode', 'Pin', 'Pincode', 'PIN Code') },
    { name: 'Total Weight', value: getAny(order, 'total_Weight', 'totalWeight', 'total_weight', 'Total Weight') },
    { name: 'Grand Total', value: getAny(order, 'grandTotal', 'grand_total', 'Grand Total') },
  ];

  for (const r of required) {
    if (r.value === undefined || String(r.value).trim() === '') {
      errors.push(`${r.name} is required`);
      isValid = false;
    }
  }

  // Email (if present)
  const email = getAny(order, 'email', 'Email');
  if (email !== undefined && String(email).trim() !== '') {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(String(email))) {
      errors.push('Invalid email format');
      isValid = false;
    }
  }

  // Phone (if present)
  const phone = getAny(order, 'phone', 'Phone');
  if (phone !== undefined) {
    const phoneRegex = /^[0-9+\-\s()]{10,}$/;
    if (!phoneRegex.test(String(phone))) {
      errors.push('Phone number must be at least 10 digits');
      isValid = false;
    }
  }

  // Numeric validations (>= 0)
  const totalWeight = getAny(order, 'total_Weight', 'totalWeight', 'total_weight', 'Total Weight');
  if (totalWeight !== undefined && !isPosNum(totalWeight)) {
    errors.push('Total Weight must be a valid positive number');
    isValid = false;
  }

  const grandTotal = getAny(order, 'grandTotal', 'grand_total', 'Grand Total');
  if (grandTotal !== undefined && !isPosNum(grandTotal)) {
    errors.push('Grand Total must be a valid positive number');
    isValid = false;
  }

  const totalQty = getAny(order, 'totalQty', 'total_qty', 'Total Qty', 'Total Quantity');
  if (totalQty !== undefined && !isPosNum(totalQty)) {
    errors.push('Total Quantity must be a valid positive number');
    isValid = false;
  }

  // Dynamic box validation (soft-only; insertion will skip invalid ones)
  let softNotes = [];
  try {
    const hasAnyBoxKey = Object.keys(order).some(k => /box\s*\d+/i.test(String(k)));
    if (hasAnyBoxKey) {
      const parsed = extractBoxesFromRow(order); // already filters >0 fields
      // We can estimate how many box indices were present:
      const indices = new Set();
      for (const k of Object.keys(order)) {
        const m = String(k).match(/box\s*(\d+)/i);
        if (m && m[1]) indices.add(Number(m[1]));
      }
      const candidateCount = indices.size;
      const skippedCount = Math.max(candidateCount - parsed.length, 0);
      if (skippedCount > 0) {
        softNotes.push(`Note: ${skippedCount} box(es) had zero/invalid dimensions or weight and will be ignored.`);
      }
    }
  } catch {
    // non-blocking
  }

  let message = isValid ? 'Valid' : `Row ${orderIndex}: ${errors.join(', ')}`;
  if (!isValid) {
    if (errors.some(e => e.includes('required'))) {
      message += '\nðŸ’¡ Tip: Make sure all required fields are filled in your Excel sheet.';
    }
    if (errors.some(e => e.includes('Invalid email'))) {
      message += '\nðŸ’¡ Tip: Email should be in format: user@domain.com';
    }
    if (errors.some(e => e.includes('Phone number must be at least 10 digits'))) {
      message += '\nðŸ’¡ Tip: Phone number should have at least 10 digits';
    }
    if (errors.some(e => e.includes('must be a valid positive number'))) {
      message += '\nðŸ’¡ Tip: Numeric fields should contain only positive numbers';
    }
  } else if (softNotes.length) {
    message = `Row ${orderIndex}: Valid. ${softNotes.join(' ')}`;
  }

  return { valid: isValid, message, errors };
};



const createOrderExpressBulk = async (req, res, next) => {
  console.log("req body", req.body);
  console.log("req files", req.files);

  const selectedId = req.user.selectedClientId;
  const warehouseId = req.body.choosenWarehouse;
  let clientid = selectedId;

  if (selectedId == 1) {
    const [warehosueDetails] = await mySqlQury(
      `SELECT client_id FROM tbl_add_warehouse WHERE serial = ?`,
      [warehouseId]
    );
    clientid = warehosueDetails?.client_id || selectedId;
  }
  console.log("real client id is ", clientid);

  // file presence
  if (!req.files || req.files.length === 0) {
    return res.status(400).json({ success: false, message: 'Please upload an Excel file' });
  }

  const excelFile = req.files[0];

  console.log("Excel file details:", {
    fieldname: excelFile.fieldname,
    originalname: excelFile.originalname,
    encoding: excelFile.encoding,
    mimetype: excelFile.mimetype,
    size: excelFile.size,
    buffer: excelFile.buffer ? 'Buffer exists' : 'No buffer',
    path: excelFile.path || 'No path'
  });

  // type check
  if (!excelFile.originalname.endsWith('.xlsx') && !excelFile.originalname.endsWith('.xls')) {
    return res.status(400).json({ success: false, message: 'Please upload a valid Excel file (.xlsx or .xls)' });
  }

  try {
    const XLSX = require('xlsx');

    let workbook;
    if (excelFile.buffer) {
      console.log("Reading from buffer...");
      workbook = XLSX.read(excelFile.buffer, { type: 'buffer' });
    } else if (excelFile.path) {
      console.log("Reading from file path...");
      workbook = XLSX.readFile(excelFile.path);
    } else {
      throw new Error('No file buffer or path available');
    }

    const sheetName = workbook.SheetNames[0];
    console.log("Sheet names:", workbook.SheetNames);
    console.log("Selected sheet:", sheetName);

    const worksheet = workbook.Sheets[sheetName];
    if (!worksheet) {
      throw new Error(`Worksheet '${sheetName}' not found. Available sheets: ${workbook.SheetNames.join(', ')}`);
    }

    const orders = XLSX.utils.sheet_to_json(worksheet);
    console.log("Parsed orders from Excel:", orders);
    console.log("Orders length:", orders ? orders.length : 'undefined');
    console.log("Orders type:", Array.isArray(orders) ? 'Array' : typeof orders);

    if (!orders || !Array.isArray(orders) || orders.length === 0) {
      return res.status(400).json({ success: false, message: 'No valid orders found in the Excel file' });
    }

    // Express: no channel validation
    const results = [];
    let successCount = 0;
    let errorCount = 0;
    let skippedCount = 0;
    let validationErrorCount = 0;

    for (let i = 0; i < orders.length; i++) {
      const order = orders[i];
      const orderIndex = i + 1;

      try {
        // Validate row
        const validationResult = validateExpressBulkOrderData(order, orderIndex);
        if (!validationResult.valid) {
          validationErrorCount++;
          results.push({
            orderIndex,
            orderId: getAny(order, 'orderID', 'orderid', 'Order ID') || 'N/A',
            status: 'validation_error',
            message: validationResult.message,
            errors: validationResult.errors
          });
          continue;
        }

        const orderId = getAny(order, 'orderID', 'orderid', 'Order ID') || '';
        if (!orderId) {
          results.push({
            orderIndex,
            status: 'error',
            message: 'Order ID is missing'
          });
          errorCount++;
          continue;
        }

        // duplicate check
        const [existingOrder] = await mySqlQury(
          'SELECT id FROM tbl_exp_orders WHERE orderid = ? AND client_id = ?',
          [orderId, clientid]
        );

        if (existingOrder) {
          results.push({
            orderIndex,
            orderId,
            status: 'skipped',
            message: 'Order already exists in database'
          });
          skippedCount++;
          continue;
        }

        // transaction
        await mySqlQury('START TRANSACTION');

        // ----- 1) tbl_exp_orders -----
        const orderInsertQuery = `
          INSERT INTO tbl_exp_orders
            (ref_number, orderid, payment_mode, collectable_amount, warehouse_id, total_weight, grand_total, total_qty, total_tax, total_discount, is_unprocessed, client_id, box_qty, invoice_no)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `;
        const orderParams = [
          getAny(order, 'refid', 'ref_number', 'Ref ID', 'Ref Number') || '',
          orderId,
          (getAny(order, 'paymentMode', 'payment_mode', 'Payment Mode') || 'COD').toLowerCase(),
          getAny(order, 'collectableAmount', 'collectable_amount', 'Collectable Amount') || 0,
          warehouseId,
          getAny(order, 'total_Weight', 'totalWeight', 'total_weight', 'Total Weight') || 0,
          getAny(order, 'grandTotal', 'grand_total', 'Grand Total') || 0,
          getAny(order, 'totalQty', 'total_qty', 'Total Qty', 'Total Quantity') || 0,
          getAny(order, 'totalTax', 'total_tax', 'Total Tax') || 0,
          getAny(order, 'totalDiscount', 'total_discount', 'Total Discount') || 0,
          1, // is_unprocessed
          clientid,
          0, // will update with box count
          getAny(order, 'invoiceNumber', 'invoice_no', 'Invoice Number', 'Invoice No') || ''
        ];
        const orderResult = await mySqlQury(orderInsertQuery, orderParams);
        const newOrderId = orderResult.insertId;

        // ----- 2) Consignee (shipping + billing) -----
        const billingSameAsShipping =
          order.billingSameAsShipping !== undefined
            ? order.billingSameAsShipping
            : (order.billing_same_as_shipping !== undefined ? order.billing_same_as_shipping : true);

        const billingDetails = billingSameAsShipping
          ? {
              billing_first_name: getAny(order, 'billing_first_name', 'Billing First Name', 'firstName', 'First Name') || '',
              billing_last_name: getAny(order, 'billing_last_name', 'Billing Last Name', 'lastName', 'Last Name') || '',
              billing_email: getAny(order, 'billing_email', 'Billing Email', 'email') || '',
              billing_phone: getAny(order, 'billing_phone', 'Billing Phone', 'phone') || '',
              billing_alternate_phone: getAny(order, 'billing_alternate_phone', 'Billing Alternate Phone', 'alternatePhone', 'Alternate Phone') || '',
              billing_address_line1: getAny(order, 'billing_address_line1', 'Billing Address Line1', 'addressLine1', 'Address Line1') || '',
              billing_address_line2: getAny(order, 'billing_address_line2', 'Billing Address Line2', 'addressLine2', 'Address Line2') || '',
              billing_landmark: getAny(order, 'billing_landmark', 'Billing Landmark', 'landmark') || '',
              billing_country: getAny(order, 'billing_country', 'Billing Country', 'country') || '',
              billing_state: getAny(order, 'billing_state', 'Billing State', 'state') || '',
              billing_city: getAny(order, 'billing_city', 'Billing City', 'city') || '',
              billing_pincode: getAny(order, 'billing_pincode', 'Billing Pincode', 'pincode') || ''
            }
          : {
              billing_first_name: getAny(order, 'billing_first_name', 'Billing First Name') || '',
              billing_last_name: getAny(order, 'billing_last_name', 'Billing Last Name') || '',
              billing_email: getAny(order, 'billing_email', 'Billing Email') || '',
              billing_phone: getAny(order, 'billing_phone', 'Billing Phone') || '',
              billing_alternate_phone: getAny(order, 'billing_alternate_phone', 'Billing Alternate Phone') || '',
              billing_address_line1: getAny(order, 'billing_address_line1', 'Billing Address Line1') || '',
              billing_address_line2: getAny(order, 'billing_address_line2', 'Billing Address Line2') || '',
              billing_landmark: getAny(order, 'billing_landmark', 'Billing Landmark') || '',
              billing_country: getAny(order, 'billing_country', 'Billing Country') || '',
              billing_state: getAny(order, 'billing_state', 'Billing State') || '',
              billing_city: getAny(order, 'billing_city', 'Billing City') || '',
              billing_pincode: getAny(order, 'billing_pincode', 'Billing Pincode') || ''
            };

        const consigneeInsertQuery = `
          INSERT INTO tbl_exp_consignee_details
            (
              order_id,
              first_name, last_name, email, phone, alternate_phone,
              address_line1, address_line2, landmark, country, state, city, pincode,
              billing_same_as_shipping,
              billing_first_name, billing_last_name, billing_email, billing_phone, billing_alternate_phone,
              billing_address_line1, billing_address_line2, billing_landmark, billing_country, billing_state, billing_city, billing_pincode
            )
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `;
        const consigneeParams = [
          newOrderId,
          getAny(order, 'firstName', 'First Name', 'first_name') || '',
          getAny(order, 'lastName', 'Last Name', 'last_name') || '',
          getAny(order, 'email', 'Email') || '',
          getAny(order, 'phone', 'Phone') || '',
          getAny(order, 'alternatePhone', 'Alternate Phone', 'alternate_phone') || '',
          getAny(order, 'addressLine1', 'Address Line1', 'Address Line 1', 'address_line1') || '',
          getAny(order, 'addressLine2', 'Address Line2', 'Address Line 2', 'address_line2') || '',
          getAny(order, 'landmark', 'Landmark') || '',
          getAny(order, 'country', 'Country') || '',
          getAny(order, 'state', 'State') || '',
          getAny(order, 'city', 'City') || '',
          getAny(order, 'pincode', 'Pincode', 'PIN Code', 'Pin') || '',
          billingSameAsShipping ? 1 : 0,

          billingDetails.billing_first_name,
          billingDetails.billing_last_name,
          billingDetails.billing_email,
          billingDetails.billing_phone,
          billingDetails.billing_alternate_phone,
          billingDetails.billing_address_line1,
          billingDetails.billing_address_line2,
          billingDetails.billing_landmark,
          billingDetails.billing_country,
          billingDetails.billing_state,
          billingDetails.billing_city,
          billingDetails.billing_pincode
        ];
        await mySqlQury(consigneeInsertQuery, consigneeParams);

        // ----- 3) Boxes (dynamic) -----
        let boxCount = 0;
        const dynamicBoxes = extractBoxesFromRow(order);
        if (dynamicBoxes.length > 0) {
          const insertBoxSql = `
            INSERT INTO tbl_exp_boxes_details
              (order_id, package_type, length, breadth, height, dimension_unit, weight, weight_unit)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
          `;
          for (const b of dynamicBoxes) {
            await mySqlQury(insertBoxSql, [
              newOrderId,
              b.package_type || 'BOX',
              b.length,
              b.breadth,
              b.height,
              b.dimension_unit || 'cm',
              b.weight,
              b.weight_unit || 'kg'
            ]);
            boxCount++;
          }
        }
        if (boxCount > 0) {
          await mySqlQury('UPDATE tbl_exp_orders SET box_qty = ? WHERE id = ?', [boxCount, newOrderId]);
        }

        // ----- 4) Product (optional) -----
        if (getAny(order, 'name', 'Product Name', 'productName', 'product_name')) {
          const productInsertQuery = `
            INSERT INTO tbl_exp_product_details
              (order_id, category, name, price, sku, quantity, discount_value, discount_type, tax_type)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
          `;
          const productParams = [
            newOrderId,
            getAny(order, 'category', 'category', 'Product Category', 'productCategory') || '',
            getAny(order, 'name', 'Product Name', 'productName', 'product_name') || '',
            getAny(order, 'price', 'Product Price', 'productPrice') || 0,
            getAny(order, 'sku', 'Product SKU', 'productSku') || '',
            getAny(order, 'quantity', 'Product Quantity', 'productQuantity', 'totalQty', 'total_qty') || 1,
            getAny(order, 'discountValue', 'Discount Value', 'discount_value') || 0,
            getAny(order, 'discountType', 'Discount Type', 'discount_type') || 'Flat',
            getAny(order, 'taxType', 'Tax Type', 'tax_type') || 'None'
          ];
          await mySqlQury(productInsertQuery, productParams);
        }

        // commit
        await mySqlQury('COMMIT');

        successCount++;
        results.push({
          orderIndex,
          orderId,
          newOrderId,
          status: 'success',
          message: 'Order created successfully'
        });
      } catch (orderError) {
        await mySqlQury('ROLLBACK');
        errorCount++;
        results.push({
          orderIndex,
          status: 'error',
          message: orderError.message
        });
        console.error(`Error creating order ${orderIndex}:`, orderError);
      }
    }

    console.log("summary", successCount, skippedCount, errorCount);

    return res.json({
      success: true,
      message: `Bulk order processing completed. Success: ${successCount}, Skipped: ${skippedCount}, Errors: ${errorCount}`,
      summary: {
        totalOrders: orders.length,
        successCount,
        skippedCount,
        errorCount
      },
      results
    });

  } catch (error) {
    console.error('Bulk order creation error:', error);
    return res.status(500).json({
      success: false,
      message: 'Failed to process Excel file',
      error: error.message
    });
  }
};


function num(v) {
  const n = Number(v);
  return Number.isFinite(n) ? n : 0;
}

function str(v, fallback = '') {
  if (v === null || v === undefined) return fallback;
  return String(v).trim();
}

function getAny(obj, ...keys) {
  for (const k of keys) {
    if (obj[k] !== undefined && obj[k] !== null && String(obj[k]).trim() !== '') return obj[k];
  }
  return undefined;
}

function isPosNum(v) {
  const n = Number(v);
  return Number.isFinite(n) && n >= 0;
}

/**
 * Extract boxes from a row (order) with flexible column headers.
 * Recognized fields per box: package_type, length, breadth, height, dimension_unit, weight, weight_unit
 * Supported header patterns (case-insensitive, spaces/underscores/dashes tolerated):
 *   box1_length, box1_weightUnit
 *   Box 1 Length, Box 2 Weight Unit
 *   Box1 Length
 *   length_box1, weightUnit_box2
 */
function extractBoxesFromRow(row) {
  const boxes = {}; // { [idx]: { ...fields } }

  const patterns = [
    // box{n}_{field} or box{n}-{field} or box{n} {field}
    /^(box)\s*?(\d+)[_\-\s]*(package\s*type|packageType|length|breadth|height|dimension\s*unit|dimensionUnit|weight|weight\s*unit|weightUnit)$/i,
    // {field}_box{n} or {field}-box{n}
    /^(package\s*type|packageType|length|breadth|height|dimension\s*unit|dimensionUnit|weight|weight\s*unit|weightUnit)[_\-\s]*(box)\s*?(\d+)$/i,
    // "Box 1 {field}" or "Box1 {field}"
    /^(box)\s*?(\d+)[_\-\s]+(.*)$/i,
  ];

  const fieldAlias = (raw) => {
    const t = raw.replace(/\s+/g, '').toLowerCase();
    if (t === 'packagetype') return 'package_type';
    if (t === 'length') return 'length';
    if (t === 'breadth' || t === 'width') return 'breadth'; // allow "Width"
    if (t === 'height') return 'height';
    if (t === 'dimensionunit' || t === 'dimunit' || t === 'dimension') return 'dimension_unit';
    if (t === 'weight') return 'weight';
    if (t === 'weightunit' || t === 'unit') return 'weight_unit';
    return null;
  };

  for (const key in row) {
    if (!Object.prototype.hasOwnProperty.call(row, key)) continue;
    const val = row[key];
    if (val === undefined) continue;

    const trimmedKey = String(key).trim();
    let matched = false;

    for (const rx of patterns) {
      const m = trimmedKey.match(rx);
      if (!m) continue;

      let idx = null;
      let fieldRaw = null;

      if (rx === patterns[0]) {
        // ^(box)(\d+)...(field)$
        idx = Number(m[2]);
        fieldRaw = m[3];
      } else if (rx === patterns[1]) {
        // ^(field)...(box)(\d+)$
        idx = Number(m[3]);
        fieldRaw = m[1];
      } else {
        // ^(box)(\d+)...(.*)$
        idx = Number(m[2]);
        fieldRaw = m[3];
      }

      const field = fieldAlias(String(fieldRaw || '').trim());
      if (!field || !Number.isFinite(idx)) continue;

      if (!boxes[idx]) {
        boxes[idx] = {
          package_type: 'BOX',
          length: 0,
          breadth: 0,
          height: 0,
          dimension_unit: 'cm',
          weight: 0,
          weight_unit: 'kg',
        };
      }

      if (field === 'package_type') boxes[idx].package_type = str(val, 'BOX');
      else if (field === 'length') boxes[idx].length = num(val);
      else if (field === 'breadth') boxes[idx].breadth = num(val);
      else if (field === 'height') boxes[idx].height = num(val);
      else if (field === 'dimension_unit') boxes[idx].dimension_unit = str(val, 'cm');
      else if (field === 'weight') boxes[idx].weight = num(val);
      else if (field === 'weight_unit') boxes[idx].weight_unit = str(val, 'kg');

      matched = true;
      break;
    }

    // simple fallback like box1_packageType, box2_dimensionUnit etc.
    if (!matched) {
      const simple = trimmedKey.match(/^box\s*?(\d+)[_\-\s]*(packagetype|package_type|length|breadth|height|dimensionunit|dimension_unit|weight|weightunit|weight_unit)$/i);
      if (simple) {
        const idx = Number(simple[1]);
        const field = fieldAlias(simple[2]);
        if (Number.isFinite(idx) && field) {
          if (!boxes[idx]) {
            boxes[idx] = {
              package_type: 'BOX',
              length: 0,
              breadth: 0,
              height: 0,
              dimension_unit: 'cm',
              weight: 0,
              weight_unit: 'kg',
            };
          }
          const v = row[key];
          if (field === 'package_type') boxes[idx].package_type = str(v, 'BOX');
          else if (field === 'length') boxes[idx].length = num(v);
          else if (field === 'breadth') boxes[idx].breadth = num(v);
          else if (field === 'height') boxes[idx].height = num(v);
          else if (field === 'dimension_unit') boxes[idx].dimension_unit = str(v, 'cm');
          else if (field === 'weight') boxes[idx].weight = num(v);
          else if (field === 'weight_unit') boxes[idx].weight_unit = str(v, 'kg');
        }
      }
    }
  }

  // sort by box index and keep only valid (>0) numeric fields
  return Object.keys(boxes)
    .sort((a, b) => Number(a) - Number(b))
    .map(k => boxes[k])
    .filter(b =>
      Number(b.length) > 0 &&
      Number(b.breadth) > 0 &&
      Number(b.height) > 0 &&
      Number(b.weight) > 0
    );
}

const getAddressesEcom=async (req, res, next) => {
  try {
    const { phoneNumber, storeId } = req.body;  // Extract both phoneNumber and storeId

    let query = '';
    let queryParams = [];

    if (phoneNumber) {
      console.log("Fetching addresses for phone number:", phoneNumber);
      query = 'SELECT * FROM tbl_ecom_consignee_details WHERE phone = ?';
      queryParams = [phoneNumber];
    } else if (storeId) {
      console.log("Fetching addresses for store ID:", storeId);
      query = 'SELECT * FROM tbl_customer_details WHERE store_id = ?';
      queryParams = [storeId];
    } else {
      // If neither phoneNumber nor storeId is provided, return an error
      return res.status(400).json({ success: false, message: 'Please provide either a phone number or store ID.' });
    }

    // Execute the query with the appropriate parameters
    const results = await mySqlQury(query, queryParams);
    console.log('Results of address fetch:', results);

    // Always return a success response with the addresses
    res.status(200).json({ success: true, addresses: results });
  } catch (error) {
    console.error("Error fetching addresses:", error);
    res.status(500).json({ success: false, message: 'Server error' });
  }
}
const getEcomCreateOrder =async (req, res, next) => {
  try {
    const role_data = req.user;
    const role = req.user.role;
    const selectedClientId = req.user.selectedClientId || 1;

    let loginDetails = null;
    let clientId = 0;
    let walletBalance = 0;
    let vasService = 0;
    console.log("req user", req.user);
    let warehouseData = null;
    let productsData = null;

    // Get login details based on selectedClientId
    if (selectedClientId === 1) {
      // For admin (selectedClientId = 1), get details from tbl_admin
      const adminDetails = await mySqlQury(
        'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
        [role_data.id]
      );
      if (adminDetails && adminDetails.length > 0) {
        loginDetails = adminDetails[0];
      }
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [role_data.id]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      vasService = 1;

      // Fetch all warehouse data for admin
      warehouseData = await mySqlQury('SELECT serial,warehouse_name FROM tbl_add_warehouse');
      productsData = await mySqlQury('SELECT category,name,price,sku FROM client_products');
    } else {
      // For specific client, use selectedClientId directly
      loginDetails = {
        id: selectedClientId,
        first_name: 'Client',
        company_name: 'Client Company',
        logo_path: null,
        vas: 1
      };
      clientId = selectedClientId;
      vasService = 1;
      
      const wallet = await mySqlQury(`SELECT total_amount FROM tbl_wallet WHERE user_id = ?`, [selectedClientId]);
      walletBalance = (wallet.length > 0) ? wallet[0].total_amount : 0;
      console.log("login details", selectedClientId, loginDetails);

      // Fetch warehouse data for this specific client
      warehouseData = await mySqlQury(
        'SELECT serial,warehouse_name FROM tbl_add_warehouse WHERE client_id = ?',
        [selectedClientId]
      );
      productsData = await mySqlQury(
        'SELECT category,name,price,sku FROM client_products WHERE client_id = ?',
        [selectedClientId]
      );
    }

    const lang_data = req.language_data;
    const language_name = req.lang;
    const clients = await mySqlQury(`SELECT id, company_name FROM tbl_admin`);

    const notification_data = await mySqlQury(
      `SELECT * FROM tbl_notification WHERE received = '${role_data.id}' ORDER BY id DESC LIMIT 3`
    );

    // Get active topics
    const activeTopics = await mySqlQury(
      'SELECT topic_id FROM tbl_permissions WHERE role_id = ? AND is_active = 1',
      [req.user.role]
    );

    const commodities = await mySqlQury(`SELECT COMMODITY_NAME FROM commodities`);
    const [profile] = await mySqlQury(
      `SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?`,
      [req.user.id]
    );

    // Extract active topic IDs
    let activeTopicIds = [];
    if (Array.isArray(activeTopics)) {
      activeTopicIds = activeTopics.map(topic => Number(topic.topic_id));
    }
    console.log("client id in express create order", clientId);
    console.log("product data",productsData)
    console.log("warehosue data",warehouseData)

    // Render the express/create-order template and pass all the data
    res.render('pages/ecom/create-order', {
      title: 'Create New B2B Order',
      bodyClass: 'profile-page',
      activePage: 'create-orderb2b',
      role_data: role_data,
      lang_data: lang_data,
      language_name: language_name,
      notification_data: notification_data,
      clients,
      commodities,
      activeTopicIds,
      loginDetails,
      profile,
      clientId,
      walletBalance,
      vasService,
      warehouseData, // Pass warehouse data to the template
      productsData,
      role
    });

  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({
      status: "error",
      message: "Internal Server Error",
      details: error.message
    });
  } 
}
const postKyc = async (req, res) => {
  try {
    const {id, is_kyc_submitted, is_kyc_verified} = req.user; 
    const result = await mySqlQury(
      "SELECT id,organization, email, first_name,last_name, phone_no, is_kyc_submitted, is_kyc_verified FROM tbl_admin WHERE id = ?",
      [id]
    );

    const user = result[0] || {};
    console.log("user in kyc", user);

    // // âœ… If KYC already submitted, redirect to index
    if (is_kyc_verified) {
      req.flash("info", "You have already submitted your KYC.");
      return res.redirect("/index");
    }
   // âœ… If KYC already submitted, redirect to index
    // if (token.is_kyc_submitted) {
    //   req.flash("info", "You have already submitted your KYC.");
    //   return res.redirect("/index");
    // }
    // âœ… Otherwise render the KYC form
    
    res.render("pages/kyc", {
      title: "KYC Form",
      bodyClass: "profile-page",
      activePage: "kyc",
      userData: user
    });
  } catch (err) {
    console.error("Error loading KYC page", err);
    res.status(500).send("Internal Server Error");
  }
};

const getKycData = async (req, res) => {
  try {
    const userId = req.user.id;
    const role = req.user.role;

    const result = await mySqlQury(
      "SELECT organization, email, first_name, phone_no FROM tbl_admin WHERE id = ?",
      [userId]
    );

    const user = result[0] || {};

    res.json({
      success: true,
      role,
      userData: user
    });
  } catch (err) {
    console.error("Error fetching KYC JSON data", err);
    res.status(500).json({
      success: false,
      message: "Internal Server Error"
    });
  }
};

// âœ… Update KYC â€” Aadhaar front+back ek hi column me JSON, null aane par old value preserve
const postSubmitKyc = async (req, res) => {
  try {
    await mySqlQury('START TRANSACTION');

    const {
      companyType,
      company_pan,
      gstNo,
      pan_holder_name,
      trade_name,
      constitution_of_business,
      nature_of_business,
      aadhaarNumber,
      companyEmail,
      website,
      registeredCompanyName,
      brandName,
      companyRegNumber,
      cancelledCheckNumber,
    } = req.body;

    const userId = req.user.id;
    const userEmail = req.user.email;

    // ðŸ–¼ï¸ Files from form (names aligned with your HTML)
    const selfiePath = req.files?.selfie?.[0]?.filename || null;
    const aadhaarFront = req.files?.aadhaarFrontUpload?.[0]?.filename || null;
    const aadhaarBack  = req.files?.aadhaarBackUpload?.[0]?.filename  || null;
    const panPath      = req.files?.pandoc?.[0]?.filename             || null;
    const gstPath      = req.files?.gstdoc?.[0]?.filename             || null;
    const regDoc       = req.files?.companyRegUpload?.[0]?.filename   || null;
    const chequeDoc    = req.files?.cancelledCheckUpload?.[0]?.filename || null;
    const logoPath     = req.files?.clientLogo?.[0]?.filename         || null;

    // ðŸ”’ Lock current row; also fetch existing values to preserve if new is null
      const existingRows = await mySqlQury(
        `SELECT ks.*, tbl.* 
        FROM kyc_submissions ks 
        JOIN tbl_admin tbl ON ks.user_id = tbl.id 
        WHERE ks.user_id = ? 
        FOR UPDATE`,
        [userId]
      );

    if (existingRows.length === 0) {
      await mySqlQury('ROLLBACK');
      return res.status(404).json({ success: false, message: 'KYC record not found for this user.' });
    }
    if(existingRows[0].is_kyc_submitted==1){
      await mySqlQury('ROLLBACK')
      return res.status(400).json({ success: false, message: 'KYC has already been submitted and cannot be updated.' });
    }
    const existing = existingRows[0];
    // ðŸª„ Merge helper: prefer newValue, else keep oldValue
    const keep = (newVal, oldVal) => (newVal !== null && newVal !== undefined && newVal !== '' ? newVal : oldVal ?? null);

    // ðŸ§® Build merged values (text + file paths)
    const merged = {
      email: keep(userEmail, existing.email),
      company_type: keep(companyType, existing.company_type),
      registered_company_name: keep(registeredCompanyName, existing.registered_company_name),
      brand_name: keep(brandName, existing.brand_name),
      company_email: keep(companyEmail, existing.company_email),
      website: keep(website, existing.website),

      selfie_path: keep(selfiePath, existing.selfie_path),
      aadhaar_number: keep(aadhaarNumber, existing.aadhaar_number),
      aadhar_front_doc: keep(aadhaarFront, existing.aadhar_front_doc),
      aadhar_back_doc: keep(aadhaarBack, existing.aadhar_back_doc),
      pan_number: keep(company_pan, existing.pan_number),
      pan_path: keep(panPath, existing.pan_path),
      pan_name: keep(pan_holder_name, existing.pan_name),

      gst_number: keep(gstNo, existing.gst_number),
      gst_path: keep(gstPath, existing.gst_path),
      gst_trade_name: keep(trade_name, existing.gst_trade_name),
      gst_constitution_of_business: keep(constitution_of_business, existing.gst_constitution_of_business),
      gst_nature_of_business_activities: keep(nature_of_business, existing.gst_nature_of_business_activities),

      company_reg_number: keep(companyRegNumber, existing.company_reg_number),
      company_reg_doc: keep(regDoc, existing.company_reg_doc),

      cancelled_cheque_number: keep(cancelledCheckNumber, existing.cancelled_cheque_number),
      cancelled_cheque_doc: keep(chequeDoc, existing.cancelled_cheque_doc),

      logo_path: keep(logoPath, existing.logo_path),
    };

    // ðŸ§· Prepare UPDATE with dynamic aadhaar column
    const sql = `
      UPDATE kyc_submissions SET
        email = ?,
        company_type = ?, registered_company_name = ?, brand_name = ?,
        company_email = ?, website = ?,
        selfie_path = ?, aadhaar_number = ?, aadhar_front_doc = ?, aadhar_back_doc = ?,
        pan_number = ?, pan_path = ?, pan_name = ?,
        gst_number = ?, gst_path = ?, gst_trade_name = ?, gst_constitution_of_business = ?, gst_nature_of_business_activities = ?,
        company_reg_number = ?, company_reg_doc = ?,
        cancelled_cheque_number = ?, cancelled_cheque_doc = ?,
        logo_path = ?
      WHERE user_id = ?;
    `;

    const params = [
      merged.email,
      merged.company_type, merged.registered_company_name, merged.brand_name,
      merged.company_email, merged.website,
      merged.selfie_path, merged.aadhaar_number, merged.aadhar_front_doc, merged.aadhar_back_doc,
      merged.pan_number, merged.pan_path, merged.pan_name,
      merged.gst_number, merged.gst_path, merged.gst_trade_name, merged.gst_constitution_of_business, merged.gst_nature_of_business_activities,
      merged.company_reg_number, merged.company_reg_doc,
      merged.cancelled_cheque_number, merged.cancelled_cheque_doc,
      merged.logo_path,
      userId,
    ];
    await mySqlQury(`update tbl_admin set is_kyc_submitted=1 where id=?`, [userId]);
    await mySqlQury(sql, params);

    await mySqlQury('COMMIT');
    return res.json({ success: true, message: 'âœ… KYC updated successfully!' });
  } catch (err) {
    console.error('âŒ KYC Update Error:', err);
    await mySqlQury('ROLLBACK');
    return res.status(500).json({ success: false, message: 'Server error while updating KYC data.' });
  }
};

// âœ… Update KYC â€” After kyc submitted
const UpdateKycData = async (req, res) => {
  try {
    await mySqlQury('START TRANSACTION');

    const {
      companyType,
      company_pan,
      gstNo,
      pan_holder_name,
      trade_name,
      constitution_of_business,
      nature_of_business,
      aadhaarNumber,
      companyEmail,
      website,
      registeredCompanyName,
      brandName,
      companyRegNumber,
      cancelledCheckNumber,
    } = req.body;

    const userId = req.user.id;
    const userEmail = req.user.email;

    // ðŸ–¼ï¸ Files from form (names aligned with your HTML)
    const selfiePath = req.files?.selfie?.[0]?.filename || null;
    const aadhaarFront = req.files?.aadhaarFrontUpload?.[0]?.filename || null;
    const aadhaarBack  = req.files?.aadhaarBackUpload?.[0]?.filename  || null;
    const panPath      = req.files?.pandoc?.[0]?.filename             || null;
    const gstPath      = req.files?.gstdoc?.[0]?.filename             || null;
    const regDoc       = req.files?.companyRegUpload?.[0]?.filename   || null;
    const chequeDoc    = req.files?.cancelledCheckUpload?.[0]?.filename || null;
    const logoPath     = req.files?.clientLogo?.[0]?.filename         || null;

    // ðŸ”’ Lock current row; also fetch existing values to preserve if new is null
    const existingRows = await mySqlQury(
      'SELECT * FROM kyc_submissions WHERE user_id = ?  FOR UPDATE',
      [userId]
    );

    if (existingRows.length === 0) {
      await mySqlQury('ROLLBACK');
      return res.status(404).json({ success: false, message: 'KYC record not found for this user.' });
    }
    const existing = existingRows[0];

    // ðŸª„ Merge helper: prefer newValue, else keep oldValue
    const keep = (newVal, oldVal) => (newVal !== null && newVal !== undefined && newVal !== '' ? newVal : oldVal ?? null);



    // ðŸ§® Build merged values (text + file paths)
    const merged = {
      email: keep(userEmail, existing.email),
      company_type: keep(companyType, existing.company_type),
      registered_company_name: keep(registeredCompanyName, existing.registered_company_name),
      brand_name: keep(brandName, existing.brand_name),
      company_email: keep(companyEmail, existing.company_email),
      website: keep(website, existing.website),

      selfie_path: keep(selfiePath, existing.selfie_path),
      aadhaar_number: keep(aadhaarNumber, existing.aadhaar_number),
      aadhar_front_doc: keep(aadhaarFront, existing.aadhar_front_doc),
      aadhar_back_doc: keep(aadhaarBack, existing.aadhar_back_doc),
      pan_number: keep(company_pan, existing.pan_number),
      pan_path: keep(panPath, existing.pan_path),
      pan_name: keep(pan_holder_name, existing.pan_name),

      gst_number: keep(gstNo, existing.gst_number),
      gst_path: keep(gstPath, existing.gst_path),
      gst_trade_name: keep(trade_name, existing.gst_trade_name),
      gst_constitution_of_business: keep(constitution_of_business, existing.gst_constitution_of_business),
      gst_nature_of_business_activities: keep(nature_of_business, existing.gst_nature_of_business_activities),

      company_reg_number: keep(companyRegNumber, existing.company_reg_number),
      company_reg_doc: keep(regDoc, existing.company_reg_doc),

      cancelled_cheque_number: keep(cancelledCheckNumber, existing.cancelled_cheque_number),
      cancelled_cheque_doc: keep(chequeDoc, existing.cancelled_cheque_doc),

      logo_path: keep(logoPath, existing.logo_path),
    };

    // ðŸ§· Prepare UPDATE with dynamic aadhaar column
    const sql = `
      UPDATE kyc_submissions SET
        email = ?,
        company_type = ?, registered_company_name = ?, brand_name = ?,
        company_email = ?, website = ?,
        selfie_path = ?, aadhaar_number = ?, aadhar_front_doc = ?, aadhar_back_doc = ?,
        pan_number = ?, pan_path = ?, pan_name = ?,
        gst_number = ?, gst_path = ?, gst_trade_name = ?, gst_constitution_of_business = ?, gst_nature_of_business_activities = ?,
        company_reg_number = ?, company_reg_doc = ?,
        cancelled_cheque_number = ?, cancelled_cheque_doc = ?,
        logo_path = ?
      WHERE user_id = ?;
    `;

    const params = [
      merged.email,
      merged.company_type, merged.registered_company_name, merged.brand_name,
      merged.company_email, merged.website,
      merged.selfie_path, merged.aadhaar_number, merged.aadhar_front_doc, merged.aadhar_back_doc,
      merged.pan_number, merged.pan_path, merged.pan_name,
      merged.gst_number, merged.gst_path, merged.gst_trade_name, merged.gst_constitution_of_business, merged.gst_nature_of_business_activities,
      merged.company_reg_number, merged.company_reg_doc,
      merged.cancelled_cheque_number, merged.cancelled_cheque_doc,
      merged.logo_path,
      userId,
    ];

    await mySqlQury(sql, params);

    await mySqlQury('COMMIT');
    return res.json({ success: true, message: 'âœ… KYC updated successfully!' });
  } catch (err) {
    console.error('âŒ KYC Update Error:', err);
    await mySqlQury('ROLLBACK');
    return res.status(500).json({ success: false, message: 'Server error while updating KYC data.' });
  }
};


const encrypt = async (token) => {
  try {
    const pass = 'India@2608';
    const iv = crypto.randomBytes(16); // generate random IV (16 bytes)

    // Generate SHA512 hash from password
    const hash = crypto.createHash('sha512');
    const dataKey = hash.update(pass, 'utf-8');
    const genHash = dataKey.digest('hex');

    const key = genHash.substring(0, 16); // AES-128 uses 16-byte key

    const cipher = crypto.createCipheriv('aes-128-cbc', Buffer.from(key), iv);
    let encrypted = cipher.update(token, 'utf-8', 'base64');
    encrypted += cipher.final('base64');

    // Append IV to encrypted data (needed for decryption)
    const result = encrypted + ':' + Buffer.from(iv).toString('base64');
    return result;
  } catch (err) {
    throw err;
  }
};

// ðŸ”“ Decrypt Function
const decrypt = (encText) => {
  try {
    const pass = 'India@2608';

    const hash = crypto.createHash('sha512');
    const datakey = hash.update(pass, 'utf-8');
    const genHash = datakey.digest('hex');
    const key = genHash.substring(0, 16);

    const parts = encText.split(':');
    const iv = Buffer.from(parts[1], 'base64'); // Extract IV
    const encryptedData = parts[0];

    const decipher = crypto.createDecipheriv('aes-128-cbc', Buffer.from(key), iv);
    let decrypted = decipher.update(encryptedData, 'base64', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  } catch (err) {
    throw err;
  }
};
// ðŸ”¢ Generate Random 6-digit Transaction ID
async function generateTransID() {
  const min = 100000;
  const max = 999999;
  const randomID = Math.floor(Math.random() * (max - min + 1)) + min;
  return randomID.toString();
}

// ðŸ§ª Test Everything
(async () => {
  const transID = await generateTransID(); // e.g., '123456'
  console.log('Generated TransID:', transID);

  const encrypted = await encrypt(transID);
  console.log('Encrypted:', encrypted);

  const decrypted = decrypt(encrypted);
  console.log('Decrypted:', decrypted);
})
const postApproveClientKyc = async (req, res) => {
  const clientId = Number(req.body.client_id);
  const paymentMode = req.body.payment_mode; // New payment mode field
  console.log("payment mode", paymentMode)
  // console.log("fdhfdjfd",fdufgduf)

  try {
    await mySqlQury('START TRANSACTION');

    // Validate payment mode
    if (!paymentMode || !['prepaid', 'postpaid'].includes(paymentMode)) {
      await mySqlQury('ROLLBACK');
      return res.status(400).json({ error: 'Valid payment mode (prepaid or postpaid) is required.' });
    }

    // 1) Lock KYC row for this user
    const kycRows = await mySqlQury(
      `SELECT user_id, monthly_parcels, business_volume
       FROM kyc_submissions
       WHERE user_id = ?
       FOR UPDATE`,
      [clientId]
    );

    if (!kycRows || kycRows.length === 0) {
      await mySqlQury('ROLLBACK');
      return res.status(404).json({ error: 'KYC data not found.' });
    }

    const kycRow = kycRows[0];
    const monthlyParcelsValue = Number(kycRow.monthly_parcels) || 0; // codes 1..9
    const expVolumeValue      = Number(kycRow.business_volume)  || 0; // exact match

    // 2) Approve + activate client + set payment mode
    await mySqlQury(
      `UPDATE tbl_admin
       SET is_kyc_verified = 1, is_active = 1, is_kyc_submitted = 1, payment_mode = ?
       WHERE id = ?`,
      [paymentMode, clientId]
    );

    // 3) Partner selection rule: prefer business_volume, else monthly_parcels
    let whereClause = '';
    let whereValue  = null;

    if (expVolumeValue > 0) {
      whereClause = 'business_volume = ?';
      whereValue  = expVolumeValue;
    } else if (monthlyParcelsValue > 0) {
      whereClause = 'packet_shipment = ?';
      whereValue  = monthlyParcelsValue;
    }

    // 4) Insert mappings in one shot (if selector exists)
    if (whereClause) {
      // NOTE: if your column is actually spelled logistics_partner_id, fix it here.
      await mySqlQury(
        `
        INSERT IGNORE INTO tbl_client_lp (client_id, logictics_partner_id, status)
        SELECT ?, id, 1
        FROM tbl_logistics_partner
        WHERE ${whereClause}
        `,
        [clientId, whereValue]
      );
    }
       // 5) Create wallet entry for the client with initial amount = 0
       await mySqlQury(
        `INSERT IGNORE INTO tbl_wallet (user_id, total_amount, created_at, updated_at)
         VALUES (?, 0, NOW(), NOW())`,
        [clientId]
      );

    await mySqlQury('COMMIT');

    return res.json({
      success: true,
      message: whereClause
        ? `KYC approved, client activated with ${paymentMode} payment mode, and partner mappings created.`
        : `KYC approved and client activated with ${paymentMode} payment mode. No partner mappings (no volume/parcel code).`
    });
  } catch (err) {
    console.error('Approval error:', err);
    try { await mySqlQury('ROLLBACK'); } catch {}
    return res.status(500).json({ error: 'Server error during approval.' });
  }
};

const getKycList = async (req, res) => {

  try {
    const query = `
    SELECT     
      u.*
    FROM kyc_submissions k
    LEFT JOIN tbl_admin u
      ON k.user_id = u.id
    ORDER BY k.created_at DESC
  `;
  
    const kycList = await mySqlQury(query);

    res.render('pages/kyc-list', {
      title: 'Pending KYC Submissions',
      bodyClass: '',
      activePage: 'kyc-list',
      kycList: kycList || [],
      error: null,
      success: req.flash('success'),
      errors: req.flash('errors')
    });

  } catch (err) {
    console.error("Error fetching KYC list:", err);
    res.status(500).send("Failed to load KYC list.");  
  }
}   
// Assuming you already have: const mySqlQury = require('../db'); etc.

// utils/volumeBucket.js (optional helper you can inline below)
function parcelBucketLabel(code) {
  // Adjust ranges if your product uses a different map
  const map = {
    1: "0â€“500",
    2: "500â€“1,000",
    3: "1,000â€“2,000",
    4: "2,000â€“5,000",
    5: "5,000â€“10,000",
    6: "10,000+",
  };
  if (code == null) return null;
  const n = Number(code);
  return map[n] || `Code ${code}`;
}
const showClientData = async (req, res) => {
  const clientId = Number(req.params.id);
  try {
    res.render('pages/ClientDetails', {
      title: 'Client Info',
      clientId
    });
  } catch (error) {
    console.error("Error in /role-management route:", error);
    res.status(500).json({ error: "Internal server error while loading role management page" });
  }
}

const getClientDataById = async (req, res) => {
  try {
    const userId = Number(req.params.id);
    if (!userId) {
      return res.status(400).json({ ok: false, message: 'Invalid user id.' });
    }

    const sql = `
      SELECT
        /* tbl_admin */
        a.id              AS a_id,
        a.first_name      AS a_first_name,
        a.last_name       AS a_last_name,
        a.email           AS a_email,
        a.country_code    AS a_country_code,
        a.phone_no        AS a_phone_no,
        a.role            AS a_role,
        a.role_name       AS a_role_name,
        a.client_name     AS a_client_name,
        a.client_id       AS a_client_id,
        a.is_active       AS a_is_active,
        a.user_type       AS a_user_type,
        a.reporting_user  AS a_reporting_user,
        a.reporting_id    AS a_reporting_id,
        a.logo_path       AS a_logo_path,
        a.company_name    AS a_company_name,
        a.is_verified     AS a_is_verified,
        a.is_kyc_verified AS a_is_kyc_verified,
        a.is_kyc_submitted AS a_is_kyc_submitted,
        a.organization    AS a_organization,
        a.gst             AS a_gst,
        a.payment_mode    AS a_payment_mode,
        a.monthly_parcels AS a_monthly_parcels,
        a.company_type    AS a_company_type,
        a.verify_token    AS a_verify_token,
        a.exp_volume      AS a_exp_volume,
        a.parent_id       AS a_parent_id,
        a.level           AS a_level,
        a.role_id         AS a_role_id,

        /* kyc_submissions */
        k.id                          AS k_id,
        k.user_id                     AS k_user_id,
        k.email                       AS k_email,
        k.business_type               AS k_business_type,
        k.sub_type                    AS k_sub_type,
        k.selfie_path                 AS k_selfie_path,
        k.aadhaar_number              AS k_aadhaar_number,
        k.aadhar_front_doc           AS k_aadhar_front_doc,
        k.aadhar_back_doc             AS k_aadhar_back_doc,
        k.pan_name                    AS k_pan_name,
        k.pan_number                  AS k_pan_number,
        k.pan_path                    AS k_pan_path,
        k.gst_number                  AS k_gst_number,
        k.gst_trade_name              AS k_gst_trade_name,
        k.gst_nature_of_business_activities AS k_gst_nature_of_business_activities,
        k.company_reg_number          AS k_company_reg_number,
        k.company_reg_doc             AS k_company_reg_doc,
        k.cancelled_cheque_number     AS k_cancelled_cheque_number,
        k.cancelled_cheque_doc        AS k_cancelled_cheque_doc,
        k.logo_path                   AS k_logo_path,
        k.gst_constitution_of_business AS k_gst_constitution_of_business,
        k.gst_path                    AS k_gst_path,
        k.created_at                  AS k_created_at,
        k.submitted_at                AS k_submitted_at,
        k.submission_status           AS k_submission_status,
        k.business_logo_path          AS k_business_logo_path,
        k.registered_company_name     AS k_registered_company_name,
        k.brand_name                  AS k_brand_name,
        k.company_email               AS k_company_email,
        k.website                     AS k_website,
        k.company_type                AS k_company_type,
        k.organization                AS k_organization,
        k.monthly_parcels             AS k_monthly_parcels,
        k.business_volume             AS k_business_volume,
        k.segment_type                AS k_segment_type
      FROM tbl_admin a
      LEFT JOIN kyc_submissions k ON k.user_id = a.id
      WHERE a.id = ?
      LIMIT 1
    `;

    const rows = await mySqlQury(sql, [userId]);
    if (!rows.length) {
      return res.status(404).json({ ok: false, message: 'User not found.' });
    }

    const r = rows[0];

    // Prefer KYC monthly_parcels code, else adminâ€™s
    const parcelsCode = r.k_monthly_parcels ?? r.a_monthly_parcels;
    const monthly_parcels_bucket_label = parcelBucketLabel(parcelsCode);

    const data = {
      admin: {
        id: r.a_id,
        first_name: r.a_first_name,
        last_name: r.a_last_name,
        email: r.a_email,
        country_code: r.a_country_code,
        phone_no: r.a_phone_no,
        role: r.a_role,
        role_name: r.a_role_name,
        client_name: r.a_client_name,
        client_id: r.a_client_id,
        is_active: r.a_is_active === 1 || r.a_is_active === true,
        user_type: r.a_user_type,
        reporting_user: r.a_reporting_user,
        reporting_id: r.a_reporting_id,
        logo_path: r.a_logo_path,
        company_name: r.a_company_name,
        is_verified: r.a_is_verified === 1 || r.a_is_verified === true,
        is_kyc_verified: r.a_is_kyc_verified === 1 || r.a_is_kyc_verified === true,
        is_kyc_submitted: r.a_is_kyc_submitted === 1 || r.a_is_kyc_submitted === true,
        organization: r.a_organization,
        gst: r.a_gst,
        payment_mode: r.a_payment_mode,
        monthly_parcels: r.a_monthly_parcels,
        company_type: r.a_company_type,
        verify_token: r.a_verify_token,
        exp_volume: r.a_exp_volume,
        parent_id: r.a_parent_id,
        level: r.a_level,
        role_id: r.a_role_id,
      },
      kyc: r.k_id ? {
        id: r.k_id,
        user_id: r.k_user_id,
        email: r.k_email,
        business_type: r.k_business_type,
        sub_type: r.k_sub_type,
        selfie_path: r.k_selfie_path,
        aadhaar_number: r.k_aadhaar_number,
        aadhar_front_doc: r.k_aadhar_front_doc,
        aadhar_back_doc: r.k_aadhar_back_doc,
        pan: {
          name: r.k_pan_name,
          number: r.k_pan_number,
          path: r.k_pan_path,
        },
        gst: {
          number: r.k_gst_number,
          trade_name: r.k_gst_trade_name,
          nature_of_business_activities: r.k_gst_nature_of_business_activities,
          constitution_of_business: r.k_gst_constitution_of_business,
          path: r.k_gst_path,
        },
        company: {
          registered_company_name: r.k_registered_company_name,
          brand_name: r.k_brand_name,
          email: r.k_company_email,
          website: r.k_website,
          type: r.k_company_type,
          organization: r.k_organization,
          reg_number: r.k_company_reg_number,
          reg_doc: r.k_company_reg_doc,
          business_logo_path: r.k_business_logo_path,
          logo_path: r.k_logo_path,
        },
        bank: {
          cancelled_cheque_number: r.k_cancelled_cheque_number,
          cancelled_cheque_doc: r.k_cancelled_cheque_doc,
        },
        monthly_parcels: r.k_monthly_parcels,
        business_volume: r.k_business_volume,
        segment_type: r.k_segment_type,
        created_at: r.k_created_at,
        submitted_at: r.k_submitted_at,
        submission_status: r.k_submission_status,
      } : null,
      derived: {
        monthly_parcels_bucket_label,
      },
    };

    return res.json({ ok: true, data });
  } catch (err) {
    console.error('getClientDataById error:', err);
    return res.status(500).json({ ok: false, message: 'Server error fetching client data.' });
  }
};

// Inline the helper if you don't want a separate file:
function parcelBucketLabel(code) {
  const map = {
    1: "0â€“500",
    2: "500â€“1,000",
    3: "1,000â€“2,000",
    4: "2,000â€“5,000",
    5: "5,000â€“10,000",
    6: "10,000+",
  };
  if (code == null) return null;
  const n = Number(code);
  return map[n] || `Code ${code}`;
}

module.exports = { getClientDataById };


module.exports = { getClientDataById };

const postKycVerify = async (req, res) => {
  const { user_id, status } = req.body;

  // status = 'approved' or 'rejected'
  // updates all related tables

  await mySqlQury('UPDATE tbl_admin SET kyc_status = ? WHERE id = ?', [status, user_id]);
  await mySqlQury('UPDATE kyc_submissions SET submission_status = ? WHERE user_id = ?', [status, user_id]);

  if (status === 'approved') {
    await mySqlQury('UPDATE tbl_admin SET kyc_approved_at = NOW() WHERE id = ?', [user_id]);
  }

  res.json({ success: true });
}
const postClientKycVerification = async (req, res) => {
  try {
    const docNumber = req.body.docNumber;

    const PAN_URL = 'https://www.truthscreen.com/api/v2.2/idsearch';
    const transID = await generateTransID();

    const dataToEncrypt = {
      docNumber,
      docType: 2,
      transID,
    };

    const encryptedData = await encrypt(JSON.stringify(dataToEncrypt));

    if (!encryptedData) {
      console.error("âŒ Failed to encrypt data");
      return res.status(400).json({ error: "Failed to encrypt data" });
    }

    const payload = {
      requestData: encryptedData.toString(),
    };

    const response = await axios.post(PAN_URL, JSON.stringify(payload), {
      headers: {
        username: 'production@dispatch.co.in',
        "Content-Type": "application/json",
      },
    });

    if (!response || !response.data || !response.data.responseData) {
      console.error("âŒ Invalid PAN response");
      return res.status(400).json({ error: "PAN card number is not correct or response is invalid" });
    }

    const decrypted = await decrypt(response.data.responseData);
    const finalData = JSON.parse(decrypted);

    return res.json({ data: finalData });

  } catch (error) {
    // âœ… Robust Axios Error Handling
    if (error.response) {
      console.error("âŒ Axios Error Response:", error.response.data);
      return res.status(error.response.status || 500).json({
        error: "KYC verification failed",
        details: error.response.data
      });
    } else if (error.request) {
      console.error("âŒ Axios No Response Error:", error.request);
      return res.status(500).json({ error: "No response from KYC server" });
    } else {
      console.error("âŒ General Error:", error.message);
      return res.status(500).json({ error: "Something went wrong", message: error.message });
    }
  }
}
function extractUserId(req) {
  const selectedUser =
    req.query?.selectedUser ||
    req.params?.selectedUser ||
    req.body?.selectedUser;

  return selectedUser || null; // return null if not found
}
const postClientGstinVerification = async (req, res) => {
  try {
    const docNumber = req.body.gstNumber?.trim();

    if (!docNumber) {
      return res.status(400).json({ success: false, message: 'GST number is required' });
    }

    const gstin_url = 'https://www.truthscreen.com/api/v2.2/idsearch';
    const transID = await generateTransID();

    const requestPayload = {
      docNumber,
      docType: 23, // 23 represents GST
      transID,
    };

    const encryptedData = await encrypt(JSON.stringify(requestPayload));
    if (!encryptedData) {
      return res.status(500).json({ success: false, message: 'Failed to encrypt request' });
    }

    const apiResponse = await axios.post(gstin_url, JSON.stringify({
      requestData: encryptedData.toString()
    }), {
      headers: {
        username: 'production@dispatch.co.in',
        'Content-Type': 'application/json',
      }
    });

    if (!apiResponse?.data?.responseData) {
      return res.status(400).json({ success: false, message: 'Invalid response from API' });
    }

    const decryptedResponse = await decrypt(apiResponse.data.responseData);
    const finalData = JSON.parse(decryptedResponse);
    console.log("final data",finalData.msg['placeOfBusinessData'][0].address)

    if (finalData.status === 0 || !finalData.msg) {
      return res.status(404).json({ success: false, message: 'GSTIN not found or invalid' });
    }

    const gstin = finalData.msg["GSTIN/ UIN"] || finalData.msg["GSTIN"];
    if (!gstin || docNumber !== gstin) {
      return res.status(400).json({ success: false, message: 'GSTIN mismatch or not found' });
    }

    const tradeName = finalData.msg["Trade Name"] || "";
    const constitution = finalData.msg["ConstitutionOfBusiness"] || "";
    const nature = finalData.msg["NatureOfBusinessActivities"] || "";

    return res.json({
      success: true,
      gstin,
      tradeName,
      constitutionOfBusiness: constitution,
      natureOfBusinessActivities: nature,
      address: finalData.msg['placeOfBusinessData'][0].address,
    });

  } catch (err) {
    console.error('GST Verification Error:', err?.response?.data || err.message);
    return res.status(500).json({ success: false, message: 'Server error during GST verification' });
  }
}


const getRoleManagement = async (req, res) => {
  try {
    let { role, level = 2, selectedClientId: selectedId } = req.user;

    // Fetch roles for the current client context (likely the parent)
    const roles = await mySqlQury('SELECT * FROM roles WHERE client_id = ?', [selectedId]);

    // If current user is level 4 (child/member), derive effective level from the parent
    let effectiveLevel = level;
    if (level === 4 && selectedId) {
      const parentRow = await mySqlQury(
        'SELECT level FROM tbl_admin WHERE id = ? LIMIT 1',
        [selectedId]
      );
      if (parentRow?.length && parentRow[0]?.level) {
        effectiveLevel = parentRow[0].level;
      }
    }

    const { apiRoles, pageRoles } = getRolesByLevel(effectiveLevel);

    res.render('pages/roles-permission', {
      title: 'Dashboard',
      role,
      selectedId,
      roles,
      apiRoles,
      pageRoles
    });
  } catch (error) {
    console.error("Error in /role-management route:", error);
    res.status(500).json({ error: "Internal server error while loading role management page" });
  }
};

const getManageRole = async (req, res) => {
  try {
    const roles = await mySqlQury('SELECT * FROM roles');
    res.render('apps/manage-role', { title: "Manage Roles", roles });
  } catch (error) {
    console.error("Error fetching roles:", error);
    res.status(500).json({ error: "Internal server error" });
  }
}  
const postApiRoles = async (req, res) => {
  try {
    const selectedId  = req.user.selectedClientId;
    const { name } = req.body;
 
    if (!name) {
      return res.status(400).json({ error: 'Role name is required' });
    } 

    // Insert the role
    const query = 'INSERT INTO roles (name, description, client_id) VALUES (?, ?, ?)';
    const results = await mySqlQury(query, [name, '[]', selectedId]);

    return res.status(201).json({ message: 'Role created successfully', results });

  } catch (error) {
    if (error.code === 'ER_DUP_ENTRY' || error.errno === 1062) {
      return res.status(409).json({
        error: 'Duplicate entry',
        message: 'A role with this name already exists.'
      });
    }

    console.error("Error creating role:", error);
    return res.status(500).json({
      error: "Internal server error",
      message: error.sqlMessage || error.message
    });
  }
}
const patchApiRolesid = async (req, res) => {
  try {
    const { id } = req.params;
    const { role, action } = req.body;
    let { selectedClientId } = req.user;
    // Fetch the role to be updated
    const [current] = await mySqlQury('SELECT description, client_id FROM roles WHERE id = ? AND client_id=?', [id, selectedClientId]);
    if (!current) return res.status(404).json({ message: 'Role not found' });

    const currentRoles = roleUtils.parseRoles(current.description);
    let updatedRoles;

    if (action === 'add') {
      // Lookup requested role level
      const requestedMapping = Object.values(mappingRoles).find(r => r.role === role);
      if (!requestedMapping) {
        return res.status(400).json({ error: "Invalid role requested" });
      }

      updatedRoles = roleUtils.addRole(currentRoles, role);

    } else if (action === 'remove') {
      updatedRoles = roleUtils.removeRole(currentRoles, role);
    } else {
      return res.status(400).json({ error: "Invalid action" });
    }

    // Update role in DB
    await mySqlQury('UPDATE roles SET description = ? WHERE id = ? AND client_id=?', [JSON.stringify(updatedRoles), id, selectedClientId]);

    res.json({ id, roles: updatedRoles, message: `Role ${action}ed successfully` });

  } catch (error) {
    console.error("Error updating role:", error);
    res.status(500).json({ error: "Internal server error" });
  }
}
const deleteApiRolesId = async (req, res) => {
  try {
    const { id } = req.params;
    let selectedId = req.user.selectedClientId
    const results = await mySqlQury('DELETE FROM roles WHERE id = ? AND client_id=?', [id, selectedId]);
    res.status(204).send();

  } catch (error) {
    console.error("Error deleting role:", error);
    res.status(500).json({ error: "Internal server error" });
  }
}

const helpDeskReports = async (req, res, next) => {
  try {
    const [loginDetails] = await mySqlQury(
      'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
      [req.user.id]
    );

    if (!loginDetails) {
      return res.status(404).send('User not found');
    }

    let activeTopicIds = []; // Modify or populate based on your application logic
    res.render('apps/helpdesk-reports', { title: 'Metrica', activeTopicIds, loginDetails });
  } catch (error) {
    console.error(error);
    next(error);
  }
}
const helpdeskAgents= async (req, res, next) => {
  try {
    const [loginDetails] = await mySqlQury(
      'SELECT first_name, role_name, company_name, logo_path FROM tbl_admin WHERE id = ?',
      [req.user.id]
    );

    if (!loginDetails) {
      return res.status(404).send('User not found');
    }

    let activeTopicIds = []; // Modify or populate based on your application logic
    res.render('apps/helpdesk-agents', { title: 'Metrica', activeTopicIds, loginDetails });
  } catch (error) {
    console.error(error);
    next(error);
  }
}

// Helper function to get order details for label generation
const getOrderDetailsForLabel = async (orderId, orderType, userId) => {
  try {
    console.log(`ðŸ” getOrderDetailsForLabel called with: orderId=${orderId}, orderType=${orderType}, userId=${userId}`);
    let orderDetails = null;
    
    if (orderType === 'express') {
      // Get Express order details
      const expressOrderQuery = `
        SELECT 
          o.*, 
          lr.lr_no, lr.tagged_api, lr.chargable_weight, lr.volumetric_weight,
          lr.pickup_zone, lr.destination_zone, lr.status as lr_status,
          c.company_name, kyc.logo_path, kyc.gst_number as gstin
        FROM tbl_exp_orders o
        LEFT JOIN tbl_exp_lr lr ON o.id = lr.order_id
        LEFT JOIN tbl_admin c ON o.client_id = c.id
        LEFT JOIN kyc_submissions kyc ON o.client_id = kyc.user_id
        WHERE o.id = ? AND o.client_id = ?
      `;
      const expressOrderResult = await mySqlQury(expressOrderQuery, [orderId, userId]);
      
      if (expressOrderResult.length === 0) {
        console.log(`Express order ${orderId} not found for user ${userId}`);
        return null;
      }
      
      orderDetails = expressOrderResult[0];
      
      // Get box details
      const expressPackageQuery = `SELECT * FROM tbl_exp_boxes_details WHERE order_id = ? ORDER BY id DESC`;
      const expressPackageResult = await mySqlQury(expressPackageQuery, [orderId]);
      orderDetails.allBoxes = expressPackageResult;
      
      // Get consignee details
      const expressConsigneeQuery = `SELECT * FROM tbl_exp_consignee_details WHERE order_id = ?`;
      const expressConsigneeResult = await mySqlQury(expressConsigneeQuery, [orderId]);
      if (expressConsigneeResult.length > 0) {
        orderDetails = { ...orderDetails, ...expressConsigneeResult[0] };
        // Preserve arrays
        orderDetails.allBoxes = expressPackageResult;
      }
      
      // Get product details
      const expressProductQuery = `SELECT * FROM tbl_exp_product_details WHERE order_id = ?`;
      const expressProductResult = await mySqlQury(expressProductQuery, [orderId]);
      orderDetails.allProducts = expressProductResult;
      
      // Get warehouse details for Express order
      if (orderDetails.warehouse_id) {
        console.log(`ðŸ” Looking up warehouse details for warehouse_id: ${orderDetails.warehouse_id}`);
        try {
          const warehouseQuery = `SELECT warehouse_name, warehouse_address,warehouse_city,warehouse_state,warehouse_pincode FROM tbl_add_warehouse WHERE serial = ?`;
          const [warehouseResult] = await mySqlQury(warehouseQuery, [orderDetails.warehouse_id]);
          console.log("Warehouse details for Express:", warehouseResult);
          
          if (warehouseResult) {
            orderDetails.warehouse_name = warehouseResult.warehouse_name;
            orderDetails.warehouse_address = warehouseResult.warehouse_address;
            orderDetails.warehouse_city = warehouseResult.warehouse_city;
            orderDetails.warehouse_state = warehouseResult.warehouse_state;
            orderDetails.warehouse_pincode = warehouseResult.warehouse_pincode;
            console.log("Warehouse info added to orderDetails:", {
              warehouse_name: orderDetails.warehouse_name,
              warehouse_address: orderDetails.warehouse_address
            });
          }
        } catch (error) {
          console.error('Error fetching warehouse details for Express:', error);
        }
      } else {
        console.log(`âš ï¸ No warehouse_id found for Express order ${orderDetails.id}, using company details as fallback`);
      }
      
    } else if (orderType === 'ecom') {
      // Get Ecom order details
      const ecomOrderQuery = `
        SELECT 
          o.*, 
          lr.lr_no, lr.tagged_api, lr.chargable_weight, lr.volumetric_weight,
          lr.pickup_zone, lr.destination_zone, lr.status as lr_status,
          c.company_name, kyc.logo_path, kyc.gst_number as gstin
        FROM tbl_ecom_orders o
        LEFT JOIN tbl_ecom_lr lr ON o.id = lr.order_id
        LEFT JOIN tbl_admin c ON o.client_id = c.id
        LEFT JOIN kyc_submissions kyc ON o.client_id = kyc.user_id
        WHERE o.id = ? AND o.client_id = ?
      `;
      const ecomOrderResult = await mySqlQury(ecomOrderQuery, [orderId, userId]);
      console.log(`ðŸ” Ecom order query result for ${orderId}:`, ecomOrderResult);
      console.log(`ðŸ” Ecom order query:`, ecomOrderQuery);
      console.log(`ðŸ” Ecom order query params:`, [orderId, userId]);
      
      if (ecomOrderResult.length === 0) {
        console.log(`Ecom order ${orderId} not found for user ${userId}`);
        return null;
      }
      
      orderDetails = ecomOrderResult[0];
      
      // Get box details
      const ecomPackageQuery = `SELECT * FROM tbl_ecom_boxes_details WHERE order_id = ? ORDER BY id DESC`;
      const ecomPackageResult = await mySqlQury(ecomPackageQuery, [orderId]);
      orderDetails.allBoxes = ecomPackageResult;
      
      // Get consignee details
      const ecomConsigneeQuery = `SELECT * FROM tbl_ecom_consignee_details WHERE order_id = ?`;
      const ecomConsigneeResult = await mySqlQury(ecomConsigneeQuery, [orderId]);
      if (ecomConsigneeResult.length > 0) {
        orderDetails = { ...orderDetails, ...ecomConsigneeResult[0] };
        // Preserve arrays
        orderDetails.allBoxes = ecomPackageResult;
      }
      
      // Get product details
      const ecomProductQuery = `SELECT * FROM tbl_ecom_product_details WHERE order_id = ?`;
      const ecomProductResult = await mySqlQury(ecomProductQuery, [orderId]);
      orderDetails.allProducts = ecomProductResult;
      
      // Get warehouse details for Ecom order
      if (orderDetails.warehouse_id) {
        console.log(`ðŸ” Looking up warehouse details for warehouse_id: ${orderDetails.warehouse_id}`);
        try {
          const warehouseQuery = `SELECT warehouse_name, warehouse_address,warehouse_city,warehouse_state,warehouse_pincode FROM tbl_add_warehouse WHERE serial = ?`;
          const [warehouseResult] = await mySqlQury(warehouseQuery, [orderDetails.warehouse_id]);
          console.log("Warehouse details for Ecom:", warehouseResult);
          
          if (warehouseResult) {
            orderDetails.warehouse_name = warehouseResult.warehouse_name;
            orderDetails.warehouse_address = warehouseResult.warehouse_address;
            orderDetails.warehouse_city = warehouseResult.warehouse_city;
            orderDetails.warehouse_state = warehouseResult.warehouse_state;
            orderDetails.warehouse_pincode = warehouseResult.warehouse_pincode;
            console.log("Warehouse info added to orderDetails:", {
              warehouse_name: orderDetails.warehouse_name,
              warehouse_address: orderDetails.warehouse_address
            });
          }
        } catch (error) {
          console.error('Error fetching warehouse details for Ecom:', error);
        }
      } else {
        console.log(`âš ï¸ No warehouse_id found for Ecom order ${orderDetails.id}, using company details as fallback`);
      }
    }
    
    console.log(`ðŸ” Final order details being returned for ${orderId}:`, orderDetails);
    console.log(`ðŸ” Final order details keys for ${orderId}:`, Object.keys(orderDetails));
    
    return orderDetails;
    
  } catch (error) {
    console.error(`Error getting order details for ${orderId}:`, error);
    return null;
  }
};

// Smart Bulk Label Processing Function
const processBulkLabels = async (req, res) => {
  try {
    const { bulkOrderIds, labelSize = 'A4', orderType = 'express' } = req.query;
    const userId = req.user?.selectedClientId;
    
    if (!bulkOrderIds) {
      return res.status(400).json({
        success: false,
        message: 'Bulk order IDs are required'
      });
    }
    
    if (!userId) {
      return res.status(400).json({
        success: false,
        message: 'User ID not found'
      });
    }
    
    // Parse bulk order IDs
    const orderIds = bulkOrderIds.split(',').map(id => id.trim()).filter(id => id);
    
    if (orderIds.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'No valid order IDs provided'
      });
    }
    
    console.log(`ðŸ”„ Processing bulk labels for ${orderIds.length} orders`);
    console.log(`   Label Size: ${labelSize}`);
    console.log(`   Order Type: ${orderType}`);
    console.log(`   User ID: ${userId}`);
    
    // Get user preferences
    const preferencesQuery = `
      SELECT * FROM tbl_user_shipping_label_preferences 
      WHERE user_id = ?
    `;
    const [userPreferences] = await mySqlQury(preferencesQuery, [userId]);
    
    if (!userPreferences) {
      return res.status(404).json({
        success: false,
        message: 'Shipping label preferences not found for this user'
      });
    }
    
    // Create directory structure for labels
    const labelsDir = path.join(__dirname, '..', 'public', 'shipping-labels');
    const orderTypeDir = path.join(labelsDir, orderType);
    const labelSizeDir = path.join(orderTypeDir, labelSize);
    
    // Ensure directories exist
    if (!fs.existsSync(labelsDir)) fs.mkdirSync(labelsDir, { recursive: true });
    if (!fs.existsSync(orderTypeDir)) fs.mkdirSync(orderTypeDir, { recursive: true });
    if (!fs.existsSync(labelSizeDir)) fs.mkdirSync(labelSizeDir, { recursive: true });
    
    const allLabelsHTML = [];
    let existingLabelsCount = 0;
    let newLabelsCount = 0;
    
          // Process each order
      for (let i = 0; i < orderIds.length; i++) {
        const orderId = orderIds[i];
        console.log(`ðŸ“„ Processing order ${i + 1}/${orderIds.length}: ${orderId}`);
        
        try {
                  // Get order details first
        const orderDetails = await getOrderDetailsForLabel(orderId, orderType, userId);
        if (!orderDetails) {
          console.warn(`âš ï¸ Order ${orderId} not found, skipping...`);
          continue;
        }
        
        // Check if label already exists by LR number in the appropriate folder
        const lrNumber = orderDetails.lr_no || orderId;
        const fileName = `label-${lrNumber}-${labelSize}.pdf`;
        const filePath = path.join(labelSizeDir, fileName);
        
        console.log(`ðŸ” Checking for existing label: ${fileName}`);
        console.log(`ðŸ” LR Number: ${lrNumber}, Order ID: ${orderId}`);
        console.log(`ðŸ” Looking in folder: ${labelSizeDir}`);
        
        if (fs.existsSync(filePath)) {
          console.log(`âœ… Label already exists for LR ${lrNumber}, using existing file`);
          existingLabelsCount++;
          
          try {
            const htmlContent = generateShippingLabelHTML({
              order: orderDetails,
              product: orderDetails.allProducts && orderDetails.allProducts.length > 0 ? orderDetails.allProducts[0] : null,
              preferences: userPreferences,
              labelSize: labelSize,
              orderType: orderType
            });
            console.log(`ðŸ“„ HTML regenerated for existing label ${lrNumber}, length:`, htmlContent.length);
            allLabelsHTML.push(htmlContent);
          } catch (error) {
            console.error(`âš ï¸ Error processing existing label for LR ${lrNumber}:`, error);
            // Continue with next order
          }
        } else {
          console.log(`ðŸ†• Generating new label for LR ${lrNumber}`);
          newLabelsCount++;
          
          // Generate new label HTML AND save individual PDF for future use
          try {
            const htmlContent = generateShippingLabelHTML({
              order: orderDetails,
              product: orderDetails.allProducts && orderDetails.allProducts.length > 0 ? orderDetails.allProducts[0] : null,
              preferences: userPreferences,
              labelSize: labelSize,
              orderType: orderType
            });
            console.log(`ðŸ“„ HTML generated for new label ${lrNumber}, length:`, htmlContent.length);
            allLabelsHTML.push(htmlContent);
            
            // Save individual PDF for future use (so next time it's found immediately)
            try {
              const pdfBuffer = await convertHTMLToPDF(htmlContent);
              await fs.promises.writeFile(filePath, pdfBuffer);
              console.log(`ðŸ’¾ Saved individual label for LR ${lrNumber} at: ${filePath}`);
              console.log(`ðŸ’¾ Future bulk downloads will find this label immediately!`);
            } catch (saveError) {
              console.error(`âš ï¸ Could not save individual PDF for LR ${lrNumber}:`, saveError);
              // Continue anyway - the label is still added to the merge
            }
            
          } catch (error) {
            console.error(`âŒ Error generating label for LR ${lrNumber}:`, error);
            // Continue with next order
          }
        }
        } catch (error) {
          console.error(`âŒ Error processing order ${orderId}:`, error);
          // Continue with next order
        }
      }
    
    if (allLabelsHTML.length === 0) {
      throw new Error('No valid orders found to process');
    }
    
                 console.log(`ðŸ“Š Label processing summary:`);
             console.log(`   Total orders: ${orderIds.length}`);
             console.log(`   Existing labels found: ${existingLabelsCount}`);
             console.log(`   New labels generated: ${newLabelsCount}`);
             console.log(`   Total labels ready for merge: ${allLabelsHTML.length}`);
             console.log(`   Note: New labels saved individually for future fast access!`);
    
    // Create individual pages for each label with correct dimensions
    console.log(`ðŸ”— Creating individual pages for each label with ${allLabelsHTML.length} labels...`);
    
    // Validate HTML content
    allLabelsHTML.forEach((html, index) => {
      console.log(`ðŸ“„ Label ${index + 1} HTML length:`, html.length);
      if (html.length < 100) {
        console.warn(`âš ï¸ Label ${index + 1} HTML seems too short:`, html.substring(0, 200));
      }
    });
    
    // Generate individual PDFs for each label and then merge them
    console.log(`ðŸ”— Generating individual PDFs for ${allLabelsHTML.length} labels...`);
    
    try {
      // Generate individual PDFs first
      const individualPdfs = [];
      
      // We need to track which order each label belongs to
      // Let's create a mapping of order IDs to their HTML content
      const orderLabelMapping = [];
      
      // Re-generate the HTML for each order to ensure warehouse details are fresh
      for (let i = 0; i < orderIds.length; i++) {
        const orderId = orderIds[i];
        
        try {
          // Get fresh order details
          const orderDetails = await getOrderDetailsForLabel(orderId, orderType, userId);
          
          if (orderDetails) {
            // Generate fresh HTML with warehouse details
            const freshHTML = generateShippingLabelHTML({
              order: orderDetails,
              product: orderDetails.allProducts && orderDetails.allProducts.length > 0 ? orderDetails.allProducts[0] : null,
              preferences: userPreferences,
              labelSize: labelSize,
              orderType: orderType
            });
            
            orderLabelMapping.push({
              orderId: orderId,
              lrNumber: orderDetails.lr_no || orderId,
              html: freshHTML
            });
            
            console.log(`ðŸ“„ Fresh HTML generated for order ${orderId}, length:`, freshHTML.length);
          }
        } catch (error) {
          console.error(`âŒ Error generating fresh HTML for order ${orderId}:`, error);
          // Use existing HTML as fallback
          if (allLabelsHTML[i]) {
            orderLabelMapping.push({
              orderId: orderId,
              lrNumber: `fallback-${i + 1}`,
              html: allLabelsHTML[i]
            });
          }
        }
      }
      
      // Now generate PDFs from fresh HTML
      for (let i = 0; i < orderLabelMapping.length; i++) {
        const { orderId, lrNumber, html } = orderLabelMapping[i];
        
        if (html) {
          console.log(`ðŸ“„ Generating PDF for order ${orderId} (LR: ${lrNumber})...`);
          
          // Create individual HTML document for each label
          const individualHTML = `
            <!DOCTYPE html>
            <html>
            <head>
              <meta charset="UTF-8">
              <title>Label ${i + 1} - ${orderType.toUpperCase()} - ${labelSize}</title>
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <style>
                body { 
                  margin: 0; 
                  padding: 0; 
                  background: white;
                  font-family: Arial, sans-serif;
                  display: flex;
                  justify-content: center;
                  align-items: center;
                  min-height: 100vh;
                }
                .label-container {
                  display: flex;
                  justify-content: center;
                  align-items: center;
                  width: 100%;
                  height: 100%;
                }
              </style>
            </head>
            <body>
              <div class="label-container">
                ${html}
              </div>
            </body>
            </html>
          `;
          
          // Generate individual PDF
          const individualPdf = await convertHTMLToPDF(individualHTML, labelSize);
          individualPdfs.push(individualPdf);
          
          // Save individual PDF to folder for future use
          try {
            const fileName = `label-${lrNumber}-${labelSize}.pdf`;
            const filePath = path.join(labelSizeDir, fileName);
            
            await fs.promises.writeFile(filePath, individualPdf);
            console.log(`ðŸ’¾ Saved individual PDF for LR ${lrNumber} at: ${filePath}`);
          } catch (saveError) {
            console.error(`âš ï¸ Could not save individual PDF for LR ${lrNumber}:`, saveError);
            // Continue anyway - the PDF is still added to the merge
          }
          
          console.log(`âœ… PDF generated for order ${orderId}, size: ${individualPdf.length} bytes`);
        }
      }
      
      console.log(`ðŸ“Š Generated ${individualPdfs.length} individual PDFs`);
      
      // Merge all individual PDFs into one
      console.log(`ðŸ”— Merging ${individualPdfs.length} PDFs into one...`);
      
      try {
        const { PDFDocument } = require('pdf-lib');
        
        // Create a new PDF document
        const mergedPdf = await PDFDocument.create();
        
        // Add each individual PDF to the merged document
        for (let i = 0; i < individualPdfs.length; i++) {
          const individualPdf = individualPdfs[i];
          console.log(`ðŸ“„ Adding PDF ${i + 1} to merged document...`);
          
          // Load the individual PDF
          const individualPdfDoc = await PDFDocument.load(individualPdf);
          
          // Copy all pages from the individual PDF
          const pages = await mergedPdf.copyPages(individualPdfDoc, individualPdfDoc.getPageIndices());
          
          // Add each page to the merged PDF
          pages.forEach(page => mergedPdf.addPage(page));
          
          console.log(`âœ… Added PDF ${i + 1} to merged document`);
        }
        
        // Save the merged PDF
        const mergedPdfBytes = await mergedPdf.save();
        bulkHTML = Buffer.from(mergedPdfBytes);
        
        console.log(`ðŸŽ‰ Successfully merged ${individualPdfs.length} PDFs into one`);
        console.log(`ðŸ“„ Final merged PDF size: ${bulkHTML.length} bytes`);
        
      } catch (mergeError) {
        console.error('âŒ Error merging PDFs:', mergeError);
        console.log('ðŸ”„ Falling back to first PDF only...');
        bulkHTML = individualPdfs[0]; // Fallback to first PDF if merging fails
      }
      
    } catch (error) {
      console.error('âŒ Error generating individual PDFs:', error);
      throw new Error(`Failed to generate individual PDFs: ${error.message}`);
    }
    
    console.log(`ðŸ“„ Final bulk PDF size:`, bulkHTML.length, 'bytes');
    
    // bulkHTML is now already a PDF buffer, no need to convert
    console.log("ðŸ”„ Bulk PDF already generated, no conversion needed");
    
    try {
      const finalPdfBuffer = bulkHTML; // Already a PDF buffer
      
      if (!finalPdfBuffer || finalPdfBuffer.length === 0) {
        throw new Error('PDF buffer is empty or null');
      }
      
      // Ensure we have a proper Buffer
      let pdfBuffer = finalPdfBuffer;
      if (!Buffer.isBuffer(finalPdfBuffer)) {
        console.log('ðŸ”„ Converting PDF buffer to proper Buffer...');
        pdfBuffer = Buffer.from(finalPdfBuffer);
      }
      
      // Validate PDF buffer
      if (pdfBuffer.length < 100) {
        throw new Error(`PDF buffer too small: ${pdfBuffer.length} bytes (expected > 100 bytes)`);
      }
      
      // Check if it starts with PDF header
      const pdfHeader = pdfBuffer.toString('ascii', 0, 4);
      if (pdfHeader !== '%PDF') {
        console.warn('âš ï¸ PDF buffer does not start with %PDF header:', pdfHeader);
      }
      
      // Generate final filename
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
      const finalFileName = `bulk-labels-${orderType}-${labelSize}-${timestamp}.pdf`;
      
      console.log(`ðŸŽ‰ Bulk label generation completed successfully!`);
      console.log(`   Total orders processed: ${allLabelsHTML.length}`);
      console.log(`   Final PDF size: ${(pdfBuffer.length / 1024).toFixed(2)} KB`);
      console.log(`   PDF buffer type: ${typeof pdfBuffer}`);
      console.log(`   PDF buffer is Buffer: ${Buffer.isBuffer(pdfBuffer)}`);
      console.log(`   PDF header: ${pdfHeader}`);
      
      // Return merged PDF
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${finalFileName}"`);
      res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
      res.setHeader('Pragma', 'no-cache');
      res.setHeader('Expires', '0');
      res.setHeader('Content-Length', pdfBuffer.length);
      
      console.log("ðŸ“¤ Sending PDF response...");
      res.send(pdfBuffer);
      
    } catch (pdfError) {
      console.error('âŒ PDF generation failed:', pdfError);
      
      // Try to create a simple test PDF as fallback
      try {
        console.log('ðŸ”„ Attempting fallback PDF generation...');
        const testHtml = `
          <!DOCTYPE html>
          <html>
          <head>
            <title>Test PDF</title>
            <style>body{font-family:Arial;padding:20px;}</style>
          </head>
          <body>
            <h1>Test PDF Generation</h1>
            <p>This is a test PDF to verify the system is working.</p>
            <p>Error: ${pdfError.message}</p>
          </body>
          </html>
        `;
        
        const testPdfBuffer = await convertHTMLToPDF(testHtml);
        console.log('âœ… Fallback PDF generated successfully, size:', testPdfBuffer.length);
        
        // Return the test PDF
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const finalFileName = `test-pdf-${timestamp}.pdf`;
        
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="${finalFileName}"`);
        res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
        res.setHeader('Pragma', 'no-cache');
        res.setHeader('Expires', '0');
        res.setHeader('Content-Length', testPdfBuffer.length);
        
        console.log("ðŸ“¤ Sending fallback PDF response...");
        res.send(testPdfBuffer);
        return;
        
      } catch (fallbackError) {
        console.error('âŒ Fallback PDF generation also failed:', fallbackError);
        throw new Error(`PDF generation failed: ${pdfError.message}. Fallback also failed: ${fallbackError.message}`);
      }
    }
    
  } catch (error) {
    console.error('âŒ Error in bulk label generation:', error);
    
    return res.status(500).json({
      success: false,
      message: 'Failed to generate bulk shipping labels',
      error: error.message
    });
  }
};




//deepanshu



const postCustomerUpdate = async (req, res) => {
  try {
    const {
      order_id,
      name,
      email,
      phone,
      status,
      address_line1,
      address_line2,
      landmark,
      country,
      state,
      city,
      pincode
    } = req.body;

    // Validate required fields
    if (!order_id) {
      return res.status(400).json({
        ok: false,
        error: 'order_id is required'
      });
    }

    // Update address in tbl_exp_consignee_details
    let updateData = {};
   
    // Split name into first and last name (if provided)
    if (name) {
      const nameParts = name.trim().split(' ');
      updateData.first_name = nameParts[0] || '';
      updateData.last_name = nameParts.slice(1).join(' ') || '';
    }
   
    if (email) updateData.email = email;
    if (phone) updateData.phone = phone;
   
    // Update address fields
    if (address_line1) updateData.address_line1 = address_line1;
    if (address_line2) updateData.address_line2 = address_line2;
    if (landmark) updateData.landmark = landmark;
    if (country) updateData.country = country;
    if (state) updateData.state = state;
    if (city) updateData.city = city;
    if (pincode) updateData.pincode = pincode;

    // Check if any data was provided to update
    if (Object.keys(updateData).length === 0) {
      return res.status(400).json({
        ok: false,
        error: 'No update data provided'
      });
    }

    // Update the record in tbl_exp_consignee_details
    const [affectedRows] = await ConsigneeDetails.update(updateData, {
      where: { order_id: order_id }
    });

    if (affectedRows === 0) {
      return res.status(404).json({
        ok: false,
        error: 'Order not found'
      });
    }

    res.status(200).json({
      ok: true,
      message: 'Customer address updated successfully',
      data: {
        order_id,
        ...updateData
      }
    });

  } catch (error) {
    console.error('Error updating customer address:', error);
    res.status(500).json({
      ok: false,
      error: 'Internal server error',
      message: error.message
    });
  }
};


const postCustomerUpdateEcom = async (req, res) => {
  try {
    const {
      order_id,
      name,
      email,
      phone,
      status,
      address_line1,
      address_line2,
      landmark,
      country,
      state,
      city,
      pincode
    } = req.body;

    // Validate required fields
    if (!order_id) {
      return res.status(400).json({
        ok: false,
        error: 'order_id is required'
      });
    }

    // Update address in tbl_exp_consignee_details
    let updateData = {};
   
    // Split name into first and last name (if provided)
    if (name) {
      const nameParts = name.trim().split(' ');
      updateData.first_name = nameParts[0] || '';
      updateData.last_name = nameParts.slice(1).join(' ') || '';
    }
   
    if (email) updateData.email = email;
    if (phone) updateData.phone = phone;
   
    // Update address fields
    if (address_line1) updateData.address_line1 = address_line1;
    if (address_line2) updateData.address_line2 = address_line2;
    if (landmark) updateData.landmark = landmark;
    if (country) updateData.country = country;
    if (state) updateData.state = state;
    if (city) updateData.city = city;
    if (pincode) updateData.pincode = pincode;

    // Check if any data was provided to update
    if (Object.keys(updateData).length === 0) {
      return res.status(400).json({
        ok: false,
        error: 'No update data provided'
      });
    }

    // Update the record in tbl_exp_consignee_details
    const [affectedRows] = await EcomConsigneeDetails.update(updateData, {
      where: { order_id: order_id }
    });

    if (affectedRows === 0) {
      return res.status(404).json({
        ok: false,
        error: 'Order not found'
      });
    }

    res.status(200).json({
      ok: true,
      message: 'Customer address updated successfully',
      data: {
        order_id,
        ...updateData
      }
    });

  } catch (error) {
    console.error('Error updating customer address:', error);
    res.status(500).json({
      ok: false,
      error: 'Internal server error',
      message: error.message
    });
  }
};

async function ecomCall(req, res) {
  try {
    const {
      order_id,
      name,
      phone_no,
      company_name,
      call_connected,
      not_connected_reason,
      customer_response,
    } = req.body;

    if (!order_id || !call_connected) {
      return res.status(400).json({
        ok: false,
        error: "order_id and call_connected are required",
      });
    }

    // ðŸ”¹ Try to find existing log for this order
    const [log, created] = await Callecom.findOrCreate({
      where: { order_id },
      defaults: {
        name,
        phone_no,
        company_name: company_name || null,
        call_connected,
        not_connected_reason: call_connected === "no" ? not_connected_reason : null,
        customer_response: call_connected === "yes" ? customer_response : null,
      },
    });

    if (!created) {
      await log.update({
        name,
        phone_no,
        company_name: company_name || null,
        call_connected,
        not_connected_reason: call_connected === "no" ? not_connected_reason : null,
        customer_response: call_connected === "yes" ? customer_response : null,
      });
    }

    return res.status(201).json({
      ok: true,
      message: "Call log saved successfully",
      data: log,
    });
  } catch (err) {
    console.error("âŒ [ecomCall] Error:", err);
    return res.status(500).json({
      ok: false,
      error: err.message || "Server error",
    });
  }
}


async function saveCustomerNotAvailable(req, res) {
  try {
    const { start_msg, true_msg, false_msg, confirm_msg, time_options } = req.body;

    const [flow, created] = await AutomationFlow.findOrCreate({
      where: { flow_name: "customer_not_available" },
      defaults: { start_msg, true_msg, false_msg, confirm_msg, time_options },
    });

    if (!created) {
      await flow.update({ start_msg, true_msg, false_msg, confirm_msg, time_options });
    }

    return res.status(201).json({
      ok: true,
      message: "Automation flow saved successfully",
      data: flow,
    });
  } catch (err) {
    console.error("âŒ [saveCustomerNotAvailable] Error:", err);
    return res.status(500).json({
      ok: false,
      error: err.message || "Server error",
    });
  }
}

// Fetch Flow
async function getCustomerNotAvailable(req, res) {
  try {
    const flow = await AutomationFlow.findOne({
      where: { flow_name: "customer_not_available" },
    });

    if (!flow) {
      return res.status(404).json({
        ok: false,
        message: "Flow not found",
      });
    }

    return res.status(200).json({
      ok: true,
      data: flow,
    });
  } catch (err) {
    console.error("âŒ [getCustomerNotAvailable] Error:", err);
    return res.status(500).json({
      ok: false,
      error: err.message || "Server error",
    });
  }
}


async function createIbr(req, res) {
  try {
    const { text } = req.body;

    // Store relative paths
    const screenshot = req.files?.screenshot?.[0]
      ? path.join("uploads/ibr", req.files.screenshot[0].filename)
      : null;

    const voice = req.files?.voice?.[0]
      ? path.join("uploads/ibr", req.files.voice[0].filename)
      : null;

    // Save to DB
    const newIbr = await Ibr.create({
      screenshot,
      voice,
      text,
    });

    return res.status(201).json({
      ok: true,
      message: "IBR entry created",
      data: newIbr,
    });
  } catch (err) {
    console.error("âŒ [createIbr] Error:", err);
    return res.status(500).json({
      ok: false,
      error: err.message || "Server error",
    });
  }
}




const getCustomerUpdates = async (req, res) => {
  try {
    const updates = await UpdatedCustomerDetail.findAll({
      order: [['created_at', 'DESC']] // latest first
    });

    res.status(200).json({
      ok: true,
      total: updates.length,
      data: updates
    });
  } catch (error) {
    console.error('Error fetching customer updates:', error);
    res.status(500).json({ ok: false, error: 'Internal server error' });
  }
};

// const postCustomerUpdate = async (req, res) => {
//   try {
//     const {
//       order_id,
//       name,
//       email,
//       phone,
//       status,
//       address_line1,
//       address_line2,
//       landmark,
//       country,
//       state,
//       city,
//       pincode
//     } = req.body;

//     // Validate required fields
//     if (!order_id) {
//       return res.status(400).json({
//         ok: false,
//         error: 'order_id is required'
//       });
//     }

//     // Update address in tbl_exp_consignee_details
//     let updateData = {};
   
//     // Split name into first and last name (if provided)
//     if (name) {
//       const nameParts = name.trim().split(' ');
//       updateData.first_name = nameParts[0] || '';
//       updateData.last_name = nameParts.slice(1).join(' ') || '';
//     }
   
//     if (email) updateData.email = email;
//     if (phone) updateData.phone = phone;
   
//     // Update address fields
//     if (address_line1) updateData.address_line1 = address_line1;
//     if (address_line2) updateData.address_line2 = address_line2;
//     if (landmark) updateData.landmark = landmark;
//     if (country) updateData.country = country;
//     if (state) updateData.state = state;
//     if (city) updateData.city = city;
//     if (pincode) updateData.pincode = pincode;

//     // Check if any data was provided to update
//     if (Object.keys(updateData).length === 0) {
//       return res.status(400).json({
//         ok: false,
//         error: 'No update data provided'
//       });
//     }

//     // Update the record in tbl_exp_consignee_details
//     const [affectedRows] = await ConsigneeDetails.update(updateData, {
//       where: { order_id: order_id }
//     });

//     if (affectedRows === 0) {
//       return res.status(404).json({
//         ok: false,
//         error: 'Order not found'
//       });
//     }

//     res.status(200).json({
//       ok: true,
//       message: 'Customer address updated successfully',
//       data: {
//         order_id,
//         ...updateData
//       }
//     });

//   } catch (error) {
//     console.error('Error updating customer address:', error);
//     res.status(500).json({
//       ok: false,
//       error: 'Internal server error',
//       message: error.message
//     });
//   }
// };


// const postCustomerUpdateEcom = async (req, res) => {
//   try {
//     const {
//       order_id,
//       name,
//       email,
//       phone,
//       status,
//       address_line1,
//       address_line2,
//       landmark,
//       country,
//       state,
//       city,
//       pincode
//     } = req.body;

//     // Validate required fields
//     if (!order_id) {
//       return res.status(400).json({
//         ok: false,
//         error: 'order_id is required'
//       });
//     }

//     // Update address in tbl_exp_consignee_details
//     let updateData = {};
   
//     // Split name into first and last name (if provided)
//     if (name) {
//       const nameParts = name.trim().split(' ');
//       updateData.first_name = nameParts[0] || '';
//       updateData.last_name = nameParts.slice(1).join(' ') || '';
//     }
   
//     if (email) updateData.email = email;
//     if (phone) updateData.phone = phone;
   
//     // Update address fields
//     if (address_line1) updateData.address_line1 = address_line1;
//     if (address_line2) updateData.address_line2 = address_line2;
//     if (landmark) updateData.landmark = landmark;
//     if (country) updateData.country = country;
//     if (state) updateData.state = state;
//     if (city) updateData.city = city;
//     if (pincode) updateData.pincode = pincode;

//     // Check if any data was provided to update
//     if (Object.keys(updateData).length === 0) {
//       return res.status(400).json({
//         ok: false,
//         error: 'No update data provided'
//       });
//     }

//     // Update the record in tbl_exp_consignee_details
//     const [affectedRows] = await EcomConsigneeDetails.update(updateData, {
//       where: { order_id: order_id }
//     });

//     if (affectedRows === 0) {
//       return res.status(404).json({
//         ok: false,
//         error: 'Order not found'
//       });
//     }

//     res.status(200).json({
//       ok: true,
//       message: 'Customer address updated successfully',
//       data: {
//         order_id,
//         ...updateData
//       }
//     });

//   } catch (error) {
//     console.error('Error updating customer address:', error);
//     res.status(500).json({
//       ok: false,
//       error: 'Internal server error',
//       message: error.message
//     });
//   }
// };



async function sendWhatsAppVerification(req, res) {
  try {
    const payload = req.body;

    if (!payload || !payload.phoneNumber || !payload.template?.name) {
      return res.status(400).json({ ok: false, error: "Missing required fields" });
    }

    const response = await axios.post(
      "https://api.interakt.ai/v1/public/message/",
      payload,
      {
        headers: {
          "Authorization": `Basic ${process.env.WHATS_APP_API}`,
          "Content-Type": "application/json"
        }
      }
    );

    return res.json({ ok: true, data: response.data });
  } catch (err) {
    console.error("âŒ [sendWhatsAppVerification] Error:", err.response?.data || err.message);
    return res.status(500).json({ ok: false, error: err.response?.data || err.message });
  }
}


async function addNdrReason(req, res) {
  try {
    const { order_id, reason } = req.body;

    if (!order_id || !reason) {
      return res.status(400).json({ ok: false, error: "Missing fields" });
    }

    const newReason = await NdrReason.create({
      order_id,
      reason
    });

    return res.json({ ok: true, data: newReason });
  } catch (err) {
    console.error("âŒ [addNdrReason] Error:", err);
    return res.status(500).json({ ok: false, error: err.message });
  }
}


async function getNdrHistory(req, res) {
  try {
    const { order_id } = req.query;

    if (!order_id) {
      return res.status(400).json({ ok: false, error: "Missing fields" });
    }

    const history = await NdrReason.findAll({
      where: { order_id},
      order: [["created_at", "DESC"]]
    });

    return res.json({
      ok: true,
      data: history
    });
  } catch (err) {
    console.error("âŒ [getNdrHistory] Error:", err);
    return res.status(500).json({ ok: false, error: err.message });
  }
}

async function getNdrHistoryexp(req, res) {
  try {
    const { order_id } = req.query;

    const whereClause = {};
    if (order_id) {
      whereClause.order_id = order_id;
    }

    const history = await ExpNdrReason.findAll({
      where: whereClause,
      order: [["created_at", "DESC"]],
      include: [
        {
          model: ExpOrders,
          as: "order",   // must match ExpNdrReason.belongsTo(ExpOrders, { as: "order" })
          include: [
            { model: ConsigneeDetails, as: "consignee" },  
            { model: ExpLR, as: "exp_lrs" },              
            { model: ExpProductDetails, as: "products" },  
            { model: Admin, as: "client" }                  
          ]
        }
      ]
    });

    return res.json({
      ok: true,
      data: history
    });
  } catch (err) {
    console.error("âŒ [getNdrHistoryexp] Error:", err);
    return res.status(500).json({ ok: false, error: err.message });
  }
}




async function getNdrHistoryecom(req, res) {
  try {
    const { order_id } = req.query;

    let whereClause = {};
    if (order_id) {
      whereClause.order_id = order_id;
    }

    const history = await EcomNdrReason.findAll({
      where: whereClause,
      order: [["created_at", "DESC"]],
      include: [
        {
          model: EcomOrders,
          as: "order",
          include: [
            { model: EcomConsigneeDetails, as: "consignee" },
            { model: EcomLR, as: "ecom_lrs" },
            { model: EcomProductDetails, as: "products" },
            { model: Admin, as: "client" }
          ]
        }
      ]
    });

    return res.json({
      ok: true,
      data: history
    });
  } catch (err) {
    console.error("âŒ [getNdrHistoryecom] Error:", err);
    return res.status(500).json({ ok: false, error: err.message });
  }
}



async function getNdrActionsecom(req, res) {
  try {

    const [escalations, rtos, reattempts] = await Promise.all([
      TblEscalationEcom.findAll({ order: [["created_at", "DESC"]] }),
      TblRtoRequestsecom.findAll({ order: [["created_at", "DESC"]] }),
      TblDeliveryReattemptsEcom.findAll({ order: [["created_at", "DESC"]] }),
    ]);


    return res.json({
      ok: true,
      data: {
        escalations,
        rtos,
        reattempts,
      },
    });
  } catch (err) {
    console.error("âŒ [getNdrActions] Error:", err);
    return res.status(500).json({ ok: false, error: err.message });
  }
}


async function getNdrActions(req, res) {
  try {

    const [escalations, rtos, reattempts] = await Promise.all([
      TblEscalation.findAll({ order: [["created_at", "DESC"]] }),
      TblRtoRequests.findAll({ order: [["created_at", "DESC"]] }),
      TblDeliveryReattempts.findAll({ order: [["created_at", "DESC"]] }),
    ]);


    return res.json({
      ok: true,
      data: {
        escalations,
        rtos,
        reattempts,
      },
    });
  } catch (err) {
    console.error("âŒ [getNdrActions] Error:", err);
    return res.status(500).json({ ok: false, error: err.message });
  }
}




async function createReattempt(req, res) {
  try {
   

    // 1) Extract payload
    const {
      order_id,
      reason,
      reason_incorrect,    // frontend boolean
      request_reattempt,   // frontend boolean
      reattempted_date,
      phone,
      landmark,
      address1,
      address2,
      city,
      state,
      pin_code,
      remarks
    } = req.body;

 
    // 2) Save to DB (map fields to DB column names)
    const newReattempt = await TblDeliveryReattempts.create({
      order_id,
      reason,
      is_reason_incorrect: reason_incorrect ? 1 : 0,
      request_for_reattempt: request_reattempt ? 1 : 0,
      reattempted_date,
      phone,
      landmark,
      address_line1: address1,
      address_line2: address2,
      city,
      state,
      pincode: pin_code,
      remarks
    });

    // 3) Response
    return res.json({ ok: true, data: newReattempt });

  } catch (err) {
    // 4) Error Handling
    return res.status(500).json({ ok: false, error: err.message });
  }
}


async function createReattemptecom(req, res) {
  try {
   

    // 1) Extract payload
    const {
      order_id,
      reason,
      reason_incorrect,    // frontend boolean
      request_reattempt,   // frontend boolean
      reattempted_date,
      phone,
      landmark,
      address1,
      address2,
      city,
      state,
      pin_code,
      remarks
    } = req.body;

 
    // 2) Save to DB (map fields to DB column names)
    const newReattempt = await TblDeliveryReattemptsEcom.create({
      order_id,
      reason,
      is_reason_incorrect: reason_incorrect ? 1 : 0,
      request_for_reattempt: request_reattempt ? 1 : 0,
      reattempted_date,
      phone,
      landmark,
      address_line1: address1,
      address_line2: address2,
      city,
      state,
      pincode: pin_code,
      remarks
    });

    // 3) Response
    return res.json({ ok: true, data: newReattempt });

  } catch (err) {
    // 4) Error Handling
    return res.status(500).json({ ok: false, error: err.message });
  }
}


async function createRto(req, res) {
  try {
   

    const { order_id, product, payment_mode, pending_days, remarks } = req.body;

    if (!remarks) {
      return res.status(400).json({ ok: false, error: "Remarks are required" });
    }

    const newRto = await TblRtoRequests.create({
      order_id,
      product,
      payment_mode,
      pending_since: pending_days,
      remarks
    });

    return res.json({ ok: true, data: newRto });
  } catch (err) {
    return res.status(500).json({ ok: false, error: err.message });
  }
}


async function createRtoecom(req, res) {
  try {
   

    const { order_id, product, payment_mode, pending_days, remarks } = req.body;

    if (!remarks) {
      return res.status(400).json({ ok: false, error: "Remarks are required" });
    }

    const newRto = await TblRtoRequestsecom.create({
      order_id,
      product,
      payment_mode,
      pending_since: pending_days,
      remarks
    });

    return res.json({ ok: true, data: newRto });
  } catch (err) {
    return res.status(500).json({ ok: false, error: err.message });
  }
}



async function createEscalation(req, res) {
  try {
   

    const { order_id, reason, remarks } = req.body;

    if (!order_id || !reason || !remarks) {
      return res.status(400).json({ ok: false, error: "order_id, reason and remarks are required" });
    }

    const newEscalation = await TblEscalation.create({
      order_id,
      reason,
      remarks
    });


    return res.json({ ok: true, data: newEscalation });
  } catch (err) {
    return res.status(500).json({ ok: false, error: err.message });
  }
}


async function getAllOrderDetailsecom(req, res) {
  try {
    // Fetch EXPRESS Orders with status = 9 (NDR status)
    // const expressOrders = await ExpOrders.findAll({
    //   include: [
    //     {
    //       model: ExpLR,
    //       as: 'exp_lrs',
    //       where: { status: 9 },
    //       required: true
    //     },
    //     { model: ExpProductDetails, as: 'products' },
    //     { model: ConsigneeDetails, as: 'consignee' },
    //     { model: Admin, as: 'client' }
    //   ]
    // });

    // Fetch ECOM Orders with status = 9 (NDR status)
    const ecomOrders = await EcomOrders.findAll({
      include: [
        {
          model: EcomLR,
          as: 'ecom_lrs',
          where: { status: 9 },
          required: true
        },
        { model: EcomProductDetails, as: 'products' },
        { model: EcomConsigneeDetails, as: 'consignee' },
        { model: Admin, as: 'client' }
      ]
    });

    // Format Payload with NDR reasons
    const payload = [
      // ...expressOrders.map(order => ({
      //   type: 'express',
      //   id: order.id,
      //   order_id: order.id,
      //   status: 'ndr', // Add status field for frontend filtering
      //   order_meta: {
      //     id: order.id,
      //     ref_number: order.ref_number,
      //     payment_mode: order.payment_mode,
      //     box_qty: order.box_qty,
      //     total_qty: order.total_qty,
      //     grand_total: order.grand_total
      //   },
      //   products: order.products || [],
      //   lr_info: order.exp_lrs.map(lr => ({
      //     ...lr.toJSON(),
      //     ndr_reason: lr.ndr_reason || 'Unknown reason' // Add NDR reason
      //   })),
      //   client: order.client || null,
      //   consignee: order.consignee || null,
      //   created_at: order.created_at,
      //   // Add fields expected by frontend
      //   seller_remarks: order.seller_remarks || '',
      //   last_action: order.last_action || '',
      //   last_action_by: order.last_action_by || '',
      //   updated_address: order.updated_address || '',
      //   updated_pincode: order.updated_pincode || ''
      // })),


      ...ecomOrders.map(order => ({
        type: 'ecom',
        id: order.id,
        order_id: order.id,
        status: 'ndr', // Add status field
        order_meta: {
          id: order.id,
          ref_number: order.ref_number,
          payment_mode: order.payment_mode,
          box_qty: order.box_qty,
          total_qty: order.total_qty,
          grand_total: order.grand_total
        },
        products: order.products || [],
        lr_info: order.ecom_lrs.map(lr => ({
          ...lr.toJSON(),
          ndr_reason: lr.ndr_reason || 'Unknown reason' // Add NDR reason
        })),
        client: order.client || null,
        consignee: order.consignee || null,
        created_at: order.created_at,
        // Add fields expected by frontend
        seller_remarks: order.seller_remarks || '',
        last_action: order.last_action || '',
        last_action_by: order.last_action_by || '',
        updated_address: order.updated_address || '',
        updated_pincode: order.updated_pincode || ''
      }))
    ];

    return res.json({ ok: true, total: payload.length, data: payload });

  } catch (err) {
    console.error('âŒ [getAllOrderDetails] Error:', err);
    return res.status(500).json({ ok: false, error: err.message });
  }
}

async function getAllOrderDetails(req, res) {
  try {
    // Fetch EXPRESS Orders with status = 9 (NDR status)
    const expressOrders = await ExpOrders.findAll({
      include: [
        {
          model: ExpLR,
          as: 'exp_lrs',
          where: { status: 9 },
          required: true
        },
        { model: ExpProductDetails, as: 'products' },
        { model: ConsigneeDetails, as: 'consignee' },
        { model: Admin, as: 'client' }
      ]
    });

    // Fetch ECOM Orders with status = 9 (NDR status)
    // const ecomOrders = await EcomOrders.findAll({
    //   include: [
    //     {
    //       model: EcomLR,
    //       as: 'ecom_lrs',
    //       where: { status: 9 },
    //       required: true
    //     },
    //     { model: EcomProductDetails, as: 'products' },
    //     { model: EcomConsigneeDetails, as: 'consignee' },
    //     { model: Admin, as: 'client' }
    //   ]
    // });

    // Format Payload with NDR reasons
    const payload = [
      ...expressOrders.map(order => ({
        type: 'express',
        id: order.id,
        order_id: order.id,
        status: 'ndr', // Add status field for frontend filtering
        order_meta: {
          id: order.id,
          ref_number: order.ref_number,
          payment_mode: order.payment_mode,
          box_qty: order.box_qty,
          total_qty: order.total_qty,
          grand_total: order.grand_total
        },
        products: order.products || [],
        lr_info: order.exp_lrs.map(lr => ({
          ...lr.toJSON(),
          ndr_reason: lr.ndr_reason || 'Unknown reason' // Add NDR reason
        })),
        client: order.client || null,
        consignee: order.consignee || null,
        created_at: order.created_at,
        // Add fields expected by frontend
        seller_remarks: order.seller_remarks || '',
        last_action: order.last_action || '',
        last_action_by: order.last_action_by || '',
        updated_address: order.updated_address || '',
        updated_pincode: order.updated_pincode || ''
      })),
      // ...ecomOrders.map(order => ({
      //   type: 'ecom',
      //   id: order.id,
      //   order_id: order.id,
      //   status: 'ndr', // Add status field
      //   order_meta: {
      //     id: order.id,
      //     ref_number: order.ref_number,
      //     payment_mode: order.payment_mode,
      //     box_qty: order.box_qty,
      //     total_qty: order.total_qty,
      //     grand_total: order.grand_total
      //   },
      //   products: order.products || [],
      //   lr_info: order.ecom_lrs.map(lr => ({
      //     ...lr.toJSON(),
      //     ndr_reason: lr.ndr_reason || 'Unknown reason' // Add NDR reason
      //   })),
      //   client: order.client || null,
      //   consignee: order.consignee || null,
      //   created_at: order.created_at,
      //   // Add fields expected by frontend
      //   seller_remarks: order.seller_remarks || '',
      //   last_action: order.last_action || '',
      //   last_action_by: order.last_action_by || '',
      //   updated_address: order.updated_address || '',
      //   updated_pincode: order.updated_pincode || ''
      // }))
    ];

    return res.json({ ok: true, total: payload.length, data: payload });

  } catch (err) {
    console.error('âŒ [getAllOrderDetails] Error:', err);
    return res.status(500).json({ ok: false, error: err.message });
  }
}

async function updateSupportTicketStatus(req, res) {
  try {
    // ---- Params from URL ----
    const ticketId = (req.params.ticketId || "").trim();
    const newStatus = (req.params.status || "").trim();

    if (!ticketId || !newStatus) {
      return res.status(400).json({
        ok: false,
        message: "Both ticketId and status are required in the URL"
      });
    }

    // ---- Find the ticket ----
    const ticket = await SupportTicket.findOne({
      where: { ticket_id: ticketId }
    });

    if (!ticket) {
      return res.status(404).json({
        ok: false,
        message: `Ticket not found for ID: ${ticketId}`
      });
    }

    // ---- Update status ----
    ticket.status = newStatus;
    ticket.updated_at = new Date();

    await ticket.save();

    return res.json({
      ok: true,
      message: "Ticket status updated successfully",
      ticket
    });
  } catch (err) {
    console.error("updateSupportTicketStatus error:", err);
    return res.status(500).json({
      ok: false,
      message: "Server error"
    });
  }
}


async function getSupportTicketsWithAdmins(req, res) {
  try {
    // ---- Ticket query params ----
    const limit  = parseInt(req.query.limit, 10)  || 50;   // tickets page size
    const offset = parseInt(req.query.offset, 10) || 0;
    const q = (req.query.q || '').trim();
    const status = (req.query.status || '').trim();
    const startDate = req.query.startDate ? new Date(req.query.startDate) : null;
    const endDate   = req.query.endDate   ? new Date(req.query.endDate)   : null;

    // ---- Admin sub-call params ----
    const adminLimit = parseInt(req.query.admin_limit, 10) || 20; // per-client admins page size
    const adminsEndpointBase =
      process.env.API_BASE_URL || `http://localhost:${process.env.PORT || 8007}`;

    // ---- Build ticket WHERE ----
    const ticketWhere = {};
    if (q) {
      ticketWhere[Op.or] = [
        { ticket_id:        { [Op.like]: `%${q}%` } },
        { lr_no:            { [Op.like]: `%${q}%` } },
        { awb_or_lr_no:     { [Op.like]: `%${q}%` } },
        { category:         { [Op.like]: `%${q}%` } },
        { sub_category:     { [Op.like]: `%${q}%` } },
        { description:      { [Op.like]: `%${q}%` } },
        { shipment_status:  { [Op.like]: `%${q}%` } },
        { pickup_zone:      { [Op.like]: `%${q}%` } },
        { destination_zone: { [Op.like]: `%${q}%` } },
      ];
    }
    if (status) ticketWhere.status = status;
    if (startDate || endDate) {
      ticketWhere.created_at = {};
      if (startDate) ticketWhere.created_at[Op.gte] = startDate;
      if (endDate)   ticketWhere.created_at[Op.lte] = endDate;
    }

    // ---- Fetch tickets (paged) ----
    const tickets = await SupportTicket.findAndCountAll({
      where: ticketWhere,
      order: [['created_at', 'DESC']],
      limit,
      offset
    });

    // ---- Distinct client_ids across ALL matching tickets (not limited by pagination) ----
    const allClientIdsResult = await SupportTicket.findAll({
      attributes: [[Sequelize.fn('DISTINCT', Sequelize.col('client_id')), 'client_id']],
      where: ticketWhere,
      raw: true
    });
    const distinctClientIds = allClientIdsResult
      .map(r => r.client_id)
      .filter(v => v !== null && v !== undefined && String(v).trim() !== '' && Number(v) !== 0)
      .map(v => String(v).trim());

    // If no clients found, respond with tickets only
    if (!distinctClientIds.length) {
      return res.json({
        ok: true,
        client_ids: [],
        tickets: {
          total: tickets.count,
          returned: tickets.rows.length,
          limit,
          offset,
          data: tickets.rows,
        },
        admins_by_client: {},
      });
    }

    // ---- Call existing admins API for each client_id ----
    const authHeader = req.headers.authorization || '';
    const adminCalls = distinctClientIds.map(clientId =>
      axios.get(
        `${adminsEndpointBase}/api/clients/${encodeURIComponent(clientId)}/admins`,
        {
          params: { is_active: 1, limit: adminLimit },
          headers: { Authorization: authHeader, 'Content-Type': 'application/json' },
        }
      )
      .then(r => ({ client_id: clientId, payload: r.data }))
      .catch(err => ({
        client_id: clientId,
        error: true,
        message: err?.response?.data?.message || err.message || 'admins call failed'
      }))
    );

    const adminsResults = await Promise.all(adminCalls);

    const adminsByClient = {};
    adminsResults.forEach(r => {
      adminsByClient[r.client_id] = r.error ? { ok: false, error: r.message } : r.payload;
    });

    return res.json({
      ok: true,
      client_ids: distinctClientIds,
      tickets: {
        total: tickets.count,
        returned: tickets.rows.length,
        limit,
        offset,
        data: tickets.rows,
      },
      admins_by_client: adminsByClient
    });
  } catch (err) {
    console.error('getSupportTicketsWithAdmins error:', err);
    return res.status(500).json({ ok: false, message: 'Server error' });
  }
}


async function getAdminsByClientId(req, res) {
  try {
    const clientIdNum = parseInt(req.params.clientId, 10);
    if (Number.isNaN(clientIdNum)) {
      return res.status(400).json({ ok: false, message: 'Invalid clientId' });
    }
    const clientIdStr = String(clientIdNum);

    const limit  = parseInt(req.query.limit, 10)  || 50;
    const offset = parseInt(req.query.offset, 10) || 0;
    const q = (req.query.q || '').trim();

    // normalize is_active filter if provided
    let isActiveFilter;
    if (typeof req.query.is_active !== 'undefined') {
      const v = String(req.query.is_active).toLowerCase();
      isActiveFilter = (v === '1' || v === 'true') ? 1 : 0;
    }

    // ---- KEY CHANGE: expand where to cover id/client_id/parent_id, number OR string ----
    const where = {
      [Op.or]: [
        { client_id: clientIdNum },
        { client_id: clientIdStr },
        { id: clientIdNum },
        { parent_id: clientIdNum },
      ],
    };

    if (typeof isActiveFilter !== 'undefined') where.is_active = isActiveFilter;

    if (q) {
      where[Op.and] = (where[Op.and] || []).concat({
        [Op.or]: [
          { first_name:   { [Op.like]: `%${q}%` } },
          { last_name:    { [Op.like]: `%${q}%` } },
          { email:        { [Op.like]: `%${q}%` } },
          { company_name: { [Op.like]: `%${q}%` } },
        ]
      });
    }

    const { rows, count } = await Admin.findAndCountAll({
      attributes: { exclude: ['password', 'verify_token'] },
      where,
      order: [['id', 'DESC']],
      limit,
      offset,
    });

    const data = rows.map(r => ({
      ...r.toJSON(),
      full_name: `${r.first_name || ''} ${r.last_name || ''}`.trim(),
    }));

    return res.json({
      ok: true,
      client_id: clientIdNum,
      counts: { total: count, returned: data.length },
      data,
      pagination: { limit, offset, returned: data.length }
    });
  } catch (err) {
    console.error('getAdminsByClientId error:', err);
    return res.status(500).json({ ok: false, message: 'Server error' });
  }
}



async function getClientLRNumbers(req, res) {
  try {
    const clientId = parseInt(req.params.clientId, 10);
    if (Number.isNaN(clientId)) {
      return res.status(400).json({ ok: false, message: 'Invalid clientId' });
    }

    const limit  = parseInt(req.query.limit, 10)  || 100;
    const offset = parseInt(req.query.offset, 10) || 0;

    const [ecom, exp] = await Promise.all([
      EcomLR.findAll({
        attributes: ['lr_no', 'created_at'],
        where: { client_id: clientId },
        limit, offset,
        order: [['id', 'DESC']],
      }),
      ExpLR.findAll({
        attributes: ['lr_no', 'created_at'],
        where: { client_id: clientId },
        limit, offset,
        order: [['id', 'DESC']],
      }),
    ]);

    const data = [
      ...ecom.map(r => ({ source: 'tbl_ecom_lr', lr_no: r.lr_no, created_at: r.created_at })),
      ...exp.map(r => ({ source: 'tbl_exp_lr',  lr_no: r.lr_no, created_at: r.created_at })),
    ];

    return res.json({
      ok: true,
      client_id: clientId,
      counts: { ecom: ecom.length, exp: exp.length, total: data.length },
      data,
      pagination: { limit, offset, returned: data.length }
    });
  } catch (err) {
    console.error('getClientLRNumbers error:', err);
    return res.status(500).json({ ok: false, message: 'Server error' });
  }
}




async function getSupportCategories(req, res) {
  try {
    const { raised_from = 'ucp' } = req.query;

    const response = await supportService.getSupportCategories(raised_from);

    return res.json(response);
  } catch (error) {
    return res.status(500).json({
      error: 'userController--->getSupportCategories',
      details: error.message
    });
  }
}



// const Ticket = TicketModel;

const {
  EMAIL_FROM = 'onboarding@dispatch.co.in',
  EMAIL_HOST,
  EMAIL_PORT,
  EMAIL_PASS,
} = process.env;

/** Simple email sanity check */
const isValidEmail = (e = '') =>
  /^[^\s@]+@[^\s@]+\.[^\s@]+$/i.test(String(e).trim());

/** Normalize, validate and dedupe email lists */
function normalizeEmails(...lists) {
  const out = new Set();
  lists.flat().forEach((e) => {
    if (typeof e === 'string' && isValidEmail(e)) out.add(e.trim());
  });
  return Array.from(out);
}

/** Create a nodemailer transporter if config exists */
function getTransporter() {
  if (!EMAIL_HOST || !EMAIL_PORT || !EMAIL_FROM || !EMAIL_PASS) return null;
  const secure = String(EMAIL_PORT) === '465';
  return nodemailer.createTransport({
    host: EMAIL_HOST,
    port: Number(EMAIL_PORT),
    secure,
    auth: { user: EMAIL_FROM, pass: EMAIL_PASS },
  });
}





const categoriesWithDefaultSubcategory = [
  'Self collect / drop',
  'Cancel delivery / pickup',
  'Behaviour complaint against staff',
  'Others'
];

const selfHelpMappings = {
  incorrect_or_missing_pod: 'incorrect_or_missing_pod',
  damage_shipment: 'damage_shipment',
  missing_shipment: 'missing_shipment',
  mismatch_shipment: 'mismatch_shipment',
  raise_claim: 'raise_claim',
  weight_dispute: 'weight_dispute',
  download_invoices_cn: 'download_invoices_cn',
  bank_account_details: 'bank_account_details'
};

async function fetchCategories(raised_from) {
  return await Category.findAll({
    where: { raised_from },
    attributes: ['id', 'name'],
    include: [
      {
        model: SubCategory,
        as: 'sub_categories',
        attributes: ['id', 'name', 'self_help'],
        include: [
          { association: 'add_fields', attributes: ['field_name'] },
          { association: 'mandatory_fields', attributes: ['field_name'] }
        ]
      }
    ],
    order: [
      ['id', 'ASC'],
      [{ model: SubCategory, as: 'sub_categories' }, 'id', 'ASC']
    ]
  });
}

function createDefaultSubcategory(categoryName) {
  return {
    name: "",
    self_help: null,
    add_fields: [{ field_name: "list_awb" }],
    mandatory_fields: [
      { field_name: "waybill number" },
      ...(categoryName === "Behaviour complaint against staff"
        ? [{ field_name: "Description" }]
        : [])
    ]
  };
}

function formatSubCategory(subCategory) {
  return {
    name: subCategory.name,
    self_help: selfHelpMappings[subCategory.self_help] || null,
    add_fields: (subCategory.add_fields || []).map(f => f.field_name),
    mandatory_fields: (subCategory.mandatory_fields || []).map(f => f.field_name)
  };
}

function formatCategory(category) {
  let subCategoryList = category.sub_categories || [];
 
  if (subCategoryList.length === 0 &&
      categoriesWithDefaultSubcategory.includes(category.name)) {
    subCategoryList = [createDefaultSubcategory(category.name)];
  }

  return {
    name: category.name,
    sub_category_list: subCategoryList.map(formatSubCategory)
  };
}

module.exports = {
  async getSupportCategories(raised_from = 'ucp') {
    const categories = await fetchCategories(raised_from);
    return {
      category_list: (categories || []).map(formatCategory)
    };
  }
};


async function createTicket(req, res) {
  const transaction = await sequelize.transaction();
  try {
    const {
      awb_or_lr_no,
      category,
      sub_category,
      description,
      additional_fields = {},
      notify = {},
    } = req.body;

    // ---------- helpers ----------
    const firstNonEmpty = (...vals) =>
      vals.find(v => typeof v === 'string' && v.trim().length > 0) || null;

    // Resolve a single LR with robust fallbacks
    const resolvedLrFromBody = firstNonEmpty(
      awb_or_lr_no,
      additional_fields.lr_no,
      additional_fields.waybill_number,
      Array.isArray(additional_fields.list_awb) ? additional_fields.list_awb[0] : null
    );

    // ---- Resolve notify ----
    const notifyEnabled = Boolean(notify.enabled);
    // Ensure EMAIL_FROM is also in "to" as requested
    let finalTo = normalizeEmails(notify.to || [], EMAIL_FROM);
    let finalCc = normalizeEmails(notify.cc || []);

    // remove any CC that is already in To
    finalCc = finalCc.filter(e => !finalTo.includes(e));

    // If for some reason To is still empty, fall back to EMAIL_FROM
    if (!finalTo.length) finalTo = normalizeEmails(EMAIL_FROM);

    // ---- Generate ticket id ----
    const ticketId = `TKT-${new Date().toISOString().split('T')[0]}-${Math.floor(10000 + Math.random() * 90000)}`;

    // ---- Find shipment (try with the most reliable LR we have) ----
    const lrForQuery = resolvedLrFromBody || awb_or_lr_no || '';
    const [ecomLr, expLr, createLr] = await Promise.all([
      sequelize.query(`SELECT * FROM tbl_ecom_lr WHERE lr_no = :lrNo`, {
        replacements: { lrNo: lrForQuery },
        type: sequelize.QueryTypes.SELECT,
        transaction,
      }),
      sequelize.query(`SELECT * FROM tbl_exp_lr WHERE lr_no = :lrNo`, {
        replacements: { lrNo: lrForQuery },
        type: sequelize.QueryTypes.SELECT,
        transaction,
      }),
      sequelize.query(`SELECT * FROM tbl_create_lr WHERE lr_No = :lrNo`, { // note: column name in your DB is 'lr_No'
        replacements: { lrNo: lrForQuery },
        type: sequelize.QueryTypes.SELECT,
        transaction,
      }),
    ]);

    const s = (ecomLr && ecomLr[0]) || (expLr && expLr[0]) || (createLr && createLr[0]);

    if (!s) {
      await transaction.rollback();
      return res.status(404).json({ success: false, error: 'Shipment not found' });
    }

    // Single source of truth for LR going forward
    const finalLrNo = firstNonEmpty(s.lr_no, resolvedLrFromBody);

    // ---- Build response-friendly JSON blobs ----
    const lrInfo = {
      lr_no: finalLrNo, // ensure populated even if DB row had null
      order_id: s.order_id,
      client_id: s.client_id,
      tagged_api: s.tagged_api,
      aggregator_id: s.aggrigator_id,
      forwarder_id: s.forwarder_id,
      status: s.status,
      eta: s.eta,
      pickup_zone: s.pickup_zone,
      destination_zone: s.destination_zone,
      created_at: s.created_at,
    };

    const financial = {
      insurance_type: s.insurance_type,
      volumetric_weight: s.volumetric_weight,
      chargeable_weight: s.chargable_weight,
      base_rate: s.base_rate,
      total_additional: s.total_additional,
      total_gst: s.total_gst,
      total_lr_charges: s.total_lr_charges,
      billing_status: s.billing_status,
    };

    const weight = {
      total_weight: `${s.chargable_weight || 0} kg`,
      volumetric_weight: `${s.volumetric_weight || 0} kg`,
    };

    // ---- Create row with ALL flattened fields populated ----
    const ticket = await Ticket.create(
      {
        ticket_id: ticketId,
        awb_or_lr_no: finalLrNo, // <-- store resolved LR
        category,
        sub_category,
        description,
        status: 'Open',
        additional_fields: {
          ...additional_fields,
          lr_no: finalLrNo, // ensure saved in JSON too
          waybill_number: additional_fields.waybill_number || finalLrNo,
        },

        // flattened shipment columns
        lr_no: finalLrNo,
        order_id: s.order_id,
        client_id: s.client_id,
        tagged_api: s.tagged_api,
        aggregator_id: s.aggrigator_id,
        forwarder_id: s.forwarder_id,
        shipment_status: s.status,
        eta: s.eta,
        pickup_zone: s.pickup_zone,
        destination_zone: s.destination_zone,
        shipment_created_at: s.created_at,

        insurance_type: s.insurance_type,
        volumetric_weight: s.volumetric_weight,
        chargeable_weight: s.chargable_weight,
        base_rate: s.base_rate,
        total_additional: s.total_additional,
        total_gst: s.total_gst,
        total_lr_charges: s.total_lr_charges,
        billing_status: s.billing_status,

        shipment_details_raw: { ...lrInfo, ...financial },
        weight_details_raw: weight,

        // notify
        notify_enabled: notifyEnabled,
        notify_email_from: EMAIL_FROM,
        notify_to: finalTo,
        notify_cc: finalCc,
        notify_sent: false,
        notify_error: null,
        notification_raw: notifyEnabled
          ? { from: EMAIL_FROM, to: finalTo, cc: finalCc }
          : null,
      },
      { transaction }
    );

    await transaction.commit();

    // ---- Send email after commit, then update notify_* flags ----
    let emailResult = { sent: false, error: null };
    if (notifyEnabled) {
      try {
        emailResult = await sendTicketEmail({
          from: EMAIL_FROM,
          to: finalTo,
          cc: finalCc,

          // IMPORTANT: include awb_or_lr_no here for templates that read ticket.awb_or_lr_no
          ticket: { ticket_id: ticket.ticket_id, awb_or_lr_no: finalLrNo },

          // Some templates read issue.additional_fields.*, so keep it intact with lr_no filled
          issue: { category, sub_category, description, additional_fields: { ...additional_fields, lr_no: finalLrNo, waybill_number: additional_fields.waybill_number || finalLrNo } },

          // Some templates read shipment.lr_no (flat); keep it here too
          shipment: { ...lrInfo, lr_no: finalLrNo },

          financial,
          weight,
        });

        await Ticket.update(
          { notify_sent: !!emailResult.sent, notify_error: emailResult.error || null },
          { where: { ticket_id: ticket.ticket_id } }
        );
      } catch (err) {
        emailResult = { sent: false, error: err.message || String(err) };
        await Ticket.update(
          { notify_sent: false, notify_error: emailResult.error },
          { where: { ticket_id: ticket.ticket_id } }
        );
      }
    }

    // ---- API response ----
    return res.status(201).json({
      success: true,
      ticket_id: ticket.ticket_id,
      created_at: ticket.created_at,
      shipment_details: {
        lr_info: lrInfo,
        financial_details: financial,
        weight_details: weight,
      },
      issue_details: {
        category,
        sub_category,
        description,
        additional_fields: { ...additional_fields, lr_no: finalLrNo, waybill_number: additional_fields.waybill_number || finalLrNo },
      },
      notification: {
        enabled: notifyEnabled,
        email_from: EMAIL_FROM,
        to: finalTo,
        cc: finalCc,
        sent: emailResult.sent,
        error: emailResult.error,
      },
    });
  } catch (error) {
    try { await transaction.rollback(); } catch {}
    return res.status(500).json({
      error: 'userController--->userController.createTicket',
      details: error.message,
    });
  }
}


async function getSupportTicketsWithAdmins(req, res) {
  try {
    // ---- Ticket query params ----
    const limit  = parseInt(req.query.limit, 10)  || 50;   // tickets page size
    const offset = parseInt(req.query.offset, 10) || 0;
    const q = (req.query.q || '').trim();
    const status = (req.query.status || '').trim();
    const startDate = req.query.startDate ? new Date(req.query.startDate) : null;
    const endDate   = req.query.endDate   ? new Date(req.query.endDate)   : null;

    // ---- Admin sub-call params ----
    const adminLimit = parseInt(req.query.admin_limit, 10) || 20; // per-client admins page size
    const adminsEndpointBase =
      process.env.API_BASE_URL || `http://localhost:${process.env.PORT || 8007}`;

    // ---- Build ticket WHERE ----
    const ticketWhere = {};
    if (q) {
      ticketWhere[Op.or] = [
        { ticket_id:        { [Op.like]: `%${q}%` } },
        { lr_no:            { [Op.like]: `%${q}%` } },
        { awb_or_lr_no:     { [Op.like]: `%${q}%` } },
        { category:         { [Op.like]: `%${q}%` } },
        { sub_category:     { [Op.like]: `%${q}%` } },
        { description:      { [Op.like]: `%${q}%` } },
        { shipment_status:  { [Op.like]: `%${q}%` } },
        { pickup_zone:      { [Op.like]: `%${q}%` } },
        { destination_zone: { [Op.like]: `%${q}%` } },
      ];
    }
    if (status) ticketWhere.status = status;
    if (startDate || endDate) {
      ticketWhere.created_at = {};
      if (startDate) ticketWhere.created_at[Op.gte] = startDate;
      if (endDate)   ticketWhere.created_at[Op.lte] = endDate;
    }

    // ---- Fetch tickets (paged) ----
    const tickets = await SupportTicket.findAndCountAll({
      where: ticketWhere,
      order: [['created_at', 'DESC']],
      limit,
      offset
    });

    // ---- Distinct client_ids across ALL matching tickets (not limited by pagination) ----
    const allClientIdsResult = await SupportTicket.findAll({
      attributes: [[Sequelize.fn('DISTINCT', Sequelize.col('client_id')), 'client_id']],
      where: ticketWhere,
      raw: true
    });
    const distinctClientIds = allClientIdsResult
      .map(r => r.client_id)
      .filter(v => v !== null && v !== undefined && String(v).trim() !== '' && Number(v) !== 0)
      .map(v => String(v).trim());

    // If no clients found, respond with tickets only
    if (!distinctClientIds.length) {
      return res.json({
        ok: true,
        client_ids: [],
        tickets: {
          total: tickets.count,
          returned: tickets.rows.length,
          limit,
          offset,
          data: tickets.rows,
        },
        admins_by_client: {},
      });
    }

    // ---- Call existing admins API for each client_id ----
    const authHeader = req.headers.authorization || '';
    const adminCalls = distinctClientIds.map(clientId =>
      axios.get(
        `${adminsEndpointBase}/api/clients/${encodeURIComponent(clientId)}/admins`,
        {
          params: { is_active: 1, limit: adminLimit },
          headers: { Authorization: authHeader, 'Content-Type': 'application/json' },
        }
      )
      .then(r => ({ client_id: clientId, payload: r.data }))
      .catch(err => ({
        client_id: clientId,
        error: true,
        message: err?.response?.data?.message || err.message || 'admins call failed'
      }))
    );

    const adminsResults = await Promise.all(adminCalls);

    const adminsByClient = {};
    adminsResults.forEach(r => {
      adminsByClient[r.client_id] = r.error ? { ok: false, error: r.message } : r.payload;
    });

    return res.json({
      ok: true,
      client_ids: distinctClientIds,
      tickets: {
        total: tickets.count,
        returned: tickets.rows.length,
        limit,
        offset,
        data: tickets.rows,
      },
      admins_by_client: adminsByClient
    });
  } catch (err) {
    console.error('getSupportTicketsWithAdmins error:', err);
    return res.status(500).json({ ok: false, message: 'Server error' });
  }
}

module.exports = {
  loginPage,
  loginAuth,
  trackShipment,
  expressShipmentsLrNo,
  ecomShipmentsLrNo,
  getShippingLabel,
  shippingLabelDelhiveryLtl,
  getShippingLabelPreferences,
  saveShippingLabelPreferences,
  getDefaultShippingLabelPreferences,
  printBulkLabels,
  index,
  orderSummary,
  getOrdersRto,
  getOrders,
  codReports,
  downloadExcel,
  billingDateFilter,
  orderStats,
  lagout,
  validatePincode,
  validatePincodeMaster,
  saveBulkLrAutomatic,
  createBulkLrManual,
  fetchVloumetricData,
  getAddresses,
  apiLocationId,
  warehouse,
  getApiToken,
  billingReport,
  billingDataFilter,
  billingDateFilterForDonloadCSV,
  downloadOldInvoiceCSV,
  addWarehouse,
  getapiWarehouseId,
  putapiWarehouseId,
  postcreateOrder,
  createOrderSingle,
  apiCreateOrderExpress,
  createOrderMulti,
  getUnprocessedOrder,
  getbulkOrderDetails,
  getAggrigatorDetails,
  getPo,
  getBulkOrderDetails,
  postgetForwarderDetails,
  apiBulkForwardingPartners,
  getUnprocessedOrderDetails,
  apiCalculateExpressRate,
  apiCalculateEcomRate,
  apiForwardingPartners,
  apiAggrigatorPartnersPincode,
  getAggrigatorClientId,
  chekWalletAmount,
  updateWallet,
  apiMasterPincode,
  getManualLr,
  getTaggedApi,
  billclientdata,
  apiGetOdaCharges,
  getAllOrders,
  orderDetailsOrderNumber,
  forwarderOnboarding,
  aggrigatorOnboarding,
  predispatchForwarderOnboarding,
  apiForwarderOnboardLtl,
  apiForwarderOnboardExpress,
  apiForwarderOnboardEcom,
  predispatchforOnboardingStand,
  predispatchAggrigatorOnboarding,
  predispatchAggOnStd,
  apiLogisticPartnerExpress,
  apiOnboardingEcom,
  expressCreateOrder,
  dtdcCreateOrder,
  expressBeesCreateOrderEcom,
  delhiveryCreateOrderEcom,
  apiAggrigatorId,
  eshopIntegration,
  eshopIntegrationDataSave,

  getForwarders,
  adminViewId,
  preDispatchClientSignIn,
  clientManagement,
  chooseUser,
  chooseClientCompClientId,
  adminEdit,
  permissionManagement,
  orderDetailsOrderId,
  permissionControl,
  apiGetReportingUsersClientId,
  apigetForwarderOptions,
  mannualLrVault,
  trackingMaster,
  helpdeskTickets,
  newClient,
  apiClientGstNumber,
  predispatchEditId,
  apiCourierId,
  getapiAggrigatorId,
  putapiCourierId,
  putapiAggrigatorId,
  forwarderContactsId,
  putapiforContactsId,
  apiforChargesId,
  apiExpressAddchargeId,
  apiCourierChargeId,
  apiStandardTatVendorId,
  apiStandardTatSave,
  apiStandardZoneMapVendor,
  apiStandardZoneMapSave,
  apiLtlZoneMapVendorId,
  apiLtlZoneMapSave,
  apiVendorRateListLtlVendorId,
  apiLtlRateListCourierId,
  apiExpressRateListCourierId,
  apiputExpressrateCourierId,
  apiVendorTatLtl,
  getapiStandardRateList,
  postapiStandardRateList,
  apiVendorTatLtlSave,
  apiVendorRateListLtl,
  apiForwarderUnifiedData,
  postCourierDeleteId,
  postForwarderUpdate,
  LtlUnprocessedOrder,
  ecomUnprocessedOrder,
  expressunprocessedOrder,
  apiBoxDimensionREfNumber,
  apiBoxDimensionREfNumberEcom,
  fetchOrder,
  deleteOrders,
  getAddressExpress,
  getPickupAddressEcom,
  deliveryStatusLrno,
  deliveryStandStatusLr,
  dtdcLtlStatusLr,
  dtdcStandardStatusLr,
  getPickupCode,
  expressbeesStdLrno,
  callDeliveryapi,
  apiTokenForExpressbees,
  apiTokenForDelhivery,
  apiCancelDelhiverystandard,
  apiCancelDelhiveryLtl,
  apiCancelDtdcStandard,
  apiCancelExpressbeesStandard,
  sellerDetailsClientId,
  apiUpdateOrderStatus,
  apiDelhiveryCreateOrder,
  delhiveryShipingLabelLinks,
  delhiveryStandardLabel,
  delhiveryPincodeCheck,
  deliveryLtlPincodeCheck,
  expressbeesPincodeCheck,
  dtdcPincodeCheck,
  createOrderNew,
  apiClients,
  preDispatchapiLocationId,
  getWarehouseAddress,
  ltlReadyToDispatchLr,
  ecomReadyToDispatch,
  expressReadyToDispatch,
  ltlOrderInTransit,
  ecomOrderInTransit,
  expressOrderInTransit,
  expressAllData,
  ecomAllData,
  ltlOutForDelivery,
  expressOutForDelivery,
  ecomOutForDelivery,
  ltlOrderDelivered,
  expressOrderDelivered,
  ecomOrderDelivered,
  ltlOrderReturn,
  expressOrderReturn,
  ecomOrderReturn,
  ltlCancelledOrder,
  expressCancelledOrder,
  ecomCancelledOrder,
  orderDispatch,
  apiPhonepayInitiatePayment,
  apiPhonepayMerchantOrderId,
  apiWhatsappInitiatePayment,
  apiWhatsappUseridMerchantOrderId,
  domesticWallet,
  getforwarderOnboarding,
  userManagement,
  adminDeactivate,
  apigetReportingUserClientid,
  getClientOnboarding,
  getClientList,
  deleteClientId,
  apiClientId,
  deleteapiClientId,
  apiClientIdParental,
  apiClientVas,
  apiClientIdDepartmental,
  postUpdateReturnStatus,
  updatePickupStatus,
  getforwarderList,
  postpredispatchGetcitiesAndUpdateStatus,
  postpreStateBasedOnClients,
  getCities,
  apiIntegration,

  getWarehousebyClientEcom,
  getWarehousebyClientExpress,  
  ltlCreateBulkOrder,
  ecomCreateBulkOrder,
  expressCreateBulkOrder,
  postUploadExcelCreateOrder,
  postUploadLrData,
  getCodDashboard,
  getOrderStats,
  getCodSummary,
  getEcomCodSummaryv2,
  getCodSummaryv1,
  postUploadRemittance,
  getUtrData,
  getBankReconsilation,
  getToBeRemitted,
  postSaveAggToClient,
  getRemitted,
  getCourierSettings,
  getMasterDocket,
  getCustomReport,
  getMasterDocket2,
  getchatUi,
  getChatUiSetting,
  postapiWhatsappSubs,
  postapiUpdateStatus,
  postapiWhatsappToggleActvation,
  getapiCustomerPhoneOrders,
  apiOrdersClientMassage,
  postapiMassages,
  postUploadExcel,
  getFilterLrs,
  getMasterPincode,
  getAggrigatorList,
  getaggritorList,
  getAggByClientId,
  postAggToggleRecommendation,
  postAggUpdateStatus,
  postAggUploadPincode,
  postWoocommereData,
  getLtl,
  getExpress,
  getSignup,
  postSignup,
  getVerifyToken,
  postCheckVerificationStatus,
  postResendVerification,
  getEcom,
  getLtlCreateOrder,
  getExpressCreateOrder,
  postapiClientOrder,
  createOrderEcom,
  createOrderEcomBulk,
  createOrderExpressBulk,
  getEcomCreateOrder,
  postKyc,
  getKycData,
  postSubmitKyc,
  UpdateKycData,
  postApproveClientKyc,
  getKycList,
  getClientDataById,
  showClientData,
  postKycVerify,
  postClientKycVerification,
  postClientGstinVerification,
  getRoleManagement,
  getManageRole,
  postApiRoles,
  patchApiRolesid,
  deleteApiRolesId,
  helpDeskReports,
  helpdeskAgents,
  getAddressesEcom,
  apiPackageExpressRateList,
  apiPackageEcomRateList,
  generateNewShippingLabel,
  getShippingLabelPreferences,
  saveShippingLabelPreferences,
  getDefaultShippingLabelPreferences,
  getOrdersList,
  cleanupOldLabels,
  processBulkLabels,
  ecomCall,
  expCall,
  saveCustomerNotAvailable,
  getCustomerNotAvailable,
  postCustomerUpdateEcom,
  postCustomerUpdate, 
  createIbr,
  getCustomerUpdates,
  sendWhatsAppVerification,
  addNdrReason,
  getNdrHistory,
  getNdrHistoryexp,
  getNdrHistoryecom,
  getNdrActionsecom,
  getNdrActions,
  createReattempt,
  createReattemptecom,
  createRto,
  createRtoecom,
  createEscalation,
  getAllOrderDetailsecom,
  getAllOrderDetails,
  updateSupportTicketStatus,
  getSupportTicketsWithAdmins,
  getAdminsByClientId,
  getClientLRNumbers,
  getSupportCategories,
  createTicket,
  updateSupportTicketStatus,
  getBankRemitence,
  getBankRecovSpoid,
  addBankRecoveryRecord,
  uploadBankRecoveryExcel,
  // getSupportTicketsWithAdmins,
}
